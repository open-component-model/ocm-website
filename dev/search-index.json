[{"content":"","date":"0001-01-01","id":0,"permalink":"/dev/docs/overview/","summary":"","tags":[],"title":"Overview"},{"content":"The Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It’s built to support secure, reliable delivery and deployment of software—across cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\nBelow are the main projects, but please also check out the others in our Github org.\nOCM Specification - The ocm-spec repository contains the OCM specification, which provides a formal description of OCM and its format to describe software artifacts and a storage layer to persist those and make them accessible from remote. OCM Core Library - The ocm core library contains an API for interacting with OCM elements. A guided tour on how to work with the library can be found here. OCM CLI - With the ocm command line interface end users can interact with OCM elements, helping them create component versions and embed them in CI and CD processes. Examples can be found in this Makefile. OCM Controller - The ocm-controllers are designed to enable the automated deployment of software using the Open Component Model and Flux. OCM Website - The ocm-website you are currently visiting. It is built using Hugo and hosted on Github Pages. ","date":"0001-01-01","id":1,"permalink":"/dev/docs/overview/about/","summary":"\u003cp\u003eThe Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It’s built to support secure, reliable delivery and deployment of software—across cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\u003c/p\u003e","tags":[],"title":"About the OCM Project"},{"content":"Software development is complex. Most organizations struggle with fragmented tools, complicated workflows, and the challenge of managing software across different environments - cloud, on-premises, hybrid, and even air-gapped networks.\nTraditional approaches lead to:\nComplicated, custom CI/CD pipelines Inconsistent software delivery Difficulty tracking and securing software components Lack of a standard way to describe software and its artifacts Requirements Towards a Modern Software Component Model Community-First Approach A truly modern software component model cannot live in isolation. It needs an active, diverse community to grow, adapt, and remain relevant. Open source projects invite users and maintainers to propose ideas, report issues, and deliver improvements. Lowering entry barriers nurtures diverse perspectives, accelerates innovation, and ensures real-world feedback shapes priorities. Continuous collaboration - through design discussions, reviews, and documentation — builds trust and fosters adoption across industries. In this way, the community itself becomes the guarantor of quality, relevance, and long-term sustainability.\nImmutable and Unique Component Identity A crucial requirement is the ability to assign an immutable and globally unique Component Identity to each software component. This identifier acts as a \u0026ldquo;correlation ID,\u0026rdquo; allowing all lifecycle management processes, such as security compliance and vulnerability scanning, to correlate their outputs to a single, identifiable software component.\nArtifact Descriptions with Location Information The model should facilitate the description of all technical artifacts required for deploying a specific version of a software component. This list, termed a \u0026ldquo;Software Bill of Delivery\u0026rdquo; (SBoD), outlines only the artifacts needed for successful deployment. Additionally, the description must encompass the technical access location from which each artifact can be retrieved.\nSeparation of Component Identity and Artifact Location Organizations often need to:\nStore artifacts in local registries Work in environments with limited or no internet access (air-gapped) Move artifacts between different systems and environments The Component Identity must remain stable across all boundaries and system environments, while the artifact locations should be changeable. The ideal model separates the component identity from its artifact locations, allowing maximum flexibility.\nTechnology Neutrality Real-world software environments are messy. A good component model must:\nSupport modern containerized applications Handle legacy software Work across clouds, on-premises, and hybrid infrastructures Technology-Agnostic and Forward-Thinking Design The model should:\nAdapt easily to emerging technologies Avoid constant rewrites of existing tools and processes Stay relevant as software development evolves Cover both legacy and modern software Built-In Security Automatic capabilities for:\nSigning software components Verifying artifact integrity Protecting against tampering Maintaining trust across changing artifact locations Collaborative Potential Enable teams to:\nEasily share and reuse trusted components Create a network of verifiable, reusable and high-quality software building blocks OCM: Solving Software Lifecycle Complexity The Open Component Model (OCM) is designed to tackle these challenges head-on. It provides a standardized approach to describing, managing, and sharing software components that brings order to software lifecycle management. By linking additional metadata using OCM’s identities, it facilitates asynchronous handling of various lifecycle management processes, such as compliance checks, security scans, deployments, and more, in a decoupled and streamlined manner.\nCommunity-Driven Governance: OCM’s open governance and transparent contribution workflow empower anyone to asynchronously propose, review, and merge enhancements — keeping its software lifecycles aligned with evolving community needs.\nUnique Component Identities: OCM assigns an immutable, globally unique ID to each component, enabling seamless correlation across all lifecycle tools and processes.\nSoftware Bill of Delivery: OCM enables the specification of all artifacts required for delivering a software component. This compilation, termed a \u0026ldquo;Software Bill of Delivery\u0026rdquo; (SBoD), lists all artifacts and information how to access them.\nStable IDs, Changing Artifact Locations: OCM separates immutable component IDs from the changeable artifact locations, essential for private and air-gapped environments.\nTechnology Agnosticism: Being agnostic to implementation technologies like container images, NPM packages or binaries, OCM can handle both cloud-native and legacy apps.\nFuture-Proof Extensibility: OCM\u0026rsquo;s extensible design allows simple adaptation to emerging trends without disrupting existing tooling.\nTrusted Signatures: Built-in signing and verification ensure artifact integrity even as artifact locations change over time.\nOCM creates a \u0026ldquo;single source of truth\u0026rdquo; for software artifacts. It streamlines compliance checks, security scans, and deployments by providing a consistent, location-independent way to identify, access, exchange, and verify software components.\nBy making software component management more transparent, secure, and efficient, OCM helps organizations transform their software delivery from a complicated puzzle into a smooth, manageable process.\n","date":"0001-01-01","id":2,"permalink":"/dev/docs/overview/benefits-of-ocm/","summary":"\u003cp\u003eSoftware development is complex. Most organizations struggle with fragmented tools, complicated workflows, and the challenge of managing software across different environments - cloud, on-premises, hybrid, and even air-gapped networks.\u003c/p\u003e","tags":[],"title":"Benefits of OCM"},{"content":"As the Open Component Model (OCM) revolves around components, it is essential to establish a common understanding of the fundamental terminology employed throughout this website. The following section provides concise definitions of key terms, laying the groundwork for the documentation and tutorials that follow.\nFor a comprehensive exploration of every aspect of this topic, please refer to the OCM Specification OCM Specification and its Glossary.\nComponents in OCM The concept of a Component can vary widely, often defined with very specific views on granularity or other technical attributes. OCM takes a different approach, focusing on the intended purpose and overall meaning of components.\nIn OCM, Components group a set of semantically related Component Versions. Each Component Version is uniquely and globally identified by a Component Identity and can reference other Components. A Component Version can also contain Artifacts and a formal description on how to access them. These Artifacts come in two categories: resources, which describe the payload (e.g.,OCI images), and sources, which describe the input for creating resources (e.g., source code).\nOCM Coordinates OCM Coordinates are used to reference OCM Component Versions and Artifacts within OCM Component Versions. Coordinates referring to an OCM Component Version are also called Component Identity, whereas relative Coordinates referring to an artifact are called Artifact Identity. Component Identities are globally unique and may be used to refer to full Component Versions. Artifact Identities are always relative to a Component Version and may only be used in conjunction with a Component Identity.\nIn detail:\nComponent Identity Component Name: Identifies a component. Must start with URL-prefix that should be controlled by the owner of the component to avoid collisions. Component Version: If used with a Component name, identifies a specific Component Version. Must adhere to \u0026ldquo;relaxed SemVer\u0026rdquo; (major, minor (+ optional patch level) - optional v-prefix). Artifact Identity Within a Component Version, all Artifacts must have a unique identity. Every Source Identity or Resource Identity always includes a name that typically expresses the intended purpose.\nArtifacts may also have additional extraIdentity attributes that contribute to their identities. extraIdentity attributes are string-to-string maps.\nExamples Assuming there is a component named example.org/my-component with two versions, 1.2.3 and 1.3.0, declaring a resource with the name my-resource, the following OCM Coordinates can be used to reference different elements:\nexample.org/my-component: all versions of the component (1.2.3 + 1.3.0) example.org/my-component:1.2.3: version 1.2.3 of the component example.org/my-component:1.2.3:resource/my-resource: my-resource as declared by the component version ","date":"0001-01-01","id":3,"permalink":"/dev/docs/overview/important-terms/","summary":"\u003cp\u003eAs the Open Component Model (OCM) revolves around components, it is essential to establish a common understanding of the fundamental terminology employed throughout this website. The following section provides concise definitions of key terms, laying the groundwork for the documentation and tutorials that follow.\u003c/p\u003e","tags":[],"title":"Important Terms"},{"content":"Where to find the OCM specification The most up-to-date version of the OCM specification offers you a deep insight to all technical details of the Open Component Model and explains all elements the model OCM is based on.\n","date":"0001-01-01","id":4,"permalink":"/dev/docs/overview/specification/","summary":"\u003ch2 id=\"where-to-find-the-ocm-specification\"\u003eWhere to find the OCM specification\u003c/h2\u003e\n\u003cp\u003eThe most up-to-date version of the \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm-spec/blob/main/README.md\" target=\"_blank\" rel=\"noopener\"\u003eOCM specification\u003c/a\u003e offers you a deep insight to all technical details of the Open Component Model and explains all elements the model OCM is based on.\u003c/p\u003e","tags":[],"title":"Specification"},{"content":"","date":"0001-01-01","id":5,"permalink":"/dev/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"This and the following chapters walk you through some basic steps to get started with OCM concepts and the OCM CLI. You will learn how to create a component version, display and examine the component, and how to transport and sign it.\nTo follow the steps described in this section, you will need to:\nInstall the OCM Command Line Interface (CLI) The CLI is used to interact with component versions and registries. Install it like described in Installing the OCM CLI.\nObtain Access to an OCM Repository This can be any OCI registry for which you have write permission (e.g., GitHub Packages). An OCM repository based on an OCI registry is identified by a leading OCI repository prefix. For example: ghcr.io/\u0026lt;YOUR-ORG\u0026gt;/ocm.\nObtain Credentials for the CLI to Access the OCM Repository Using the Docker Configuration File The easiest way to do this is to reuse your Docker configuration json file.\nTo do this, create a file named .ocmconfig in your home directory with the following content:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 # The path to the Docker configuration file dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true - type: attributes.config.ocm.software attributes: cache: ~/.ocm/cache\rUsing Basic Authentication Alternatively, you can use basic authentication. Create a file named .ocmconfig in your home directory with the following content:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: ociRegistry hostname: \u0026lt;YOUR-REGISTRY\u0026gt;/\u0026lt;YOUR-REPO\u0026gt; # e.g. ghcr.io/acme/acme credentials: - type: Credentials properties: username: \u0026lt;YOUR-USERNAME\u0026gt; password: \u0026lt;YOUR-PASSWORD\u0026gt;\rMore information on the credentials topic can be seen by running the OCM CLI help topic command ocm credential-handling and in this guide with many examples for different repository types.\n","date":"0001-01-01","id":6,"permalink":"/dev/docs/getting-started/prerequisites/","summary":"\u003cp\u003eThis and the following chapters walk you through some basic steps to get started with OCM concepts and the OCM CLI.\nYou will learn how to create a component version, display and examine the component, and how to transport and sign it.\u003c/p\u003e","tags":[],"title":"Prerequisites"},{"content":"Overview You can install the latest release of the OCM CLI from any of the following sources (more details below):\nHomebrew Nix AUR Docker Podman GitHub Releases Bash To install with bash for macOS or Linux, execute the following command:\ncurl -s https://ocm.software/install.sh | sudo bash\rInstall using Homebrew # Homebrew (macOS and Linux) brew install open-component-model/tap/ocm\rInstall using Nix (with Flakes) # Nix (macOS, Linux, and Windows) # ad hoc cmd execution nix run github:open-component-model/ocm -- --help nix run github:open-component-model/ocm#helminstaller -- --help # install development version nix profile install github:open-component-model/ocm # or release \u0026lt;version\u0026gt; nix profile install github:open-component-model/ocm/\u0026lt;version\u0026gt; #check installation nix profile list | grep ocm # optionally, open a new shell and verify that cmd completion works ocm --help\rsee: Flakes\nInstall from AUR (Arch Linux User Repository) package-url\n# if not using a helper util git clone https://aur.archlinux.org/ocm-cli.git cd ocm-cli makepkg -i\rAUR Documentation\nInstall using Docker / Podman podman run -t ghcr.io/open-component-model/ocm:latest --help\rBuild and Run It Yourself podman build -t ocm . podman run --rm -t ocm --loglevel debug --help\ror interactively:\npodman run --rm -it ocm /bin/sh\rYou can pass in the following arguments to override the predefined defaults:\nGO_VERSION: The golang version to be used for compiling. ALPINE_VERSION: The alpine version to be used as the base image. GO_PROXY: Your go proxy to be used for fetching dependencies. Please check hub.docker.com for possible version combinations.\npodman build -t ocm --build-arg GO_VERSION=1.22 --build-arg ALPINE_VERSION=3.19 --build-arg GO_PROXY=https://proxy.golang.org .\ron MS Windows using Chocolatey choco install ocm-cli\rsee: chocolatey community package: ocm-cli\nusing winget Deprecated: Please note, winget packages are no longer provided. Any existing packages are still working, but no new packages are built and published to winget repository.\nBuilding from Source Prerequisites git golang make Installation Process Clone the open-component-model/ocm repo:\ngit clone https://github.com/open-component-model/ocm\rEnter the repository directory (cd ocm/) and install the cli using make:\nmake install\rPlease note that the OCM CLI is installed in your go/bin directory, so you might need to add this directory to your PATH.\nVerify the installation:\nocm version\r","date":"0001-01-01","id":7,"permalink":"/dev/docs/getting-started/installation/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eYou can install the latest release of the OCM CLI from any of the following sources (more details below):\u003c/p\u003e","tags":[],"title":"Installing the OCM CLI"},{"content":"Creating and Storing Component Versions Component Versions are created using a component-constructor.yaml file, which is a description file that contains one or multiple components. The file describes the components and their artifacts - resources and sources, metadata in form of labels and references to other components.\nComponent Versions are locally stored in archives using the Common Transfer Format (CTF). A CTF archive may contain any number of component versions and is used to transfer components to and between component repositories.\nNote that a CTF archive itself is also an OCM repository, so it can be used as source or target for component transfer operations using the OCM CLI.\nThe command ocm add componentversions directly creates a component version from a component-constructor.yaml file and stores it in a local CTF archive.\nCreate a Component Version In this example we will use the The ocm CLI tool to create a very basic component version that contains a local resource and a resource that is accessed from a remote location. The local resource is the podinfo Helm Chart and the referenced resource is a Docker image stored in an OCI registry.\nWe start by creating a test folder where we execute all required steps for this example and navigating into it:\nmkdir /tmp/helloworld cd /tmp/helloworld\rNow we download the podinfo Helm Chart that we want to use as local resource and extract it:\nhelm repo add podinfo https://stefanprodan.github.io/podinfo helm pull --untar podinfo/podinfo\rCreate a file component-constructor.yaml, which describes all elements of the component. You can use our public configuration schema to validate the configuration. The schema is available at https://ocm.software/schemas/configuration-schema.yaml and can be used in your editor to validate the configuration (e.g., in Visual Studio Code).\nComponent versions need to have at least a name, version and provider attribute. All other attributes are optional. Check out an example component descriptor or the OCM Specification to see all available attributes.\nAs mentioned before our example component will just contain a Helm Chart and a Docker image as resources:\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: - name: github.com/acme.org/helloworld # version needs to follow \u0026#34;relaxed\u0026#34; SemVer version: 1.0.0 provider: name: acme.org resources: # local Helm chart resource - name: mychart type: helmChart input: type: helm path: ./podinfo # remote image resource - name: image type: ociImage version: 1.0.0 access: type: ociArtifact imageReference: gcr.io/google_containers/echoserver:1.10\rA resource is described either by its access information to a remote repository or by locally provided resources.\nFor remote access, the field access is used to describe the access method. The type field is used to specify the kind of access.\nIf the resource content is taken from local resources, the field input is used to specify the access to the local resources. Similarly to the access attribute, the kind of the input source is described by the field type.\nAvailable access and input types are described here.\nFor more complex scenarios, the description files might use variable substitution (templating), see Best Practices.\nAdd Component Version to CTF archive To store our component version locally and to make it transportable, we now add it to a CTF archive using the following command. The option --create is used to create a new CTF archive if it does not exist:\nocm add componentversions --create --file ctf-hello-world component-constructor.yaml\rprocessing component-constructor.yaml... processing document 1... processing index 1 found 1 component adding component github.com/acme.org/helloworld:1.0.0... adding resource helmChart: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociArtifact: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;...\rWhat happened? The command creates the CTF archive (option --create) and adds the listed components with the described resources.\nctf-hello-world/ ├── artifact-index.json └── blobs ├── sha256.125cf912d0f67b2b49e4170e684638a05a12f2fcfbdf3571e38a016273620b54 ├── sha256.1cb2098e31e319df7243490464b48a8af138389abe9522c481ebc27dede4277b ├── sha256.974e652250ffaba57b820c462ce603fc1028a608b0fa09caef227f9e0167ce09 └── sha256.d442bdf33825bace6bf08529b6f00cf0aacc943f3be6130325e1eb4a5dfae3a5\rThe transport archive\u0026rsquo;s contents can be found in artifact-index.json. This file contains the list of component version artifacts to be transported.\njq . ${CTF_ARCHIVE}/artifact-index.json\r{ \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;artifacts\u0026#34;: [ { \u0026#34;repository\u0026#34;: \u0026#34;component-descriptors/github.com/acme/helloworld\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:d3cf4858f5387eaea194b7e40b7f6eb23460a658ad4005c5745361978897e043\u0026#34; } ] }\rThe content of the transport archive is stored as OCI artifacts. Notice that the repository names of Component Version artifacts (found at artifacts.respository) are prefixed by component-descriptors/.\nThe component version is described as an OCI manifest:\njq . ${CTF_ARCHIVE}/blobs/sha256.d3cf4858f5387eaea194b7e40b7f6eb23460a658ad4005c5745361978897e043\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0dd94de11c17f995648c8e817971581bce4b016f53d4d2bf2fff9fcda37d7b95\u0026#34;, \u0026#34;size\u0026#34;: 201 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:4ab29c8acb0c8b002a5037e6d9edf2d657222da76fee2a10f38d65ecd981d0c6\u0026#34;, \u0026#34;size\u0026#34;: 3072 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:b2dc5088f005d27ea39b427c2e67e91e2b6b80d3e85eca2476a019003c402904\u0026#34;, \u0026#34;size\u0026#34;: 16122 } ] }\rNotice that the output of the component version above contains the component descriptor as one of the layers. It can be identified by its content type, which is application/vnd.ocm.software.component-descriptor.v2+yaml+tar. In this case, the component descriptor can be displayed with the following command:\ntar xvf ${CTF_ARCHIVE}/blobs/sha256.4ab29c8acb0c8b002a5037e6d9edf2d657222da76fee2a10f38d65ecd981d0c6 -O - component-descriptor.yaml\rmeta: schemaVersion: v2 component: name: github.com/acme/helloworld version: 1.0.0 provider: acme.org componentReferences: [] repositoryContexts: [] resources: - access: localReference: sha256:b2dc5088f005d27ea39b427c2e67e91e2b6b80d3e85eca2476a019003c402904 mediaType: application/vnd.oci.image.manifest.v1+tar+gzip referenceName: github.com/acme/helloworld/podinfo:6.7.0 type: localBlob digest: ... name: mychart relation: local type: helmChart version: 1.0.0 - access: imageReference: gcr.io/google_containers/echoserver:1.10 type: ociArtifact digest: ... name: image relation: external type: ociArtifact version: 1.0.0 sources: []\rThe other elements listed as layers describe the blobs for the local resources stored along with the component version. The digests can be seen in the localReference attributes of the component descriptor.\n","date":"0001-01-01","id":8,"permalink":"/dev/docs/getting-started/create-component-version/","summary":"\u003ch2 id=\"creating-and-storing-component-versions\"\u003eCreating and Storing Component Versions\u003c/h2\u003e\n\u003cp\u003eComponent Versions are created using a \u003ccode\u003ecomponent-constructor.yaml\u003c/code\u003e file, which is a description file that contains one or multiple components. The file describes the components and their artifacts - resources and sources, metadata in form of labels and references to other components.\u003c/p\u003e","tags":[],"title":"Create a Component Version"},{"content":"List Component Versions To show a component stored in an OCM repository or CTF archive (which itself is an OCM repository), the ocm get componentversion command can be used:\nocm get componentversion ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0\rCOMPONENT VERSION PROVIDER ocm.software/toi/demo/helmdemo 0.12.0 ocm.software\rTo see the component descriptor of the displayed component version, use the output format option -o yaml:\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -o yaml\rcomponent: componentReferences: - componentName: ocm.software/toi/installers/helminstaller name: installer version: 0.12.0 creationTime: \u0026#34;2024-07-19T14:32:13Z\u0026#34; name: ocm.software/toi/demo/helmdemo provider: ocm.software repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: open-component-model/ocm type: OCIRegistry resources: - access: localReference: sha256:8a2fe6af4ce56249094622c9d618e24b4cfb461a7dfa6a42cce31749189bc499 mediaType: application/vnd.toi.ocm.software.package.v1+yaml type: localBlob digest: ... labels: - name: commit value: e5ca3001323b75ee5793a786089f1f410e9e8db3 name: package relation: local type: toiPackage version: 0.12.0 - access: imageReference: ghcr.io/open-component-model/ocm/ocm.software/toi/demo/helmdemo/echoserver:0.1.0 type: ociArtifact digest: ... name: chart relation: local type: helmChart version: 0.12.0 ...\rTo refer to the content of a component repository, the component name can be appended to the repository specification separated by // (you can also use the --repo option to specify the repository).\nIn the example above, ghcr.io/open-component-model/ocm is the OCM repository, whereas ocm.software/toi/demo/helmdemo is the component stored in this component repository.\nOptionally, a specific version can be appended, separated by a colon (:). If no version is specified, all component versions will be displayed.\nWith the option --recursive, it is possible to show the complete component version, including the component versions it references.\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive\rREFERENCEPATH COMPONENT VERSION PROVIDER IDENTITY ocm.software/toi/demo/helmdemo 0.12.0 ocm.software ocm.software/toi/demo/helmdemo:0.12.0 ocm.software/toi/installers/helminstaller 0.12.0 ocm.software \u0026#34;name\u0026#34;=\u0026#34;installer\u0026#34;\rTo get a tree view, add the option -o tree:\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive -o tree\rNESTING COMPONENT VERSION PROVIDER IDENTITY └─ ⊗ ocm.software/toi/demo/helmdemo 0.12.0 ocm.software └─ ocm.software/toi/installers/helminstaller 0.12.0 ocm.software \u0026#34;name\u0026#34;=\u0026#34;installer\u0026#34;\rAs mentioned before a CTF archive itself is an OCM repository, so we can execute the same commands on a CTF archive. So, let\u0026rsquo;s get the information about the component github.com/acme.org/helloworld we created in the previous step and that we stored in the CTF archive /tmp/helloworld/ctf-hello-world:\nocm get cv /tmp/helloworld/ctf-hello-world//github.com/acme.org/helloworld:1.0.0\rCOMPONENT VERSION PROVIDER github.com/acme.org/helloworld 0.1.0 ocm.software\rList the Resources of a Component Version To list the resources found in a component version tree, the command ocm get resources can be used:\nocm get resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive -o tree\rCOMPONENT NAME VERSION IDENTITY TYPE RELATION └─ ocm.software/toi/demo/helmdemo 0.12.0 ├─ chart 0.12.0 helmChart local ├─ config-example 0.12.0 yaml local ├─ creds-example 0.12.0 yaml local ├─ image 1.0 ociImage external ├─ package 0.12.0 toiPackage local └─ ocm.software/toi/installers/helminstaller installer 0.12.0 ├─ toiexecutor 0.12.0 toiExecutor local └─ toiimage 0.12.0 ociImage local\rDownload the Resources of a Component Version Use the ocm download command to download resources such as component versions, individual resources or artifacts:\nocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 chart -O helmchart.tgz\rhelmchart.tgz: 4707 byte(s) written\rBecause it is stored as OCI artifact in an OCI registry, the filesystem format used for OCI artifacts is the blob format.\nWhat happened? The file helmchart.tgz was downloaded.\ntar xvf helmchart.tgz\rx index.json x oci-layout x blobs x blobs/sha256.a9dd654eed17e786b5c5445e8bc48f3a47371c2efe392a53a3fbecd9e942b696 x blobs/sha256.c8017985866ceb44c2426a4ad9a429d6aec1f6818cb6dccbf964623139c1d1d5 x blobs/sha256.ea8e5b44cd1aff1f3d9377d169ad795be20fbfcd58475a62341ed8fb74d4788c\rjq . index.json\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.index.v1+json\u0026#34;, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:c8017985866ceb44c2426a4ad9a429d6aec1f6818cb6dccbf964623139c1d1d5\u0026#34;, \u0026#34;size\u0026#34;: 410, \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.ref.name\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;software.ocm/tags\u0026#34;: \u0026#34;0.1.0\u0026#34; } } ], \u0026#34;annotations\u0026#34;: { \u0026#34;software.ocm/main\u0026#34;: \u0026#34;sha256:c8017985866ceb44c2426a4ad9a429d6aec1f6818cb6dccbf964623139c1d1d5\u0026#34; } }\rDownload with Download Handlers To use a format more suitable for the content technology, enable the usage of download handlers.\nIf a download handler is available for the artifact type and the blob media type used to store the blob in the OCM repository, it will convert the blob format into a more suitable format:\nocm download resource -d ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 chart -O helmchart.tgz\rhelmchart.tgz: 3763 byte(s) written\rWhat happened? The downloaded archive is now a regular Helm Chart archive:\ntar tvf helmchart.tgz\r-rw-r--r-- 0 0 0 136 Jul 19 16:32 echoserver/Chart.yaml -rw-r--r-- 0 0 0 1842 Jul 19 16:32 echoserver/values.yaml -rw-r--r-- 0 0 0 1755 Jul 19 16:32 echoserver/templates/NOTES.txt -rw-r--r-- 0 0 0 1802 Jul 19 16:32 echoserver/templates/_helpers.tpl -rw-r--r-- 0 0 0 1848 Jul 19 16:32 echoserver/templates/deployment.yaml -rw-r--r-- 0 0 0 922 Jul 19 16:32 echoserver/templates/hpa.yaml -rw-r--r-- 0 0 0 2083 Jul 19 16:32 echoserver/templates/ingress.yaml -rw-r--r-- 0 0 0 367 Jul 19 16:32 echoserver/templates/service.yaml -rw-r--r-- 0 0 0 324 Jul 19 16:32 echoserver/templates/serviceaccount.yaml -rw-r--r-- 0 0 0 385 Jul 19 16:32 echoserver/templates/tests/test-connection.yaml -rw-r--r-- 0 0 0 349 Jul 19 16:32 echoserver/.helmignore\rDownload an Image For example, for OCI images, the OCI format is more suitable:\nocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 image -O image.tgz\rimage.tgz: 46181313 byte(s) written\rWhat happened? The file image.tgz was downloaded.\ntar xvf image.tgz\rx index.json x oci-layout x blobs x blobs/sha256.06679f57dba70a6875e4ae5843ba2483ecab6ec48182ca8720ddc5b1863bad52 x blobs/sha256.28c6282d04f63710146ace6c7be14a40c7ee6a71a2f91316928469e4aafe0d92 x blobs/sha256.2d3e25b9e93ad26878862abee5ed02683206f6f6d57e311cdd1dedf3662b61c8 x blobs/sha256.365ec60129c5426b4cf160257c06f6ad062c709e0576c8b3d9a5dcc488f5252d x blobs/sha256.4b12f3ef8e65aaf1fd77201670deb98728a8925236d8f1f0473afa5abe9de119 x blobs/sha256.76d46396145f805d716dcd1607832e6a1257aa17c0c2646a2a4916e47059dd54 x blobs/sha256.7fd34bf149707ca78b3bb90e4ba68fe9a013465e5d03179fb8d3a3b1cac8be27 x blobs/sha256.b0e3c31807a2330c86f07d45a6d80923d947a8a66745a2fd68eb3994be879db6 x blobs/sha256.bc391bffe5907b0eaa04e96fd638784f77d39f1feb7fbe438a1dae0af2675205 x blobs/sha256.cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229 x blobs/sha256.d5157969118932d522396fe278eb722551751c7aa7473e6d3f03e821a74ee8ec x blobs/sha256.e0962580d8254d0b1ef35006d7e2319eb4870e63dc1f9573d2406c7c47d442d2\rjq . index.json\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.index.v1+json\u0026#34;, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u0026#34;, \u0026#34;size\u0026#34;: 2400, \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.ref.name\u0026#34;: \u0026#34;1.10\u0026#34;, \u0026#34;software.ocm/tags\u0026#34;: \u0026#34;1.10\u0026#34; } } ], \u0026#34;annotations\u0026#34;: { \u0026#34;software.ocm/main\u0026#34;: \u0026#34;sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u0026#34; } }\rDownload an Executable The Open Component Model allows to publish platform-specific executables. In this case, the platform specification is used by convention as extra identity for the artifacts that are contained in the component version.\nExample:\nocm get componentversion ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.1.0-dev -o yaml\r... resources: - name: ocmcli extraIdentity: architecture: amd64 os: linux relation: local type: executable version: 0.1.0-dev access: localReference: sha256:1a8827761f0aaa897d1d4330c845121c157e905d1ff300ba5488f8c423bc7cd9 mediaType: application/octet-stream type: localBlob - name: ocmcli extraIdentity: architecture: arm64 os: darwin relation: local type: executable version: 0.1.0-dev access: localReference: sha256:9976b18dc16ae2b2b3fc56686f18f4896d44859f1ea6221f70e83517f697e289 mediaType: application/octet-stream type: localBlob ...\rNote that the resources shown above have the same name and type executable but a different extra-identity. If a component version complies to this convention, executables can directly be downloaded for the specified platform with the use of the -x option. If only one executable is contained in the component version, the resource name can be omitted. Example:\nocm download resource -x --latest ghcr.io/open-component-model/ocm//ocm.software/ocmcli\rocm: 83369938 byte(s) written\rWhat happened? file ocm\rWith the option --latest, the latest matching component version is used for download. With the option --constraints, version constraints can be configured. For example: --constraints 0.1.x will select all patch versions of 0.1. Together with --latest, the latest patch version is selected.\nThe option -x enables the executable download handler, which provides the x-bit of the downloaded files. Additionally, it filters all matching resources for executables and the correct platform.\nDownload a Full Component Version Download entire component versions using the ocm download componentversion command:\nocm download componentversions ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -O helloworld\rhelloworld: downloaded\rThe result is a CTF archive. This can then be modified using the ocm add ... commands shown earlier.\nWhat happened? The component version was downloaded.\ntree helloworld\rhelloworld/ ├── blobs │ ├── sha256.87cef1e2233bf5591030ac854e2556fbe6a00a28bb5640e25a9cb69ece519c5a │ ├── sha256.8a2fe6af4ce56249094622c9d618e24b4cfb461a7dfa6a42cce31749189bc499 │ └── sha256.e790920a11de2016de64225280efcf062e14b767955f7508de64fd5192e3fb3a └── component-descriptor.yaml\rDownload OCI Artifacts Download OCI artifacts from an OCI registry, such as OCI images, with the ocm download artifacts command:\nocm download artifact ghcr.io/open-component-model/ocm-controller:v0.24.0 -O ocm-controller\rocm-controller: downloaded\rWhat happened? The OCI image echoserver was downloaded.\ntree echoserver\rocm-controller/ ├── blobs │ ├── sha256.05d57e68048827c243cd477025f96064df9f4d83b8639ed04306f0647c9cfe78 │ ├── sha256.0f8b424aa0b96c1c388a5fd4d90735604459256336853082afb61733438872b5 │ ├── sha256.1069fc2daed1aceff7232f4b8ab21200dd3d8b04f61be9da86977a34a105dfdc │ ├── sha256.286c61c9a31ace5fa0b8832c8e8e30d66bf32138f2f787463235aa0071f714ea │ ├── sha256.2bdf44d7aa71bf3a0da2de0563ad0e3882948d699b4991edf8c0ab44e7f26ae3 │ ├── sha256.35fddc32f468fc8d276fa1b6a72cac27f35a0080233c2ddc6a03fab224024dbc │ ├── sha256.3f4e2c5863480125882d92060440a5250766bce764fee10acdbac18c872e4dc7 │ ├── sha256.452e9eed7ecfd0c2b44ac6fda20cee66ab98aec38ba30aa868e02445be7c8bb0 │ ├── sha256.80a8c047508ae5cd6a591060fc43422cb8e3aea1bd908d913e8f0146e2297fea │ ├── sha256.9375d0c4fac611287075434624a464af5b6bb026947698a06577ad348f607d56 │ ├── sha256.b40161cd83fc5d470d6abe50e87aa288481b6b89137012881d74187cfbf9f502 │ ├── sha256.c8022d07192eddbb2a548ba83be5e412f7ba863bbba158d133c9653bb8a47768 │ ├── sha256.d557676654e572af3e3173c90e7874644207fda32cd87e9d3d66b5d7b98a7b21 │ └── sha256.d858cbc252ade14879807ff8dbc3043a26bbdb92087da98cda831ee040b172b3 ├── index.json └── oci-layout\r","date":"0001-01-01","id":9,"permalink":"/dev/docs/getting-started/display-and-examine-component-versions/","summary":"\u003ch2 id=\"list-component-versions\"\u003eList Component Versions\u003c/h2\u003e\n\u003cp\u003eTo show a component stored in an OCM repository or CTF archive (which itself is an OCM repository), the \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_get_componentversions.md\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eocm get componentversion\u003c/code\u003e\u003c/a\u003e command can be used:\u003c/p\u003e","tags":[],"title":"Display and Examine Component Versions"},{"content":"Component versions can be signed to ensure integrity along a transport chain.\nSigning requires a key pair, a signature, and, optionally, an issuer, as well as an algorithm and a name for the signature.\nA component version can have multiple signatures with different names. A normalization of the component version is used for signing. See Signing Process and Normalization for more details. Currently, only signing according to the RSA PKCS #1 v1.5 signature algorithm is supported.\nTo follow the examples, one must follow the instructions from the section Create a Component Version.\nCreate a key pair using the OCM CLI:\nocm create rsakeypair acme.priv\rcreated rsa key pair acme.priv[acme.pub]\rThis creates two files. One named acme.priv for the private key and for convenience one named acme.pub for the public key.\nUse the sign componentversion command to sign a component version:\nocm sign componentversion --signature acme-sig --private-key=acme.priv ${OCM_REPO}//${COMPONENT}:${VERSION}\rapplying to version \u0026#34;github.com/acme/helloworld:1.0.0\u0026#34;[github.com/acme/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully signed github.com/acme/helloworld:1.0.0 (digest SHA-256:...)\rYou can also sign a common transport archive before uploading to a component repository:\nocm sign componentversion --signature acme-sig --private-key=acme.priv ${CTF_ARCHIVE}\rapplying to version \u0026#34;github.com/acme.org/helloworld:1.0.0\u0026#34;[github.com/acme.org/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully signed github.com/acme.org/helloworld:1.0.0 (digest SHA-256:...)\rWhat happened? Digests will be created for all described artifacts and referenced component versions. Then for the top-level component versions, the component-version digests are signed. The signature and digests are stored in the component descriptor(s):\njq . ${CTF_ARCHIVE}/artifact-index.json\r{ \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;artifacts\u0026#34;: [ { \u0026#34;repository\u0026#34;: \u0026#34;component-descriptors/github.com/acme.org/helloworld\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:02b12782d66fc6504f0003bb11a8e2610ac8f3d616bc1a4545df17a6e9aca5c6\u0026#34; } ] }\rBeside the digests of the component descriptor layer, nothing has changed:\njq . ${CTF_ARCHIVE}/blobs/sha256.02b12782d66fc6504f0003bb11a8e2610ac8f3d616bc1a4545df17a6e9aca5c6\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:38ba9898cb8d2c5ad34274549632836b391f5acc96268f0276d6857e87b97141\u0026#34;, \u0026#34;size\u0026#34;: 201 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:c9705f0045f91c2cba49ce922dd65da27e66796e3a1fdc7a6fc01058357f2cd4\u0026#34;, \u0026#34;size\u0026#34;: 3584 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:125cf912d0f67b2b49e4170e684638a05a12f2fcfbdf3571e38a016273620b54\u0026#34;, \u0026#34;size\u0026#34;: 16119 } ] }\rtar xvf ${CTF_ARCHIVE}/blobs/sha256.c9705f0045f91c2cba49ce922dd65da27e66796e3a1fdc7a6fc01058357f2cd4 -O - component-descriptor.yaml\rmeta: schemaVersion: v2 component: name: github.com/acme.org/helloworld version: 1.0.0 provider: acme.org componentReferences: [] repositoryContexts: [] resources: - access: localReference: sha256:125cf912d0f67b2b49e4170e684638a05a12f2fcfbdf3571e38a016273620b54 mediaType: application/vnd.oci.image.manifest.v1+tar+gzip referenceName: github.com/acme.org/helloworld/podinfo:6.7.0 type: localBlob digest: ... name: mychart relation: local type: helmChart version: 1.0.0 - access: imageReference: gcr.io/google_containers/echoserver:1.10 type: ociArtifact digest: ... name: image relation: external type: ociArtifact version: 1.0.0 sources: [] signatures: - digest: ... name: acme-sig signature: algorithm: RSASSA-PKCS1-V1_5 mediaType: application/vnd.ocm.signature.rsa value: ...\rSigning with Certificates The public key from the last example cannot be validated. This can be changed by using a certificate instead of a pure public key. The certificate is signed by a CA. This ensures the authenticity of the described public key. Additionally, the common name of the certificate is validated against the issuer attribute of the signature stored in the component descriptor.\nThe following example creates a CA and signing certificates that are used to sign a component version.\nCreate the root CA:\nocm create rsakeypair --ca CN=certificate-authority root.priv\rcreated rsa key pair root.priv[root.cert]\rCreate the CA that is used to create signing certificates:\nocm create rsakeypair --ca CN=acme.org --ca-key root.priv --ca-cert root.cert ca.priv\rcreated rsa key pair ca.priv[ca.cert]\rCreate signing certificates from the CA:\nocm create rsakeypair CN=acme.org C=DE --ca-key ca.priv --ca-cert ca.cert --root-certs root.cert key.priv\rcreated rsa key pair key.priv[key.cert]\rYou can use additional attributes of the certificate like O, OU or C. See usage for details. The certificate can be requested by any official certificate authority instead. It requires the usage types x509.KeyUsageDigitalSignature and x509.ExtKeyUsageCodeSigning.\nFor signing the component version you need to provide the issuer, then run:\nocm sign componentversion ${CTF_ARCHIVE} --private-key key.priv --public-key key.cert --ca-cert root.cert --signature acme.org --issuer CN=acme.org\rapplying to version \u0026#34;github.com/acme.org/helloworld:1.0.0\u0026#34;[github.com/acme.org/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully signed github.com/acme.org/helloworld:1.0.0 (digest SHA-256:...)\rNow the issuer will be stored along the signature and will be checked when verifying with the certificate instead of the public key.\nSignature Verification You can verify a signed component version. Therefore, a public key or a certificate provided by the signer is required. If a certificate is provided, it is validated according to its certificate chain. If an official CA is used instead, you need the certificate of the used root CA.\nIf you followed the previous examples, you can verify the signature of a component version as follows:\nocm verify componentversions --signature acme-sig --public-key=acme.pub ${OCM_REPO}//${COMPONENT}:${VERSION}\rapplying to version \u0026#34;github.com/acme/helloworld:1.0.0\u0026#34;[github.com/acme/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully verified github.com/acme/helloworld:1.0.0 (digest SHA-256:...)\rocm verify component ${CTF_ARCHIVE} --ca-cert root.cert --issuer CN=acme.org\rapplying to version \u0026#34;github.com/acme.org/helloworld:1.0.0\u0026#34;[github.com/acme.org/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] no public key found for signature \u0026#34;acme.org\u0026#34; -\u0026gt; extract key from signature successfully verified github.com/acme.org/helloworld:1.0.0 (digest SHA-256:...)\r","date":"0001-01-01","id":10,"permalink":"/dev/docs/getting-started/sign-component-versions/","summary":"\u003cp\u003eComponent versions can be signed to ensure integrity along a transport chain.\u003c/p\u003e\n\u003cp\u003eSigning requires a key pair, a signature, and, optionally, an issuer, as well as an algorithm and a\nname for the signature.\u003c/p\u003e","tags":[],"title":"Sign Component Versions"},{"content":"The section Add Component Version to CTF archive explained how to store component versions in a CTF archive.\nDuring the transfer, it is possible to include component references as local blobs. It is also possible to include references in a recursive way.\nHere is an example of a recursive transfer from one OCI registry to another, which includes resources and references:\nocm transfer componentversion --recursive --copy-resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 another-registry/\rtransferring version \u0026#34;ocm.software/toi/demo/helmdemo:0.12.0\u0026#34;... transferring version \u0026#34;ocm.software/toi/installers/helminstaller:0.12.0\u0026#34;... ...resource 0 toiimage[ociImage](ocm.software/toi/installers/helminstaller/helminstaller:0.12.0)... ...resource 1 toiexecutor[toiExecutor]... ...adding component version... ...resource 0 package[toiPackage]... ...resource 1 chart[helmChart](ocm.software/toi/demo/helmdemo/echoserver:0.1.0)... ...resource 2 image[ociImage](google-containers/echoserver:1.10)... ...resource 3 config-example[yaml]... ...resource 4 creds-example[yaml]... ...adding component version... 2 versions transferred\rThe OCM CLI\u0026rsquo;s transfer command can be used to transfer component versions, CTF archives, and artifacts. See ocm transfer -h for more information.\nMore examples on the transport archive and the common transfer format (CTF) can be found in the ocm-spec.\nAir gapped environment Working with air-gapped environments requires careful preparation and a systematic approach to ensure all component dependencies are available offline. This section demonstrates how to prepare, transport, and deploy OCM components in secure, disconnected environments.\nInspect Component Structure Begin by examining the component descriptor and its resolved references to understand the complete dependency tree:\nocm get resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -r -otree COMPONENT NAME VERSION IDENTITY TYPE RELATION └─ ocm.software/toi/demo/helmdemo 0.12.0 ├─ chart 0.12.0 helmChart local ├─ config-example 0.12.0 yaml local ├─ creds-example 0.12.0 yaml local ├─ image 1.0 ociImage external ├─ package 0.12.0 toiPackage local └─ ocm.software/toi/installers/helminstaller installer 0.12.0 ├─ toiexecutor 0.12.0 toiExecutor local └─ toiimage 0.12.0 ociImage local\rCreate Offline Package Download the complete component descriptor with all referenced resources as local blobs. This creates a self-contained package that includes all dependencies:\nocm transfer component ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -r --copy-resources ./ctf-copy-resources transferring version \u0026#34;ocm.software/toi/demo/helmdemo:0.12.0\u0026#34;... transferring version \u0026#34;ocm.software/toi/installers/helminstaller:0.12.0\u0026#34;... ...resource 0 toiimage[ociImage](ocm.software/toi/installers/helminstaller/helminstaller:0.12.0)... ...resource 1 toiexecutor[toiExecutor]... ...adding component version... ...resource 0 package[toiPackage]... ...resource 1 chart[helmChart](ocm.software/toi/demo/helmdemo/echoserver:0.1.0)... ...resource 2 image[ociImage](google-containers/echoserver:1.10)... ...resource 3 config-example[yaml]... ...resource 4 creds-example[yaml]... ...adding component version... 2 versions transferred\rVerify Package Integrity Confirm that all resources have been successfully packaged and are available as local blobs:\ndu -shA ctf-copy-resources 106M ctf-copy-resources\rocm get resources ctf-copy-resources -o treewide COMPONENT NAME VERSION IDENTITY TYPE RELATION ACCESS ├─ ocm.software/toi/demo/helmdemo 0.12.0 │ ├─ chart 0.12.0 helmChart local localBlob │ ├─ config-example 0.12.0 yaml local localBlob │ ├─ creds-example 0.12.0 yaml local localBlob │ ├─ image 1.0 ociImage external localBlob │ └─ package 0.12.0 toiPackage local localBlob └─ ocm.software/toi/installers/helminstaller 0.12.0 ├─ toiexecutor 0.12.0 toiExecutor local localBlob └─ toiimage 0.12.0 ociImage local localBlob\rTransport to Air-Gapped Environment Copy the packaged OCM artifacts to your preferred portable storage medium for secure transport:\nsudo cp -r ./ctf-copy-resources /media/....\rPhysical Transport Phase ✈️\nTransport your portable storage device containing the OCM artefact to the air-gapped environment following your organization\u0026rsquo;s security protocols.\n___ ____/ \\____ o \u0026#34;Here I come!\u0026#34; | ✈️ | /|\\_┌▓┐ |___________| / \\ | | ___| |___\rDeploy in Air-Gapped Environment Transfer the OCM artifacts from your portable storage device to the air-gapped OCI registry:\nocm transfer ctf ./media/.../ctf-copy-resources $AIR_GAPPED_OCI_REGISTRY/... Application Deployment With all components now available in your air-gapped registry, you can proceed with deploying your applications via GitOps. The self-contained nature of the OCM package ensures reliable deployment without external dependencies.\n🎉 SUCCESSFUL DEPLOYMENT IN AIR-GAPPED K8S CLUSTER 🎉 ╔══════════════════════════════════════╗ ║ AIR-GAPPED ENVIRONMENT ║ ║ 🔒 SECURE � ║ ╚══════════════════════════════════════╝ │ ┌─────────────────────────────────────┐ │ KUBERNETES CLUSTER │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ │ │ │ POD │ │ POD │ │ POD │ │ │ │ ⚙️ │ │ ⚙️ │ │ ⚙️ │ │ │ └─────┘ └─────┘ └─────┘ │ │ │ │ │ │ │ ┌──┴────────┴────────┴──┐ │ │ │ LEADER NODE │ │ │ │ 🎛️ │ │ │ └───────────────────────┘ │ │ │ │ ┌─────┐ ┌─────┐ ┌─────┐ │ │ │NODE1│ │NODE2│ │NODE3│ │ │ │ 🖥️ │ │ 🖥️ │ │ 🖥️ │ │ │ └─────┘ └─────┘ └─────┘ │ └─────────────────────────────────────┘ \\o/ \u0026#34;DEPLOYMENT SUCCESSFUL!\u0026#34; | \u0026#34;All pods are running!\u0026#34; / \\ \u0026#34;Zero downtime achieved!\u0026#34;\r","date":"0001-01-01","id":11,"permalink":"/dev/docs/getting-started/transport-ocm-component-versions/","summary":"\u003cp\u003eThe section \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/getting-started/create-component-version/#add-component-version-to-ctf-archive/\"\u003eAdd Component Version to CTF archive\u003c/a\u003e explained how to store component versions in a CTF archive.\u003c/p\u003e\n\u003cp\u003eDuring the transfer, it is possible to include component references as local blobs. It is also possible to include references in a recursive way.\u003c/p\u003e","tags":[],"title":"Transport OCM Component Versions"},{"content":"The following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\nThe component is publicly available in the GitHub container registry and can be inspected using the following command:\nocm componentversion get --repo ghcr.io/phoban01/ocm github.com/weaveworks/weave-gitops -oyaml\rmeta: # component schema version schemaVersion: v2 component: # name of the component. Must start with URL-prefix that should be controlled # by the owner of the component to avoid collisions # regex: ^[a-z][-a-z0-9]*([.][a-z][-a-z0-9]*)*[.][a-z]{2,}(/[a-z][-a-z0-9_]*([.][a-z][-a-z0-9_]*)*)+$ name: github.com/weaveworks/weave-gitops # version of the component. Must adhere to “relaxed SemVer” # major, minor (+ optional patch level) - optional v-prefix # regex: ^[v]?(0|[1-9]\\\\d*)(?:\\\\.(0|[1-9]\\\\d*))?(?:\\\\.(0|[1-9]\\\\d*))?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$ version: v1.0.0 # component provider provider: weaveworks # list of labels that can contain arbitrary metadata in form of K/V pairs # labels can be added on component root, resource, source and reference level labels: - name: link-to-documentation value: https://github.com/weaveworks/weave-gitops # list of repository context the component version \u0026#34;lived\u0026#34; in, # with the current one at the top repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: phoban01/ocm type: OCIRegistry # list of resources that describe the payload of the component resources: # resource name - name: image # resource location (external repository or internal to this repository) relation: external # resource type type: ociImage # resource version. Must also adhere to “relaxed SemVer” (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the resource access: # type of access information type: ociArtifact imageReference: ghcr.io/weaveworks/wego-app:v0.14.1 # signing metadata for the resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: ociArtifactDigest/v1 value: efa2b9980ca2de65dc5a0c8cc05638b1a4b4ce8f6972dc08d0e805e5563ba5bb # list of sources that describe the input for creating the resources sources: # source name - name: weave-gitops # source type type: git # source version. Must also adhere to “relaxed SemVer” (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the source access: commit: 727513969553bfcc603e1c0ae1a75d79e4132b58 ref: refs/tags/v0.14.1 repoUrl: github.com/weaveworks/weave-gitops type: gitHub # list of references to other components componentReferences: # reference name - name: prometheus # reference version version: v1.0.0 # referenced component name componentName: cncf.io/prometheus # signing metadata for the referenced resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 04eb20b6fd942860325caf7f4415d1acf287a1aabd9e4827719328ba25d6f801 # list of signatures used for signing and verification signatures: # name of the signature - name: ww-dev # digest of the signature including the algorithm used digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 4faff7822616305ecd09284d7c3e74a64f2269dcc524a9cdf0db4b592b8cee6a # signature including the algorithm used signature: algorithm: RSASSA-PSS mediaType: application/vnd.ocm.signature.rsa value: 26468587671bdbd2166cf5f69829f090c10768511b15e804294fcb26e552654316c8f4851ed396f279ec99335e5f4b11cb043feb97f1f9a42115f4fda2d31ae8b481b7303b9a913d3a4b92d446fbee9ed487c93b09e513f3f68355040ec08454675e1f407422062abbd2681f70dd5488ad29020b30cfa7e001455c550458da96166bc3243c8426977d73352aface5323fb2b5a374e9c31b272a59c160b85631231c9fc2f23c032401b80fef937029a39111cee34470c61ae86cd4942553466411a5a116159fdcc10e50fe9360c5184028e72d1fe9c7315f26e15d7b4849f62d197501b8cc6b6f1b1391ecc2fc2fc0c1290d2554594505b25fa8f9bfb28c8df24\r","date":"0001-01-01","id":12,"permalink":"/dev/docs/getting-started/component-descriptor-example/","summary":"\u003cp\u003eThe following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\u003c/p\u003e\n\u003cp\u003eThe component is publicly available in the GitHub container registry and can be inspected using the following command:\u003c/p\u003e","tags":[],"title":"Example of a Component Descriptor"},{"content":"","date":"0001-01-01","id":13,"permalink":"/dev/docs/tutorials/","summary":"","tags":[],"title":"Tutorials"},{"content":"This chapter contains guidelines for common scenarios how to work with the Open Component Model, focusing on using CI/CD, build and publishing processes.\nUse Public Schema for Validation and Auto-Completion of Component Descriptors Separate Build and Publish Processes Using Makefiles Prerequisites Example Makefile Templating the Resources Pipeline Integration Static and Dynamic Variable Substitution Example Substitution File Debugging: Explain the Blobs Directory Self-Contained Transport Archives CICD Integration Use Public Schema for Validation and Auto-Completion of Component Descriptors The Open Component Model (OCM) provides a public schema to validate and offer auto-completion of component constructor files used to create component descriptors. This schema is available at https://ocm.software/schemas/configuration-schema.yaml.\nTo use this schema in your IDE, you can add the following line to your component constructor file:\n# yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml\rThis line tells the YAML language server to use the OCM schema for validation and auto-completion.\nSeparate Build and Publish Processes Traditional automated builds often have unrestricted internet access, which can lead to several challenges in enterprise environments:\nLimited control over downloaded artifacts Potential unavailability of required resources Security risks associated with write permissions to external repositories Best practice: Implement a two-step process: a) Build: Create artifacts in a controlled environment, using local mirrors when possible. b) Publish: Use a separate, secured process to distribute build results.\nOCM supports this approach through filesystem-based OCM repositories, allowing you to generate Common Transport Format (CTF) archives for component versions. These archives can then be securely processed and distributed.\nUsing Makefiles Developing applications and services using the Open Component Model usually is an iterative process of building artifacts, generating OCM component versions and finally publishing them. To simplify this process it should be automated and integrated into your build process. One option is to use a Makefile.\nThe following example can be used as a starting point and can be modified according to your needs. In this example we will use the same example as in the sections before:\nCreating a multi-arch image from Go sources from a Git repository using the Docker CLI Packaging the Docker image and a Helm chart into a CTF archive Signing and publishing the build result Prerequisites The OCM CLI must be installed and be available in your PATH The Makefile is located in the top-level folder of a Git project Operating system is Unix/Linux A sub-directory local can be used for local settings e.g. environment variables, RSA keys, \u0026hellip; A sub-directory gen will be used for generated artifacts from the make build command It is recommended to add local/ and gen/ to the .gitignore file We use the following file system layout for the example:\n$ tree . . ├── Dockerfile ├── LICENSE ├── Makefile ├── README.md ├── go.mod ├── helmchart │ ├── Chart.yaml │ ├── templates │ │ ├── NOTES.txt │ │ ├── _helpers.tpl │ │ ├── deployment.yaml │ │ ├── hpa.yaml │ │ ├── ingress.yaml │ │ ├── service.yaml │ │ ├── serviceaccount.yaml │ │ └── tests │ │ └── test-connection.yaml │ └── values.yaml ├── local │ └── env.sh ├── main.go ├── resources.yaml └── VERSION\rExample Makefile NAME ?= simpleserver PROVIDER ?= acme.org GITHUBORG ?= acme IMAGE = ghcr.io/$(GITHUBORG)/demo/$(NAME) COMPONENT = $(PROVIDER)/demo/$(NAME) OCMREPO ?= ghcr.io/$(GITHUBORG)/ocm MULTI ?= true PLATFORMS ?= linux/amd64 linux/arm64 REPO_ROOT = . VERSION = $(shell git describe --tags --exact-match 2\u0026gt;/dev/null|| echo \u0026#34;$$(cat $(REPO_ROOT)/VERSION)\u0026#34;) COMMIT = $(shell git rev-parse HEAD) EFFECTIVE_VERSION = $(VERSION)-$(COMMIT) GIT_TREE_STATE := $(shell [ -z \u0026#34;$(git status --porcelain 2\u0026gt;/dev/null)\u0026#34; ] \u0026amp;\u0026amp; echo clean || echo dirty) GEN = ./gen OCM = ocm CHART_SRCS=$(shell find helmchart -type f) GO_SRCS=$(shell find . -name \\*.go -type f) ifeq ($(MULTI),true) FLAGSUF = .multi endif .PHONY: build build: $(GEN)/build .PHONY: version version: @echo $(VERSION) .PHONY: ca ca: $(GEN)/ca $(GEN)/ca: $(GEN)/.exists $(GEN)/image.$(NAME)$(FLAGSUF) resources.yaml $(CHART_SRCS) $(OCM) create ca -f $(COMPONENT) \u0026#34;$(VERSION)\u0026#34; --provider $(PROVIDER) --file $(GEN)/ca $(OCM) add resources --templater spiff $(GEN)/ca COMMIT=\u0026#34;$(COMMIT)\u0026#34; VERSION=\u0026#34;$(VERSION)\u0026#34; \\ IMAGE=\u0026#34;$(IMAGE):$(VERSION)\u0026#34; PLATFORMS=\u0026#34;$(PLATFORMS)\u0026#34; MULTI=$(MULTI) resources.yaml @touch $(GEN)/ca $(GEN)/build: $(GO_SRCS) go build . @touch $(GEN)/build .PHONY: image image: $(GEN)/image.$(NAME) $(GEN)/image.$(NAME): $(GEN)/.exists Dockerfile $(OCMSRCS) docker build -t $(IMAGE):$(VERSION) --file Dockerfile $(COMPONENT_ROOT) .; @touch $(GEN)/image.$(NAME) .PHONY: multi multi: $(GEN)/image.$(NAME).multi $(GEN)/image.$(NAME).multi: $(GEN)/.exists Dockerfile $(GO_SRCS) echo \u0026#34;Building Multi $(PLATFORMS)\u0026#34; for i in $(PLATFORMS); do \\ tag=$$(echo $$i | sed -e s:/:-:g); \\ echo \u0026#34;Building platform $$i with tag: $$tag\u0026#34;; \\ docker buildx build --load -t $(IMAGE):$(VERSION)-$$tag --platform $$i .; \\ done @touch $(GEN)/image.$(NAME).multi .PHONY: ctf ctf: $(GEN)/ctf $(GEN)/ctf: $(GEN)/ca @rm -rf $(GEN)/ctf $(OCM) transfer ca $(GEN)/ca $(GEN)/ctf touch $(GEN)/ctf .PHONY: push push: $(GEN)/ctf $(GEN)/push.$(NAME) $(GEN)/push.$(NAME): $(GEN)/ctf $(OCM) transfer ctf -f $(GEN)/ctf $(OCMREPO) @touch $(GEN)/push.$(NAME) .PHONY: transport transport: ifneq ($(TARGETREPO),) $(OCM) transfer component -Vc $(OCMREPO)//$(COMPONENT):$(VERSION) $(TARGETREPO) else @echo \u0026#34;Cannot transport no TARGETREPO defined as destination\u0026#34; \u0026amp;\u0026amp; exit 1 endif $(GEN)/.exists: @mkdir -p $(GEN) @touch $@ .PHONY: info info: @echo \u0026#34;VERSION: $(VERSION)\u0026#34; @echo \u0026#34;COMMIT: $(COMMIT)\u0026#34; @echo \u0026#34;TREESTATE: $(GIT_TREE_STATE)\u0026#34; .PHONY: describe describe: $(GEN)/ctf ocm get resources --lookup $(OCMREPO) -r -o treewide $(GEN)/ctf .PHONY: descriptor descriptor: $(GEN)/ctf ocm get component -S v3alpha1 -o yaml $(GEN)/ctf .PHONY: clean clean: rm -rf $(GEN) The Makefile supports the following targets:\nbuild (default) simple Go build version show current VERSION of Github repository image build a local Docker image multi build multi-arch images with Docker\u0026rsquo;s buildx command ca execute build and create a component archive ctf create a common transport format archive push push the common transport archive to an OCI registry info show variables used in Makefile (version, commit, etc.) describe display the component version in a tree-form descriptor show the component descriptor of the component version transport transport the component from the upload repository into another OCM repository clean delete all generated files (but does not delete Docker images) The variables assigned with ?= at the beginning can be set from outside and override the default declared in the Makefile. Use either an environment variable or an argument when calling make.\nExample:\nPROVIDER=foo make ca\rTemplating the Resources The Makefile uses a dynamic list of generated platforms for the images. You can just set the PLATFORMS variable:\nMULTI ?= true PLATFORMS ?= linux/amd64 linux/arm64 If MULTI is set to true, the variable PLATFORMS will be evaluated to decide which image variants will be built. This has to be reflected in the resources.yaml. It has to use the input type dockermulti and list all the variants which should be packaged into a multi-arch image. This list depends on the content of the Make variable.\nThe OCM CLI supports this by enabling templating mechanisms for the content by selecting a templater using the option --templater .... The example uses the Spiff templater.\n$(GEN)/ca: $(GEN)/.exists $(GEN)/image.$(NAME)$(FLAGSUF) resources.yaml $(CHART_SRCS) $(OCM) create ca -f $(COMPONENT) \u0026#34;$(VERSION)\u0026#34; --provider $(PROVIDER) --file $(GEN)/ca $(OCM) add resources --templater spiff $(GEN)/ca COMMIT=\u0026#34;$(COMMIT)\u0026#34; VERSION=\u0026#34;$(VERSION)\u0026#34; \\ IMAGE=\u0026#34;$(IMAGE):$(VERSION)\u0026#34; PLATFORMS=\u0026#34;$(PLATFORMS)\u0026#34; MULTI=$(MULTI) resources.yaml @touch $(GEN)/ca The variables given to the add resources command are passed to the templater. The template looks like:\nname: image type: ociImage version: (( values.VERSION )) input: type: (( bool(values.MULTI) ? \u0026#34;dockermulti\u0026#34; :\u0026#34;docker\u0026#34; )) repository: (( index(values.IMAGE, \u0026#34;:\u0026#34;) \u0026gt;= 0 ? substr(values.IMAGE,0,index(values.IMAGE,\u0026#34;:\u0026#34;)) :values.IMAGE )) variants: (( bool(values.MULTI) ? map[split(\u0026#34; \u0026#34;, values.PLATFORMS)|v|-\u0026gt; values.IMAGE \u0026#34;-\u0026#34; replace(v,\u0026#34;/\u0026#34;,\u0026#34;-\u0026#34;)] :~~ )) path: (( bool(values.MULTI) ? ~~ :values.IMAGE ))\rBy using a variable values.MULTI, the command distinguishes between a single Docker image and a multi-arch image. With map[], the platform list from the Makefile is mapped to a list of tags created by the docker buildx command used in the Makefile. The value ~~ is used to undefine the yaml fields not required for the selected case (the template can be used for multi- and single-arch builds).\n$(GEN)/image.$(NAME).multi: $(GEN)/.exists Dockerfile $(GO_SRCS) echo \u0026#34;Building Multi $(PLATFORMS)\u0026#34; for i in $(PLATFORMS); do \\ tag=$$(echo $$i | sed -e s:/:-:g); \\ echo \u0026#34;Building platform $$i with tag: $$tag\u0026#34;; \\ docker buildx build --load -t $(IMAGE):$(VERSION)-$$tag --platform $$i .; \\ done @touch $(GEN)/image.$(NAME).multi Pipeline Integration Pipeline infrastructures are heterogeneous, so there is no universal answer how to integrate a build pipeline with OCM. Usually, the simplest way is using the OCM command line interface. Following you will find an example using GitHub actions.\nThere are two repositories dealing with GitHub actions: The first one provides various actions that can be called from a workflow. The second one provides the required installation of the OCM CLI into the container.\nAn typical workflow for a build step will create a component version and a transport archive:\njobs: create-ocm: runs-on: ubuntu-latest steps: ... - name: setup OCM uses: open-component-model/ocm-setup-action@main ... - name: create OCM component version uses: open-component-model/ocm-action@main with: action: create_component component: acme.org/demo/simpleserver provider: ${{ env.PROVIDER }} version: github.com/jensh007 ...\rThis creates a component version for the current build. Additionally, a CTF archive can be created or the component version along with the built container images can be uploaded to an OCI registry, etc.\nMore documentation is available here. A full example can be found in the sample Github repository.\nStatic and Dynamic Variable Substitution Looking at the settings file shows that some variables like the version or the commit change with every build or release. In many cases, these variables will be auto-generated during the build.\nOther variables like the version of 3rd-party components will just change from time to time and are often set manually by an engineer or release manager. It is useful to separate between static and dynamic variables. Static files can be checked-in into the source control system and are maintained manually. Dynamic variables can be generated during the build.\nExample Substitution File The following example shows how to separate static and dynamic variables.\nStatic settings, manually maintained:\nNAME: microblog COMPONENT_NAME_PREFIX: github.com/acme.org/microblog PROVIDER: ocm.software ELASTIC_VERSION: 8.5.1 MARIADB_VERSION: 10.6.11 MARIADB_CHART_VERSION: 11.4.2 NGINX_VERSION: 1.5.1 NGINX_CHART_VERSION: 4.4.2\rauto-generated from a build script:\nVERSION: 0.23.1 COMMIT: 5f03021059c7dbe760ac820a014a8a84166ef8b4\rocm add componentversions --create --file ../gen/ctf --settings ../gen/dynamic_settings.yaml --settings static_settings.yaml component-constructor.yaml\rDebugging: Explain the Blobs Directory For analyzing and debugging the content of a CTF archive, there are some supportive commands to analyze what is contained in the archive and what is stored in which blob:\ntree ../gen/ctf ../gen/ctf ├── artifact-index.json └── blobs ├── ... ├── sha256.59ff88331c53a2a94cdd98df58bc6952f056e4b2efc8120095fbc0a870eb0b67 ├── ...\rocm get resources -r -o wide ../gen/ctf ... --- REFERENCEPATH: github.com/acme.org/microblog/nginx-controller:1.5.1 NAME : nginx-controller-chart VERSION : 1.5.1 IDENTITY : TYPE : helmChart RELATION : local ACCESSTYPE : localBlob ACCESSSPEC : {\u0026#34;localReference\u0026#34;:\u0026#34;sha256:59ff88331c53a2a94cdd98df58bc6952f056e4b2efc8120095fbc0a870eb0b67\u0026#34;,\u0026#34;mediaType\u0026#34;:\u0026#34;application/vnd.oci.image.manifest.v1+tar+gzip\u0026#34;,\u0026#34;referenceName\u0026#34;:\u0026#34;github.com/acme.org/microblog/nginx-controller/ingress-nginx:4.4.2\u0026#34;} ...\rSelf-Contained Transport Archives The transport archive created from a component constructor file, using the command ocm add componentversions --create ..., does not automatically resolve image references to external OCI registries and stores them in the archive. If you want to create a self-contained transport archive with all images stored as local artifacts, you need to use the --copy-resources option in the ocm transfer ctf command. This will copy all external images to the blobs directory of the archive.\nocm transfer ctf --copy-resources \u0026lt;ctf-dir\u0026gt; \u0026lt;new-ctf-dir-or-oci-repo-url\u0026gt;\rNote that this archive can become huge, depending on the size of the external images !\nCICD Integration Configure rarely changing variables in a static file and generate dynamic variables during the build from the environment. See the Static and Dynamic Variable Substitution section above.\n","date":"0001-01-01","id":14,"permalink":"/dev/docs/tutorials/best-practices/","summary":"\u003cp\u003eThis chapter contains guidelines for common scenarios how to work with the Open Component Model, focusing on using CI/CD, build and publishing processes.\u003c/p\u003e","tags":[],"title":"Best Practices"},{"content":"Introduction In this tutorial software products are comprised of logical units called components. A component version consists of a set of technical artifacts (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called resources in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named sources in this specification.\nOCM introduces a Component Version for every component version that describes the resources, sources, and other component versions belonging to a particular component version and how to access them.\nUsually, however, real-life applications are composed of multiple components. For example, an application might consist of a frontend, a backend, a database, and a web server. During the software development process new component versions are created and third-party components might be consumed from a public registry and updated from time to time.\nNot all component version combinations of frontend, backend, database, etc. are compatible and form a valid product version. In order to define reasonable version combinations for the software product, we could use another feature of OCM\u0026rsquo;s Component Version, called a Component Reference (or reference in short), which allows the aggregation of component versions.\nFor each sub-component and each version in use, there is a Component Version. For the entire application, we introduce a new component that describes the overall software product referencing all components. This describes the entire application or product.\nA particular version of this application is again described by a Component Version, which contains references to the Component Versions of its sub-components in their version in use. You are not restricted to this approach. It is, e.g., possible to create multi-level hierarchies or you could just maintain a list of component version combinations which build a valid product release.\nIn a nutshell, OCM provides a simple approach to specify what belongs to a product version. Starting with the Component Version for a product version and following the component references, you could collect all artifacts belonging to this product version.\nPrerequisites We assume that you have already read the guides in the Getting Started section, as this guide discusses a more complex scenario.\nConstructing the Component We are going to use podinfo in microservices mode. This describes a setup with multiple microservices forming a larger application.\npodinfo has three services which we are going to model using individual component versions:\nbackend frontend cache (redis) We will use the following example application to demonstrate a multi-component structure using podinfo: Podinfo Component.\nThis repository contains the following items:\nComponent File The following component-constructor file describes four components: three components, each representing a podinfo microservice and one aggregated component that brings together the podinfo components using references. We refer to the aggregated component as the product component. A component-constructor file can contain one or multiple components and references to other components. The file is a YAML file and can be validated using the OCM schema.\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: # -- product component - name: ocm.software/podinfo version: 1.0.2 labels: - name: ocm.software/labels/podinfo/purpose value: - kind: test type: manual provider: name: open-component-model componentReferences: - name: backend componentName: ocm.software/podinfo/backend version: 1.0.0 - name: frontend componentName: ocm.software/podinfo/frontend version: 1.0.0 - name: redis componentName: ocm.software/redis version: 1.0.0 sources: - access: commit: ac0afafcf4aa333546634cba631f0090a0a4cbe3 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- backend component - name: ocm.software/podinfo/backend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: backend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: backend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: backend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- frontend component - name: ocm.software/podinfo/frontend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: frontend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: frontend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: frontend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- redis component - name: ocm.software/redis version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: redis resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: redis/config.yaml compress: true - name: image relation: external type: ociImage version: 6.0.1 access: type: ociArtifact imageReference: redis:6.0.1 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: redis/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0\rWith the components modeled we can start to build a component archive using the ocm cli:\nocm add componentversions --create --file component-archive component-constructor.yaml processing component-constructor.yaml... processing document 1... processing index 1 processing index 2 processing index 3 processing index 4 found 4 components adding component ocm.software/podinfo:1.0.2... adding reference ocm.software/podinfo/backend: \u0026#34;name\u0026#34;=\u0026#34;backend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/podinfo/frontend: \u0026#34;name\u0026#34;=\u0026#34;frontend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/redis: \u0026#34;name\u0026#34;=\u0026#34;redis\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding component ocm.software/podinfo/backend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/podinfo/frontend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/redis:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.0.1\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;...\rThis will create a folder called component-archive. The structure of that should look something like this:\ntree . . ├── artifact-index.json └── blobs ├── sha256.03ac3a7611e118d08fcf70e9b7be263c4a7082066f9763f71d8901d7fa2afc9d ├── sha256.118b6e8282ee1d335b1638a76a20022b6acc319177dbbce3089700da835afb6a ├── sha256.12073781e4fba95f19f046c51c90f0c4e1338d47afe4795bf6fcca163ae46eb8 ├── sha256.1f239399104ec0cc7680956eb60960d212b3368609feb83dac2c95040d24b480 ├── sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e ├── sha256.3dc6209959eb782fa6f5f44892f66e9657276735bfb40407bd00ddca30d0a9d1 ├── sha256.654debd65dbadbcee73e55b675980865ddf22acffcec166c59a5e48a213e4dd5 ├── sha256.699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0 ├── sha256.70a47378c043721e3099801dec02c44b1dd9cdef0ebf79c55784eb4666bdbc29 ├── sha256.773b28fb63f1195ff73e328744639ddc1c574d58c1e723d6e386fcd66b45bd9c ├── sha256.893be914eebd8230ef848ea82b3433c6201152f5d9925e7b5b8d68e0cec7133e ├── sha256.92991cf391167c928f3afe6891001f3dd325b64ce800cf34fad4c038141fc57f ├── sha256.98ca4d46130f5c09a704b3d8ee9af94de3c0ac73d7e990df53e64606c418fea8 ├── sha256.a779270c2fea310835d3125de90e089e423c9730a98f1acdda328470d21fced0 ├── sha256.a7dd532f80e8417ed33cf0c97328582847017895fc5146e499bdf4c94a9d17b5 ├── sha256.cae4365f264251c616210707aa4765bd95f23fd22f98abc68bae9f58d6e4506d ├── sha256.ee79c92bbcce9e7a98f07c6577fd56dd45cf6f7c2d3115216ee249f42119030e └── sha256.f6a82a23220752c232e5f66ce46f0be28b27a5af19474072c77dac6d1feb0c16 2 directories, 19 files\rThese blobs contain the resources we described when modelling our podinfo application. If we cat a random blob we get something like this:\ncat sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e {\u0026#34;componentDescriptorLayer\u0026#34;:{\u0026#34;mediaType\u0026#34;:\u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;,\u0026#34;digest\u0026#34;:\u0026#34;sha256:699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0\u0026#34;,\u0026#34;size\u0026#34;:2560}}%\rNext, we transfer this component to an OCI registry of your choice. Here \u0026lt;your-location\u0026gt; for me was ghcr.io/skarlso/demo-component.\nocm transfer component ./component-archive \u0026lt;your-location\u0026gt; transferring version \u0026#34;ocm.software/podinfo:1.0.2\u0026#34;... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/backend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/frontend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/redis:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... 4 versions transferred\rWith the transfer completed, we now have a product *Component Version* that describes a set of sub-components using *Component References*. It bundles all required artifacts for a successful deployment of the complete product.\nConclusion We saw how to create a complex, multi-service architecture product component and store it in an OCI registry.\n","date":"0001-01-01","id":15,"permalink":"/dev/docs/tutorials/structuring-software-products-with-ocm/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial software products are comprised of logical units called \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/overview/important-terms/#components-in-ocm\"\u003e\u003cem\u003ecomponents\u003c/em\u003e\u003c/a\u003e. A component version consists of a set of technical \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm-spec/blob/main/doc/04-extensions/01-artifact-types/README.md\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003eartifacts\u003c/em\u003e\u003c/a\u003e (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called \u003cem\u003eresources\u003c/em\u003e in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named \u003cem\u003esources\u003c/em\u003e in this specification.\u003c/p\u003e","tags":[],"title":"Structuring Software Products with OCM"},{"content":" Overview Input Types binary dir docker dockermulti file helm ociImage spiff utf-8 Access Types gitHub helm npm ociArtifact s3 Overview The Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\nAn Input type adds content by value, along with the component descriptor and stores it in the same target repository where the component is stored. After pushing the content to the target registry this always resolves to the attribute\nrelation: local\rin a component descriptor.\nAn Access Type just adds content by reference to an external location, e.g., an OCI registry. It is a kind of pointer in a component descriptor. It resolves to the attribute\nrelation: external\rin a component descriptor.\nThe following input types are supported:\nbinary dir docker dockermulti file helm ociImage spiff utf-8 Please use the latest ocm-cli to check available input types:\nocm add resources --help | grep \u0026#39; - Input type\u0026#39; | sort -f\rThe following list of access types is supported:\ngitHub localBlob ociArtifact ociBlob s3 Please use the latest ocm-cli to check available access types:\nocm ocm-accessmethods | grep \u0026#39; - Access type\u0026#39; | sort -f\rNot all access and input types can be combined in useful ways with all artifact types. But the OCM specification does not define any restrictions on possible combinations.\nThe following sections give an overview and typical usage examples for access and input types. It does not describe the full list of possible fields and their meaning. For a complete list of attributes, please see the command reference. The examples below are meant to be used in a component that looks like this:\n- name: github.com/open-component-model/megacomponent version: 0.1.0\rInput Types binary Allows to define resources with binary content being base64 encoded. Should only be used for smaller blobs.\nresources: - name: noticeencoded type : blob input: data: VGhpcyBpcyBzb21lIGJhc2U2NCBlbmNvZGVkIGRhdGEK mediaType: text/plain compress: false type: binary\rdir Defines a resource from content of a directory in the local file system. It is packed with tar and optionally compressed.\nresources: - name: megadir type : fileSystem input: type: dir path: ./logos\rdocker Takes an image from the local docker registry and adds it as a resource. Requires a running docker daemon.\nresources: - name: megaimage type : ociImage input: type: docker repository: images/mega path: megacomp:${VERSION}\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0 9aab9cbca56e 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/mega:1.10.\ndockermulti Takes multiple images from the local docker registry and adds them as single multi-arch image. Requires a running docker daemon. The images have to be built for different architectures/os and need a unique tag identifying them. As docker does not support multi-arch images at the time of writing this is a workaround.\nresources: - name: megaimagemulti type : ociImage input: type: dockermulti repository: images/megamulti variants: - megacomp:${VERSION}-linux-amd64 - megacomp:${VERSION}-linux-arm64\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0-linux-amd64 96659c4f7a35 5 days ago 7.05MB megacomp 0.1.0-linux-arm64 64f209acb814 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/megamulti:1.10.\nfile Imports a file from the local file system and adds it as a resource.\nresources: - name: mega-file type: blob input: type: file path: ./logos/logo-image.png\rhelm Imports a helm chart from the local file system and adds it as a resource.\nresources: - name: mega-chart type: helmChart input: type: helm path: ./megachart repository: charts/mega\rAfter transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mega prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mega. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used.\nIt is also possible to import a helm chart from a helm chart repository:\nresources: - name: mariadb-chart type: helmChart input: type: helm helmRepository: https://charts.bitnami.com/bitnami path: mariadb version: 12.2.7 repository: charts/mariadb\rHere the helm chart version 12.2.7 is copied from the path mariadb in helm chart repository https://charts.bitnami.com/bitnami. After transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mariadb prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mariadb. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used. There are additional optional fields caCert and caCertFile to specify a TLS certificate for the helm chart repository.\nociImage Takes an image that is located in an OCI registry and adds it as a resource.\nresources: - name: mega-image type: ociImage input: type: ociImage path: gcr.io/google_containers/echoserver:1.10 repository: images/echo\rThe target location of the image after transporting to an OCI registry can be set with the repository field. Here the resulting image will be prefixed with the name of the component version, e.g., github.com/open-component-model/megacomponent/images/echo:1.10. This auto-prefix can be disabled by using a leading slash /images/echo.\nspiff Processes a resource using the spiff templater and can provide values for variables.\nresources: - name: mega-package type: toiPackage input: type: spiff mediaType: application/vnd.toi.ocm.software.package.v1+yaml path: packagespec.yaml values: RELEASE_NAME: megacomp\rutf-8 Adds a resource from inline text.\nresources: - name: noticeplain type : blob input: text: \u0026#34;Here is some text\u0026#34; mediaType: text/plain compress: false type: utf8\rAccess Types gitHub Refers to a Git repository at a certain commit or tag.\nresources: - name: git-ocm type: blob version: ${VERSION} access: type: gitHub repoUrl: https://github.com/open-component-model/ocm commit: 42cc249aec77aa64984b2b91eb0f3b96dd63aacd\rhelm Refers to a helm chart located in a helm chart repository.\n- name: mariadb-chart type: helmChart version: ${VERSION} access: type: helm helmChart: mariadb:12.2.7 helmRepository: https://charts.bitnami.com/bitnami\rnpm Refers to an npm package located in a Javascript package registry.\n- name: prime-npm type: ocm/npmPackage version: ${VERSION} access: type: npm package: random-prime version: 4.0.0 registry: https://registry.npmjs.org\rociArtifact Refers to an image in an (external) OCI registry.\nresources: - name: echo-image version: \u0026#34;1.10\u0026#34; type: ociImage access: type: ociArtifact imageReference: gcr.io/google_containers/echoserver:1.10\rs3 Refers to an object in an AWS S3 store.\nresources: - name: gardenlinux-meta type: blob version: ${VERSION} access: type: s3 bucket: gardenlinux key: meta/singles/gcp-cloud-gardener-_prod-890.0-53b732\r","date":"0001-01-01","id":16,"permalink":"/dev/docs/tutorials/input-and-access-types/","summary":"\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#overview\"\u003eOverview\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#input-types\"\u003eInput Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#binary\"\u003ebinary\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dir\"\u003edir\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#docker\"\u003edocker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dockermulti\"\u003edockermulti\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#file\"\u003efile\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociimage\"\u003eociImage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#spiff\"\u003espiff\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#utf-8\"\u003eutf-8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#access-types\"\u003eAccess Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#github\"\u003egitHub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm-1\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#npm\"\u003enpm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociartifact\"\u003eociArtifact\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#s3\"\u003es3\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\u003c/p\u003e","tags":[],"title":"Input and Access Types"},{"content":"Overview The OCM command line client can be configured by supplying it with a configuration file. By default, the CLI looks for configuration in $HOME/.ocmconfig, if it exists.\nThe configuration file can be used in particular to specify the credentials, which are required for the CLI to be able to access the artifact repositories referenced in CLI commands.\nExamples This page contains basic examples of credentials configuration for a few most common artifact repository types. The examples below are complete .ocmconfig files, not snippets.\nFor comprehensive documentation on the credentials topic, including usage of certificates or HashiCorp Vault, execute the command ocm credential-handling.\nRepositories and Consumers In the examples below, some configuration is located under configurations[0].repositories, and some other under configurations[0].consumers. This chapter explains the difference between repositories and consumers, which is potentially not as obvious as one could think.\nIn this context, repository is a place where credentials can be stored, i.e., it is a credentials repository. For example, Docker\u0026rsquo;s config.json can store multiple credentials, and in that sense the file serves as a repository that can store and provide credentials. That is why its location is configured under repositories. Other examples of credentials repositories can be the NPM\u0026rsquo;s .npmrc file or a HashiCorp Vault instance.\nA consumer is something the credentials are required for. For example, if you need to configure credentials that are required to log in to an OCI registry, one could say that the registry will be consuming these credentials, i.e., the registry is a credentials consumer. That is why it is configured under consumers.\nReuse Credentials Configured for Docker This .ocmconfig file will tell the OCM CLI to use credentials configuration from Docker\u0026rsquo;s config.json file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34;\rReuse Credentials Configured for npm This .ocmconfig file will tell OCM CLI to use credentials configuration from npm\u0026rsquo;s .npmrc file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: NPMConfig/v1 npmrcFile: \u0026#39;~/.npmrc\u0026#39;\rAccessing OCI Registries HTTPS and Path To access artifacts in https://ghcr.io/open-component-model:\nThe different parts of the URL have to be specified in separate fields: scheme, hostname, and pathprefix The fields scheme and pathprefix are optional. If not specified, the OCM CLI will use the credentials for all schemes and paths on that host The password is the user\u0026rsquo;s basic authentication password. Some OCI registries allow to generate user access tokens, which can also be used for basic authentication type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rHTTP, Port Number, Empty Path To access artifacts in http://127.0.0.1:5001:\nThe fields scheme and port are optional. If not specified, the OCM CLI will use the credentials for all schemes and ports on that host As the URL has no path behind the port number, the pathprefix element can be removed type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: http hostname: 127.0.0.1 port: 5001 credentials: - type: Credentials properties: username: admin password: admin\rAccessing Helm Chart Repositories Similar to OCI registries, but uses HelmChartRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: HelmChartRepository hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rAccessing Maven Repositories Similar to OCI registries, but uses MavenRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: MavenRepository hostname: maven.repo.host pathprefix: path/to/repo credentials: - type: Credentials properties: username: some-user password: some-password\rAccessing npm Registries Similar to OCI registries, but uses NpmRegistry as identity type. In addition, it is required to specify the email address matching with the one in the user record in the npm registry.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: NpmRegistry hostname: npm.registry.host pathprefix: path/to/registry credentials: - type: Credentials properties: username: some-user password: some-password email: foo.bar@acme.org\rAccessing GitHub Repositories To access code in https://my.github.enterprise/my-org/my-repo:\nUse Github as identity type hostname is the domain name of the GitHub instance pathprefix is a combination of organization and repository names token is a personal access token generated in GitHub Developer Settings type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\rAccessing Several Systems It is, of course, possible to configure credentials for several systems in the same .ocmconfig file. To do that, you can combine as many repositories and consumers as you need.\nThe example below instructs OCM CLI to look for credentials in Docker\u0026rsquo;s config.json, and in addition specifies dedicated credentials for an OCI registry and a GitHub repository.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true consumers: - identity: type: OCIRegistry hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\r","date":"0001-01-01","id":17,"permalink":"/dev/docs/tutorials/creds-in-ocmconfig/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm.md\" target=\"_blank\" rel=\"noopener\"\u003eOCM command line client\u003c/a\u003e can be configured by supplying it with a \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_configfile.md\" target=\"_blank\" rel=\"noopener\"\u003econfiguration file\u003c/a\u003e. By default, the CLI looks for configuration in \u003ccode\u003e$HOME/.ocmconfig\u003c/code\u003e, if it exists.\u003c/p\u003e","tags":[],"title":"Credentials in .ocmconfig File"},{"content":"","date":"0001-01-01","id":18,"permalink":"/dev/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":19,"permalink":"/dev/community/","summary":"","tags":[],"title":"Communities"},{"content":"","date":"0001-01-01","id":20,"permalink":"/dev/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":21,"permalink":"/dev/docs/","summary":"","tags":[],"title":"Documentation"},{"content":"ocm The official Open Component Model (OCM) CLI\nSynopsis The Open Component Model command line client supports the work with OCM artifacts, like Component Archives, Common Transport Archive, Component Repositories, and Component Versions.\nocm [sub-command] [flags]\rOptions --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. -h, --help help for ocm --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm add\t- Add anything to OCM ocm completion\t- Generate the autocompletion script for the specified shell ocm download\t- Download anything from OCM ocm generate\t- Generate documentation for the OCM CLI ocm get\t- Get anything from OCM ocm version\t- Retrieve the build version of the OCM CLI ","date":"0001-01-01","id":22,"permalink":"/dev/docs/reference/ocm-cli/ocm/","summary":"\u003ch2 id=\"ocm\"\u003eocm\u003c/h2\u003e\n\u003cp\u003eThe official Open Component Model (OCM) CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eThe Open Component Model command line client supports the work with OCM\nartifacts, like Component Archives, Common Transport Archive,\nComponent Repositories, and Component Versions.\u003c/p\u003e","tags":[],"title":"ocm"},{"content":"ocm add Add anything to OCM\nocm add {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for add\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm add component-version\t- Add component version(s) to an OCM Repository stored as Common Transport Format Archive (CTF) based on a \u0026ldquo;component-constructor\u0026rdquo; file ","date":"0001-01-01","id":23,"permalink":"/dev/docs/reference/ocm-cli/ocm-add/","summary":"\u003ch2 id=\"ocm-add\"\u003eocm add\u003c/h2\u003e\n\u003cp\u003eAdd anything to OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for add\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string        supply configuration by a given configuration file.\n                             By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                             1. The path specified in the OCM_CONFIG_PATH environment variable\n                             2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                             - $XDG_CONFIG_HOME/ocm/config\n                             - $XDG_CONFIG_HOME/.ocmconfig\n                             - $HOME/.config/ocm/config\n                             - $HOME/.config/.ocmconfig\n                             - $HOME/.ocm/config\n                             - $HOME/.ocmconfig\n                             3. The current working directory:\n                             - $PWD/ocm/config\n                             - $PWD/.ocmconfig\n                             4. The directory of the current executable:\n                             - $EXE_DIR/ocm/config\n                             - $EXE_DIR/.ocmconfig\n                             Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum       set the log output format that is used to print individual logs\n                                json: Output logs in JSON format, suitable for machine processing\n                                text: Output logs in human-readable text format, suitable for console output\n                             (must be one of [json text]) (default text)\n      --loglevel enum        sets the logging level\n                                debug: Show all logs including detailed debugging information\n                                info:  Show informational messages and above\n                                warn:  Show warnings and errors only (default)\n                                error: Show errors only\n                             (must be one of [debug error info warn]) (default info)\n      --logoutput enum       set the log output destination\n                                stdout: Write logs to standard output (default)\n                                stderr: Write logs to standard error, useful for separating logs from normal output\n                             (must be one of [stderr stdout]) (default stdout)\n      --temp-folder string   Specify a custom temporary folder path for filesystem operations.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-add-component-version/\"\u003eocm add component-version\u003c/a\u003e\t - Add component version(s) to an OCM Repository stored as Common Transport Format Archive (CTF) based on a \u0026ldquo;component-constructor\u0026rdquo; file\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm add"},{"content":"ocm add component-version Add component version(s) to an OCM Repository stored as Common Transport Format Archive (CTF) based on a \u0026ldquo;component-constructor\u0026rdquo; file\nSynopsis Add component version(s) to an OCM Common Transport Format Archive (CTF) that can be reused for transfers.\nA \u0026ldquo;component-constructor\u0026rdquo; file is used to specify the component version(s) to be added. It can contain both a single component or many components. The component reference is used to determine the repository to add the components to.\nBy default, the command will look for a file named \u0026ldquo;\u0026ldquo;component-constructor\u0026rdquo;.yaml\u0026rdquo; or \u0026ldquo;\u0026ldquo;component-constructor\u0026rdquo;.yml\u0026rdquo; in the current directory. If given a path to a directory, the command will look for a file named \u0026ldquo;component-constructor.yaml\u0026rdquo; or \u0026ldquo;component-constructor.yml\u0026rdquo; in that directory. If given a path to a file, the command will attempt to use that file as the \u0026ldquo;component-constructor\u0026rdquo; file.\nIn case the component archive does not exist, it will be created by default.\nocm add component-version [flags]\rExamples Adding component versions to a non-default CTF named \u0026#34;transport-archive\u0026#34; based on a non-default default \u0026#34;component-constructor\u0026#34; file: add component-version --repository ./path/to/transport-archive --constructor ./path/to/component-constructor.yaml\rOptions --blob-cache-directory string path to the blob cache directory (default \u0026#34;.ocm/cache\u0026#34;) --component-version-conflict-policy enum policy to apply when a component version already exists in the repository (must be one of [abort-and-fail replace skip]) (default abort-and-fail) --concurrency-limit int maximum number of component versions that can be constructed concurrently. (default 4) -c, --constructor path path to the component constructor file (default component-constructor.yaml) -h, --help help for component-version -r, --repository path path to the repository (default transport-archive) --skip-reference-digest-processing skip digest processing for resources and sources. Any resource referenced via access type will not have their digest updated.\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm add\t- Add anything to OCM ","date":"0001-01-01","id":24,"permalink":"/dev/docs/reference/ocm-cli/ocm-add-component-version/","summary":"\u003ch2 id=\"ocm-add-component-version\"\u003eocm add component-version\u003c/h2\u003e\n\u003cp\u003eAdd component version(s) to an OCM Repository stored as Common Transport Format Archive (CTF) based on a \u0026ldquo;component-constructor\u0026rdquo; file\u003c/p\u003e","tags":[],"title":"ocm add component-version"},{"content":"","date":"0001-01-01","id":25,"permalink":"/dev/docs/reference/ocm-cli/","summary":"","tags":[],"title":"OCM CLI"},{"content":"ocm completion Generate the autocompletion script for the specified shell\nSynopsis Generate the autocompletion script for ocm for the specified shell. See each sub-command\u0026rsquo;s help for details on how to use the generated script.\nOptions -h, --help help for completion\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm completion bash\t- Generate the autocompletion script for bash ocm completion fish\t- Generate the autocompletion script for fish ocm completion powershell\t- Generate the autocompletion script for powershell ocm completion zsh\t- Generate the autocompletion script for zsh ","date":"0001-01-01","id":26,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion/","summary":"\u003ch2 id=\"ocm-completion\"\u003eocm completion\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for the specified shell\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for ocm for the specified shell.\nSee each sub-command\u0026rsquo;s help for details on how to use the generated script.\u003c/p\u003e","tags":[],"title":"ocm completion"},{"content":"ocm completion bash Generate the autocompletion script for bash\nSynopsis Generate the autocompletion script for the bash shell.\nThis script depends on the \u0026lsquo;bash-completion\u0026rsquo; package. If it is not installed already, you can install it via your OS\u0026rsquo;s package manager.\nTo load completions in your current shell session:\nsource \u0026lt;(ocm completion bash) To load completions for every new session, execute once:\nLinux: ocm completion bash \u0026gt; /etc/bash_completion.d/ocm macOS: ocm completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/ocm You will need to start a new shell for this setup to take effect.\nocm completion bash\rOptions -h, --help help for bash --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":27,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-bash/","summary":"\u003ch2 id=\"ocm-completion-bash\"\u003eocm completion bash\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for bash\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the bash shell.\u003c/p\u003e\n\u003cp\u003eThis script depends on the \u0026lsquo;bash-completion\u0026rsquo; package.\nIf it is not installed already, you can install it via your OS\u0026rsquo;s package manager.\u003c/p\u003e","tags":[],"title":"ocm completion bash"},{"content":"ocm completion fish Generate the autocompletion script for fish\nSynopsis Generate the autocompletion script for the fish shell.\nTo load completions in your current shell session:\nocm completion fish | source To load completions for every new session, execute once:\nocm completion fish \u0026gt; ~/.config/fish/completions/ocm.fish You will need to start a new shell for this setup to take effect.\nocm completion fish [flags]\rOptions -h, --help help for fish --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":28,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-fish/","summary":"\u003ch2 id=\"ocm-completion-fish\"\u003eocm completion fish\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for fish\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the fish shell.\u003c/p\u003e\n\u003cp\u003eTo load completions in your current shell session:\u003c/p\u003e","tags":[],"title":"ocm completion fish"},{"content":"ocm completion powershell Generate the autocompletion script for powershell\nSynopsis Generate the autocompletion script for powershell.\nTo load completions in your current shell session:\nocm completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your powershell profile.\nocm completion powershell [flags]\rOptions -h, --help help for powershell --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":29,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-powershell/","summary":"\u003ch2 id=\"ocm-completion-powershell\"\u003eocm completion powershell\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for powershell\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for powershell.\u003c/p\u003e\n\u003cp\u003eTo load completions in your current shell session:\u003c/p\u003e","tags":[],"title":"ocm completion powershell"},{"content":"ocm completion zsh Generate the autocompletion script for zsh\nSynopsis Generate the autocompletion script for the zsh shell.\nIf shell completion is not already enabled in your environment you will need to enable it. You can execute the following once:\necho \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc To load completions in your current shell session:\nsource \u0026lt;(ocm completion zsh) To load completions for every new session, execute once:\nLinux: ocm completion zsh \u0026gt; \u0026quot;${fpath[1]}/_ocm\u0026quot; macOS: ocm completion zsh \u0026gt; $(brew --prefix)/share/zsh/site-functions/_ocm You will need to start a new shell for this setup to take effect.\nocm completion zsh [flags]\rOptions -h, --help help for zsh --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":30,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-zsh/","summary":"\u003ch2 id=\"ocm-completion-zsh\"\u003eocm completion zsh\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for zsh\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the zsh shell.\u003c/p\u003e\n\u003cp\u003eIf shell completion is not already enabled in your environment you will need\nto enable it.  You can execute the following once:\u003c/p\u003e","tags":[],"title":"ocm completion zsh"},{"content":"ocm download Download anything from OCM\nocm download {resource|resources|plugin|plugins} [flags]\rOptions -h, --help help for download\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm download plugin\t- Download plugin binaries from a component version. ocm download resource\t- Download resources described in a component version in an OCM Repository ","date":"0001-01-01","id":31,"permalink":"/dev/docs/reference/ocm-cli/ocm-download/","summary":"\u003ch2 id=\"ocm-download\"\u003eocm download\u003c/h2\u003e\n\u003cp\u003eDownload anything from OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download {resource|resources|plugin|plugins} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for download\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string        supply configuration by a given configuration file.\n                             By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                             1. The path specified in the OCM_CONFIG_PATH environment variable\n                             2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                             - $XDG_CONFIG_HOME/ocm/config\n                             - $XDG_CONFIG_HOME/.ocmconfig\n                             - $HOME/.config/ocm/config\n                             - $HOME/.config/.ocmconfig\n                             - $HOME/.ocm/config\n                             - $HOME/.ocmconfig\n                             3. The current working directory:\n                             - $PWD/ocm/config\n                             - $PWD/.ocmconfig\n                             4. The directory of the current executable:\n                             - $EXE_DIR/ocm/config\n                             - $EXE_DIR/.ocmconfig\n                             Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum       set the log output format that is used to print individual logs\n                                json: Output logs in JSON format, suitable for machine processing\n                                text: Output logs in human-readable text format, suitable for console output\n                             (must be one of [json text]) (default text)\n      --loglevel enum        sets the logging level\n                                debug: Show all logs including detailed debugging information\n                                info:  Show informational messages and above\n                                warn:  Show warnings and errors only (default)\n                                error: Show errors only\n                             (must be one of [debug error info warn]) (default info)\n      --logoutput enum       set the log output destination\n                                stdout: Write logs to standard output (default)\n                                stderr: Write logs to standard error, useful for separating logs from normal output\n                             (must be one of [stderr stdout]) (default stdout)\n      --temp-folder string   Specify a custom temporary folder path for filesystem operations.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-plugin/\"\u003eocm download plugin\u003c/a\u003e\t - Download plugin binaries from a component version.\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-resource/\"\u003eocm download resource\u003c/a\u003e\t - Download resources described in a component version in an OCM Repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm download"},{"content":"ocm download plugin Download plugin binaries from a component version.\nSynopsis Download a plugin binary from a component version located in a component version.\nThis command fetches a specific plugin resource from the given OCM component version and stores it at the specified output location. The plugin binary can be identified by resource name and version, with optional extra identity parameters for platform-specific binaries.\nResources can be accessed either locally or via a plugin that supports remote fetching, with optional credential resolution.\nocm download plugin [flags]\rExamples # Download a plugin binary with resource name \u0026#39;ocm-plugin\u0026#39; and version \u0026#39;v1.0.0\u0026#39; ocm download plugin ghcr.io/org/component:v1 --resource-name ocm-plugin --resource-version v1.0.0 --output ./plugins/ocm-plugin # Download a platform-specific plugin binary with extra identity parameters ocm download plugin ghcr.io/org/component:v1 --resource-name ocm-plugin --resource-version v1.0.0 --extra-identity os=linux,arch=amd64 --output ./plugins/ocm-plugin-linux-amd64 # Download plugin using only resource name (uses component version if resource version not specified) ocm download plugin ghcr.io/org/component:v1 --resource-name ocm-plugin --output ./plugins/ocm-plugin\rOptions --extra-identity strings extra identity parameters for resource matching (e.g., os=linux,arch=amd64) -h, --help help for plugin --output string output location to download the plugin binary to (required) (default \u0026#34;.\u0026#34;) -f, --output-format enum output format of the plugin information (must be one of [json table yaml]) (default table) --resource-name string name of the plugin resource to download (required) --resource-version string version of the plugin resource to download (optional, defaults to component version) --skip-validation skip validation of the downloaded plugin binary\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm download\t- Download anything from OCM ","date":"0001-01-01","id":32,"permalink":"/dev/docs/reference/ocm-cli/ocm-download-plugin/","summary":"\u003ch2 id=\"ocm-download-plugin\"\u003eocm download plugin\u003c/h2\u003e\n\u003cp\u003eDownload plugin binaries from a component version.\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDownload a plugin binary from a component version located in a component version.\u003c/p\u003e","tags":[],"title":"ocm download plugin"},{"content":"ocm download resource Download resources described in a component version in an OCM Repository\nSynopsis Download a resource from a component version located in an Open Component Model (OCM) repository.\nThis command fetches a specific resource from the given OCM component version reference and stores it at the specified output location. It supports optional transformation of the resource using a registered transformer plugin.\nIf no transformer is specified, the resource is written directly in its original format. If the media type is known, the appropriate file extension will be added to the output file name if no output location is given.\nResources can be accessed either locally or via a plugin that supports remote fetching, with optional credential resolution.\nocm download resource [flags]\rExamples # Download a resource with identity \u0026#39;name=example\u0026#39; and write to default output ocm resource ghcr.io/org/component:v1 --identity name=example # Download a resource and specify an output file ocm resource ghcr.io/org/component:v1 --identity name=example --output ./my-resource.tar.gz # Download a resource and apply a transformer ocm resource ghcr.io/org/component:v1 --identity name=example --transformer my-transformer\rOptions -h, --help help for resource --identity string resource identity to download --output string output location to download to. If no transformer is specified, and no format was discovered that can be written to a directory, the resource will be written to a file. --transformer string transformer to use for the output. If not specified, the resource will be written as is. Options inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm download\t- Download anything from OCM ","date":"0001-01-01","id":33,"permalink":"/dev/docs/reference/ocm-cli/ocm-download-resource/","summary":"\u003ch2 id=\"ocm-download-resource\"\u003eocm download resource\u003c/h2\u003e\n\u003cp\u003eDownload resources described in a component version in an OCM Repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDownload a resource from a component version located in an Open Component Model (OCM) repository.\u003c/p\u003e","tags":[],"title":"ocm download resource"},{"content":"ocm generate Generate documentation for the OCM CLI\nSynopsis A longer description that spans multiple lines and likely contains examples and usage of using your command. For example:\nCobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.\nOptions -h, --help help for generate\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm generate docs\t- Generate Documentation for the CLI ","date":"0001-01-01","id":34,"permalink":"/dev/docs/reference/ocm-cli/ocm-generate/","summary":"\u003ch2 id=\"ocm-generate\"\u003eocm generate\u003c/h2\u003e\n\u003cp\u003eGenerate documentation for the OCM CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eA longer description that spans multiple lines and likely contains examples\nand usage of using your command. For example:\u003c/p\u003e","tags":[],"title":"ocm generate"},{"content":"ocm generate docs Generate Documentation for the CLI\nSynopsis Generate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.\nocm generate docs [-d \u0026lt;directory\u0026gt;] [--mode \u0026lt;format\u0026gt;] [flags]\rOptions -d, --directory string directory to generate docs to. If not set, current working directory is used. -h, --help help for docs --mode enum generation mode to use (must be one of [hugo man markdown restructured yaml]) (default markdown)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm generate\t- Generate documentation for the OCM CLI ","date":"0001-01-01","id":35,"permalink":"/dev/docs/reference/ocm-cli/ocm-generate-docs/","summary":"\u003ch2 id=\"ocm-generate-docs\"\u003eocm generate docs\u003c/h2\u003e\n\u003cp\u003eGenerate Documentation for the CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.\u003c/p\u003e","tags":[],"title":"ocm generate docs"},{"content":"ocm get Get anything from OCM\nocm get {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for get\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm get component-version\t- Get component version(s) from an OCM repository ","date":"0001-01-01","id":36,"permalink":"/dev/docs/reference/ocm-cli/ocm-get/","summary":"\u003ch2 id=\"ocm-get\"\u003eocm get\u003c/h2\u003e\n\u003cp\u003eGet anything from OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for get\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string        supply configuration by a given configuration file.\n                             By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                             1. The path specified in the OCM_CONFIG_PATH environment variable\n                             2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                             - $XDG_CONFIG_HOME/ocm/config\n                             - $XDG_CONFIG_HOME/.ocmconfig\n                             - $HOME/.config/ocm/config\n                             - $HOME/.config/.ocmconfig\n                             - $HOME/.ocm/config\n                             - $HOME/.ocmconfig\n                             3. The current working directory:\n                             - $PWD/ocm/config\n                             - $PWD/.ocmconfig\n                             4. The directory of the current executable:\n                             - $EXE_DIR/ocm/config\n                             - $EXE_DIR/.ocmconfig\n                             Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum       set the log output format that is used to print individual logs\n                                json: Output logs in JSON format, suitable for machine processing\n                                text: Output logs in human-readable text format, suitable for console output\n                             (must be one of [json text]) (default text)\n      --loglevel enum        sets the logging level\n                                debug: Show all logs including detailed debugging information\n                                info:  Show informational messages and above\n                                warn:  Show warnings and errors only (default)\n                                error: Show errors only\n                             (must be one of [debug error info warn]) (default info)\n      --logoutput enum       set the log output destination\n                                stdout: Write logs to standard output (default)\n                                stderr: Write logs to standard error, useful for separating logs from normal output\n                             (must be one of [stderr stdout]) (default stdout)\n      --temp-folder string   Specify a custom temporary folder path for filesystem operations.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-get-component-version/\"\u003eocm get component-version\u003c/a\u003e\t - Get component version(s) from an OCM repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm get"},{"content":"ocm get component-version Get component version(s) from an OCM repository\nSynopsis Get component version(s) from an OCM repository.\nThe format of a component reference is: [type::]{repository}/[valid-prefix]/{component}[:version]\nFor valid prefixes {component-descriptors|none} are available. If is used, it defaults to \u0026ldquo;component-descriptors\u0026rdquo;. This is because by default, OCM components are stored within a specific sub-repository.\nFor known types, currently only {OCIRepository|CommonTransportFormat} are supported, which can be shortened to {OCI|oci|CTF|ctf} respectively for convenience.\nIf no type is given, the repository path is interpreted based on introspection and heuristics.\nocm get component-version {reference} [flags]\rExamples Getting a single component version: get component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 get cv ./path/to/ctf//ocm.software/ocmcli:0.23.0 get cv ./path/to/ctf/component-descriptors/ocm.software/ocmcli:0.23.0 Listing many component versions: get component-versions ghcr.io/open-component-model/ocm//ocm.software/ocmcli get cvs ghcr.io/open-component-model/ocm//ocm.software/ocmcli --output json get cvs ghcr.io/open-component-model/ocm//ocm.software/ocmcli -oyaml Specifying types and schemes: get cv ctf::github.com/locally-checked-out-repo//ocm.software/ocmcli:0.23.0 get cvs oci::http://localhost:8080//ocm.software/ocmcli\rOptions --concurrency-limit int maximum amount of parallel requests to the repository for resolving component versions (default 4) -h, --help help for component-version --latest if set, only the latest version of the component is returned -o, --output enum output format of the component descriptors (must be one of [json table yaml]) (default table) --semver-constraint string semantic version constraint restricting which versions to output (default \u0026#34;\u0026gt; 0.0.0-0\u0026#34;)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm get\t- Get anything from OCM ","date":"0001-01-01","id":37,"permalink":"/dev/docs/reference/ocm-cli/ocm-get-component-version/","summary":"\u003ch2 id=\"ocm-get-component-version\"\u003eocm get component-version\u003c/h2\u003e\n\u003cp\u003eGet component version(s) from an OCM repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGet component version(s) from an OCM repository.\u003c/p\u003e\n\u003cp\u003eThe format of a component reference is:\n[type::]{repository}/[valid-prefix]/{component}[:version]\u003c/p\u003e","tags":[],"title":"ocm get component-version"},{"content":"ocm version Retrieve the build version of the OCM CLI\nSynopsis The version command retrieves the build version of the OCM CLI.\nThe build version can be formatted in different ways depending on the specified format flag. The default format is \u0026ldquo;legacyjson\u0026rdquo;, which outputs the version in a format compatible with OCM v1 specifications, with slight modifications:\n\u0026ldquo;gitTreeState\u0026rdquo; is removed in favor of \u0026ldquo;meta\u0026rdquo; field, which contains the git tree state. \u0026ldquo;buildDate\u0026rdquo; and \u0026ldquo;gitCommit\u0026rdquo; are derived from the input version string, and are parsed according to the go module version specification. When the format is set to \u0026ldquo;gobuildinfo\u0026rdquo;, it outputs the Go build information as a string. The format is standardized and unified across all golang applications.\nWhen the format is set to \u0026ldquo;gobuildinfojson\u0026rdquo;, it outputs the Go build information in JSON format. This is equivalent to \u0026ldquo;gobuildinfo\u0026rdquo;, but in a structured JSON format.\nThe build info by default is drawn from the go module build information, which is set at build time of the CLI. When officially built, it is possibly overwritten with the released version of the OCM CLI.\nocm version [flags]\rExamples ocm version --format legacyjson\rOptions -f, --format string format of the generated documentation (default \u0026#34;legacyjson\u0026#34;) -h, --help help for version\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output (default) stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stdout) --temp-folder string Specify a custom temporary folder path for filesystem operations.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ","date":"0001-01-01","id":38,"permalink":"/dev/docs/reference/ocm-cli/ocm-version/","summary":"\u003ch2 id=\"ocm-version\"\u003eocm version\u003c/h2\u003e\n\u003cp\u003eRetrieve the build version of the OCM CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eThe version command retrieves the build version of the OCM CLI.\u003c/p\u003e","tags":[],"title":"ocm version"},{"content":"","date":"0001-01-01","id":39,"permalink":"/dev/","summary":"","tags":[],"title":"Open Component Model"},{"content":"","date":"0001-01-01","id":40,"permalink":"/dev/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"","date":"0001-01-01","id":41,"permalink":"/dev/tags/","summary":"","tags":[],"title":"Tags"},{"content":" How to engage with us # The Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\nGitHub # Our GitHub repositories are the central hub for all project development. Connect with our codebase, report issues, submit pull requests, and follow our project\u0026rsquo;s progress. New contributors can find issues labeled good first issue to get started, and our detailed contribution guidelines will help you make your first successful submission.\nSlack # Join our #open-component-model channel in the Kubernetes Slack workspace and connect with us and other community members.\nKubernetes Slack Membership\nIf you aren\u0026rsquo;t already a member in the Kubernetes Slack workspace, please request an invitation\nOur team is passionate about delving into diverse deployment processes, exploring patterns, aiding in design, and troubleshooting issues. Who knows? Your inquiry might inspire the development of the next useful OCM feature!\nCommunity Calls # We\u0026rsquo;re excited to announce our regular community calls:\nSchedule # Frequency: Every first Wednesday of the months Time: 15:00-16:00 UTC (17:00-18:00 CEST, 11:00-12:00 EDT, 08:00-09:00 PDT) Duration: 1 hour Location: Use this Zoom Link to join the call. iCal (Apple/Outlook) # Download the .ics file to add the community call meeting series to your calendar.\nCall History # This page contains the history of the Open Component Model community calls and links to slides and recordings.\nWhat to Expect # Join us to see and discuss project updates, share your feedback, ask questions, and connect with other community members. The community calls should be an open discussion space and give a voice to any interested stakeholder. At the same time we want our community to be diverse, helpful, collaborative and fun.\nThese calls are open to everyone and will be moderated by at least one OCM Core Maintainer. We will answer anything you might bring up!\nWhat to Bring # We want to hear from you! This is your chance to share your thoughts and ideas with the community. You can bring anything, including:\nIdeas how to make OCM better Issues you would like to talk about and that should be addressed Concepts you would like to work on together Questions you have about the community or upcoming work Contributing # We welcome community contributions! Please see the Contributing Guideline for instructions on how to submit changes. If you are planning on making more elaborate or potentially controversial changes, please discuss them with the maintainers in the Slack channel before sending a pull request.\nCode of Conduct # To make OCM a welcoming and harassment-free experience for everyone, we follow the CNCF Code of Conduct.\nSecurity Guideline # In case you want to report any security vulnerabilities inside the Open Component Model project, please do not report them through public GitHub issues.\nPlease visit the Open Source Security Policy for more information.\n","date":"0001-01-01","id":42,"permalink":"/dev/community/engagement/","summary":"\u003ch2 id=\"how-to-engage-with-us\"\u003e\n  How to engage with us\n  \u003ca href=\"#how-to-engage-with-us\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\u003c/p\u003e","tags":[],"title":"The OCM Community"}]