[{"content":"","date":"0001-01-01","id":0,"permalink":"/dev/docs/overview/","summary":"","tags":[],"title":"Overview"},{"content":"The Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It’s built to support secure, reliable delivery and deployment of software—across cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\nBelow are the main projects, but please also check out the others in our Github org.\nOCM Specification - The ocm-spec repository contains the OCM specification, which provides a formal description of OCM and its format to describe software artifacts and a storage layer to persist those and make them accessible from remote. OCM Core Library - The ocm core library contains an API for interacting with OCM elements. A guided tour on how to work with the library can be found here. OCM CLI - With the ocm command line interface end users can interact with OCM elements, helping them create component versions and embed them in CI and CD processes. Examples can be found in this Makefile. OCM Controller - The ocm-controllers are designed to enable the automated deployment of software using the Open Component Model and Flux. OCM Website - The ocm-website you are currently visiting. It is built using Hugo and hosted on Github Pages. ","date":"0001-01-01","id":1,"permalink":"/dev/docs/overview/about/","summary":"\u003cp\u003eThe Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It’s built to support secure, reliable delivery and deployment of software—across cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\u003c/p\u003e","tags":[],"title":"About the OCM Project"},{"content":"Software development is complex. Most organizations struggle with fragmented tools, complicated workflows, and the challenge of managing software across different environments - cloud, on-premises, hybrid, and even air-gapped networks.\nTraditional approaches lead to:\nComplicated, custom CI/CD pipelines Inconsistent software delivery Difficulty tracking and securing software components Lack of a standard way to describe software and its artifacts Requirements Towards a Modern Software Component Model Community-First Approach A truly modern software component model cannot live in isolation. It needs an active, diverse community to grow, adapt, and remain relevant. Open source projects invite users and maintainers to propose ideas, report issues, and deliver improvements. Lowering entry barriers nurtures diverse perspectives, accelerates innovation, and ensures real-world feedback shapes priorities. Continuous collaboration - through design discussions, reviews, and documentation — builds trust and fosters adoption across industries. In this way, the community itself becomes the guarantor of quality, relevance, and long-term sustainability.\nImmutable and Unique Component Identity A crucial requirement is the ability to assign an immutable and globally unique Component Identity to each software component. This identifier acts as a \u0026ldquo;correlation ID,\u0026rdquo; allowing all lifecycle management processes, such as security compliance and vulnerability scanning, to correlate their outputs to a single, identifiable software component.\nArtifact Descriptions with Location Information The model should facilitate the description of all technical artifacts required for deploying a specific version of a software component. This list, termed a \u0026ldquo;Software Bill of Delivery\u0026rdquo; (SBoD), outlines only the artifacts needed for successful deployment. Additionally, the description must encompass the technical access location from which each artifact can be retrieved.\nSeparation of Component Identity and Artifact Location Organizations often need to:\nStore artifacts in local registries Work in environments with limited or no internet access (air-gapped) Move artifacts between different systems and environments The Component Identity must remain stable across all boundaries and system environments, while the artifact locations should be changeable. The ideal model separates the component identity from its artifact locations, allowing maximum flexibility.\nTechnology Neutrality Real-world software environments are messy. A good component model must:\nSupport modern containerized applications Handle legacy software Work across clouds, on-premises, and hybrid infrastructures Technology-Agnostic and Forward-Thinking Design The model should:\nAdapt easily to emerging technologies Avoid constant rewrites of existing tools and processes Stay relevant as software development evolves Cover both legacy and modern software Built-In Security Automatic capabilities for:\nSigning software components Verifying artifact integrity Protecting against tampering Maintaining trust across changing artifact locations Collaborative Potential Enable teams to:\nEasily share and reuse trusted components Create a network of verifiable, reusable and high-quality software building blocks OCM: Solving Software Lifecycle Complexity The Open Component Model (OCM) is designed to tackle these challenges head-on. It provides a standardized approach to describing, managing, and sharing software components that brings order to software lifecycle management. By linking additional metadata using OCM’s identities, it facilitates asynchronous handling of various lifecycle management processes, such as compliance checks, security scans, deployments, and more, in a decoupled and streamlined manner.\nCommunity-Driven Governance: OCM’s open governance and transparent contribution workflow empower anyone to asynchronously propose, review, and merge enhancements — keeping its software lifecycles aligned with evolving community needs.\nUnique Component Identities: OCM assigns an immutable, globally unique ID to each component, enabling seamless correlation across all lifecycle tools and processes.\nSoftware Bill of Delivery: OCM enables the specification of all artifacts required for delivering a software component. This compilation, termed a \u0026ldquo;Software Bill of Delivery\u0026rdquo; (SBoD), lists all artifacts and information how to access them.\nStable IDs, Changing Artifact Locations: OCM separates immutable component IDs from the changeable artifact locations, essential for private and air-gapped environments.\nTechnology Agnosticism: Being agnostic to implementation technologies like container images, NPM packages or binaries, OCM can handle both cloud-native and legacy apps.\nFuture-Proof Extensibility: OCM\u0026rsquo;s extensible design allows simple adaptation to emerging trends without disrupting existing tooling.\nTrusted Signatures: Built-in signing and verification ensure artifact integrity even as artifact locations change over time.\nOCM creates a \u0026ldquo;single source of truth\u0026rdquo; for software artifacts. It streamlines compliance checks, security scans, and deployments by providing a consistent, location-independent way to identify, access, exchange, and verify software components.\nBy making software component management more transparent, secure, and efficient, OCM helps organizations transform their software delivery from a complicated puzzle into a smooth, manageable process.\n","date":"0001-01-01","id":2,"permalink":"/dev/docs/overview/benefits-of-ocm/","summary":"\u003cp\u003eSoftware development is complex. Most organizations struggle with fragmented tools, complicated workflows, and the challenge of managing software across different environments - cloud, on-premises, hybrid, and even air-gapped networks.\u003c/p\u003e","tags":[],"title":"Benefits of OCM"},{"content":"As the Open Component Model (OCM) revolves around components, it is essential to establish a common understanding of the fundamental terminology employed throughout this website. The following section provides concise definitions of key terms, laying the groundwork for the documentation and tutorials that follow.\nFor a comprehensive exploration of every aspect of this topic, please refer to the OCM Specification OCM Specification and its Glossary.\nComponents in OCM The concept of a Component can vary widely, often defined with very specific views on granularity or other technical attributes. OCM takes a different approach, focusing on the intended purpose and overall meaning of components.\nIn OCM, Components group a set of semantically related Component Versions. Each Component Version is uniquely and globally identified by a Component Identity and can reference other Components. A Component Version can also contain Artifacts and a formal description on how to access them. These Artifacts come in two categories: resources, which describe the payload (e.g.,OCI images), and sources, which describe the input for creating resources (e.g., source code).\nOCM Coordinates OCM Coordinates are used to reference OCM Component Versions and Artifacts within OCM Component Versions. Coordinates referring to an OCM Component Version are also called Component Identity, whereas relative Coordinates referring to an artifact are called Artifact Identity. Component Identities are globally unique and may be used to refer to full Component Versions. Artifact Identities are always relative to a Component Version and may only be used in conjunction with a Component Identity.\nIn detail:\nComponent Identity Component Name: Identifies a component. Must start with URL-prefix that should be controlled by the owner of the component to avoid collisions. Component Version: If used with a Component name, identifies a specific Component Version. Must adhere to \u0026ldquo;relaxed SemVer\u0026rdquo; (major, minor (+ optional patch level) - optional v-prefix). Artifact Identity Within a Component Version, all Artifacts must have a unique identity. Every Source Identity or Resource Identity always includes a name that typically expresses the intended purpose.\nArtifacts may also have additional extraIdentity attributes that contribute to their identities. extraIdentity attributes are string-to-string maps.\nExamples Assuming there is a component named example.org/my-component with two versions, 1.2.3 and 1.3.0, declaring a resource with the name my-resource, the following OCM Coordinates can be used to reference different elements:\nexample.org/my-component: all versions of the component (1.2.3 + 1.3.0) example.org/my-component:1.2.3: version 1.2.3 of the component example.org/my-component:1.2.3:resource/my-resource: my-resource as declared by the component version ","date":"0001-01-01","id":3,"permalink":"/dev/docs/overview/important-terms/","summary":"\u003cp\u003eAs the Open Component Model (OCM) revolves around components, it is essential to establish a common understanding of the fundamental terminology employed throughout this website. The following section provides concise definitions of key terms, laying the groundwork for the documentation and tutorials that follow.\u003c/p\u003e","tags":[],"title":"Important Terms"},{"content":"Where to find the OCM specification The most up-to-date version of the OCM specification offers you a deep insight to all technical details of the Open Component Model and explains all elements the model OCM is based on.\n","date":"0001-01-01","id":4,"permalink":"/dev/docs/overview/specification/","summary":"\u003ch2 id=\"where-to-find-the-ocm-specification\"\u003eWhere to find the OCM specification\u003c/h2\u003e\n\u003cp\u003eThe most up-to-date version of the \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm-spec/blob/main/README.md\" target=\"_blank\" rel=\"noopener\"\u003eOCM specification\u003c/a\u003e offers you a deep insight to all technical details of the Open Component Model and explains all elements the model OCM is based on.\u003c/p\u003e","tags":[],"title":"Specification"},{"content":"","date":"0001-01-01","id":5,"permalink":"/dev/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"","date":"0001-01-01","id":6,"permalink":"/dev/docs/getting-started/ocm-cli/","summary":"","tags":[],"title":"OCM CLI"},{"content":"This and the following chapters walk you through some basic steps to get started with OCM concepts and the OCM CLI.\nYou will learn how to create a component version, display and examine the component, and download resources.\nWe will update the getting started guides with more actions, like signing, transfer and verification of components during the ongoing development of our new major release.\nTo follow the steps described in this section, you will need to:\nInstall the OCM Command Line Interface (CLI) The CLI is used to interact with component versions and registries. Install it like described in Installing the OCM CLI.\nObtain Access to an OCM Repository This can be any OCI registry for which you have write permission (e.g., GitHub Packages). An OCM repository based on an OCI registry is identified by a leading OCI repository prefix. For example: ghcr.io/\u0026lt;YOUR-ORG\u0026gt;/ocm.\nConfigure Credentials for the CLI to Access the OCM Repository Credentials to be used by the OCM CLI can be configured by supplying it with a configuration file. By default, the CLI looks for the file in $HOME/.ocmconfig.\nUsing the Docker Configuration File The easiest way to configure credentials for the OCM CLI is to reuse an existing Docker configuration json file.\nCreate a file named .ocmconfig in your home directory with the following content:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 # The path to the Docker configuration file dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true - type: attributes.config.ocm.software attributes: cache: ~/.ocm/cache\rUsing Basic Authentication Alternatively, you can use basic authentication. Create a file named .ocmconfig with the following content in your home directory:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: ociRegistry hostname: \u0026lt;YOUR-REGISTRY\u0026gt;/\u0026lt;YOUR-REPO\u0026gt; # e.g. ghcr.io/acme/acme credentials: - type: Credentials properties: username: \u0026lt;YOUR-USERNAME\u0026gt; password: \u0026lt;YOUR-PASSWORD\u0026gt;\rMore information on how to deal with credentials can be found in this guide with many examples for different repository types.\n","date":"0001-01-01","id":7,"permalink":"/dev/docs/getting-started/prerequisites/","summary":"\u003cp\u003eThis and the following chapters walk you through some basic steps to get started with OCM concepts and the OCM CLI.\u003c/p\u003e","tags":[],"title":"Prerequisites"},{"content":"The new major version of the OCM CLI is currently under active development. While we\u0026rsquo;re working on providing pre-built releases through various package managers and distribution channels, the only way to install the OCM CLI right now is to build it from source.\nThis guide will walk you through the process of building and installing the OCM CLI from the source code.\nPrerequisites Before you begin, make sure you have the following tools installed on your system:\nGit for cloning the repository Go (version 1.24 or later) Task build tool Build from Source Step 1: Clone the Repository First, clone the OCM repository from GitHub:\ngit clone https://github.com/open-component-model/open-component-model\rStep 2: Navigate to the CLI Directory Change into the CLI directory:\ncd open-component-model/cli\rStep 3: Build the CLI Use the Task build tool to compile the OCM CLI:\ntask build\rAfter the build completes successfully, you should see output similar to:\ntask: [build] ln -sf /path/to/your/open-component-model/cli/tmp/bin/ocm-\u0026lt;os\u0026gt;-\u0026lt;arch\u0026gt; /path/to/your/open-component-model/cli/tmp/bin/ocm\rThe exact path will vary depending on your system and where you cloned the repository.\nUsing the OCM CLI Once the build is complete, you have three options for using the OCM CLI:\nOption 1: Create a Permanent Alias Add an alias to your shell configuration file for permanent access:\nFor Zsh users (~/.zshrc):\necho \u0026#39;alias ocm=\u0026#34;/path/to/your/open-component-model/cli/tmp/bin/ocm\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc\rFor Bash users (~/.bashrc):\necho \u0026#39;alias ocm=\u0026#34;/path/to/your/open-component-model/cli/tmp/bin/ocm\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc\rReplace /path/to/your/ with the actual path where you cloned the repository.\nOption 2: Create a Session Alias For temporary use in your current terminal session:\nalias ocm=\u0026#34;/path/to/your/open-component-model/cli/tmp/bin/ocm\u0026#34;\rOption 3: Use the Full Path You can also run the OCM CLI directly using the full path:\n/path/to/your/open-component-model/cli/tmp/bin/ocm\rVerify Installation To verify that the OCM CLI is working correctly, run:\nocm version\rThis should display the version information and confirm that the installation was successful.\nWhat\u0026rsquo;s Next? Now that you have the OCM CLI installed, you can start exploring its capabilities. Check out our Getting Started Guides to learn how to use the OCM CLI to work with your component.\nFuture Installation Methods We\u0026rsquo;re actively working on providing more convenient installation methods, including:\nHomebrew packages Docker images Pre-built binaries for GitHub Releases and more Stay tuned for updates as we continue to improve the installation experience!\n","date":"0001-01-01","id":8,"permalink":"/dev/docs/getting-started/installation/","summary":"\u003cp\u003eThe new major version of the OCM CLI is currently under active development. While we\u0026rsquo;re working on providing pre-built releases through various package managers and distribution channels, the only  way to install the OCM CLI right now is to \u003cstrong\u003ebuild it from source\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"Installing the OCM CLI"},{"content":"Creating and Storing Component Versions Component Versions are created using a component-constructor.yaml file, which is a description file that contains one or multiple components. The file describes the components and their artifacts - resources and sources, metadata in form of labels and references to other components.\nComponent Versions are locally stored in archives using the Common Transfer Format (CTF). A CTF archive may contain any number of component versions and is used to transfer components to and between component repositories.\nNote that a CTF archive itself is also an OCM repository, so it can be used as source or target for component transfer operations using the OCM CLI.\nThe command ocm add component-version directly creates a component version from a component-constructor.yaml file and stores it in a local CTF archive.\nCreate a Component Version In this example we will use the the ocm CLI tool to create a very basic component version that contains a local resource and a resource that is accessed from a remote location. The local resource is an arbitrary file that we will create from scratch the remote resource is a Docker image stored in an OCI registry.\nOCM components can contain any kind of resource, including Helm charts, Docker images, any content from local file systems, and more. Take a look at the tutorial about Input and Access Types to see how to define and use different resource types.\nStart by creating a test folder where we execute all required steps for this example and navigating into it:\nmkdir /tmp/helloworld cd /tmp/helloworld\rQuickly create a simple test file with some content in:\necho \u0026#34;My first local Resource for an OCM component\u0026#34; \u0026gt; my-local-resource.txt\rNow create a file component-constructor.yaml, which describes all elements of the component. You can use our public configuration schema to validate the configuration. The schema is available at https://ocm.software/schemas/configuration-schema.yaml and can be used in your editor to validate the configuration (e.g., in Visual Studio Code).\nComponent versions need to have at least a name, version and provider attribute. All other attributes are optional. Check out an example component descriptor or the OCM Specification to see all available attributes.\nAs mentioned before our example component will just contain a local file and a remote Docker image as resources:\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: - name: github.com/acme.org/helloworld # version needs to follow \u0026#34;relaxed\u0026#34; SemVer version: 1.0.0 provider: name: acme.org resources: # local file resource - name: mylocalfile type: blob input: type: file path: ./my-local-resource.txt # remote image resource - name: image type: ociImage version: 1.0.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.9.1\rA resource is described either by its access information to a remote repository or by locally provided resources.\nFor remote access, the field access is used to describe the access method. The type field is used to specify the kind of access.\nIf the resource content is taken from local resources, the field input is used to specify the access to the local resources. Similarly to the access attribute, the kind of the input source is described by the field type.\nAvailable access and input types are described in the tutorial about Input and Access Types.\nAdd Component Version to CTF archive To store our component version locally and to make it transportable, now add it to a CTF archive using the following command.\nocm add component-version\ror the short form (which we will use from now on)\nocm add cv\rThis is the most basic command form, where we use the cv alias and the OCM CLI defaults both the constructor file name and the CTF archive name. If you want to specify different names, you can use the --repository and -c flags.\nocm add cv --repository /path/to/my-own-ctf -c /path/to/my-component-constructor.yaml\r... component github.com/acme.org/helloworld/1.0.0 constructed ... done! [1 component version in 482ms]\rWhat happened? The command created a CTF archive and added the listed components with the described resources.\ntree transport-archive transport-archive ├── artifact-index.json └── blobs ├── sha256.096322a7affa6a26a4549e347399f835b2350454946b4967ffdc570dbed78066 ├── sha256.70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8 ├── sha256.74db132670ec370396ec10160c4e761591d0e9e6c5960c72d2e26c0f9d6f6a76 └── sha256.c8359dfaa6353b1b3166449f7ff3a8ef6f1d3a6c6f837cca9cd2ad7e8ef8546e 2 directories, 5 files\rThe transport archive\u0026rsquo;s contents can be found in artifact-index.json. This file contains the list of component version artifacts to be transported.\njq . transport-archive/artifact-index.json\r{ \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;artifacts\u0026#34;: [ { \u0026#34;repository\u0026#34;: \u0026#34;component-descriptors/github.com/acme.org/helloworld\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:c8359dfaa6353b1b3166449f7ff3a8ef6f1d3a6c6f837cca9cd2ad7e8ef8546e\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34; } ] }\rThe content of the transport archive is stored as OCI artifacts. Notice that the repository name of component version artifacts (found at artifacts.respository) are prefixed by component-descriptors/.\nThe component version is described as an OCI manifest, including OCM specific annotations.\njq . transport-archive/blobs/sha256.c8359dfaa6353b1b3166449f7ff3a8ef6f1d3a6c6f837cca9cd2ad7e8ef8546e\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;artifactType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software/ocm.component.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:096322a7affa6a26a4549e347399f835b2350454946b4967ffdc570dbed78066\u0026#34;, \u0026#34;size\u0026#34;: 201 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:74db132670ec370396ec10160c4e761591d0e9e6c5960c72d2e26c0f9d6f6a76\u0026#34;, \u0026#34;size\u0026#34;: 3072 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;text/plain; charset=utf-8\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8\u0026#34;, \u0026#34;size\u0026#34;: 45, \u0026#34;annotations\u0026#34;: { \u0026#34;software.ocm.artifact\u0026#34;: \u0026#34;[{\\\u0026#34;identity\\\u0026#34;:{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;mylocalfile\\\u0026#34;,\\\u0026#34;version\\\u0026#34;:\\\u0026#34;1.0.0\\\u0026#34;},\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;resource\\\u0026#34;}]\u0026#34; } } ], \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.authors\u0026#34;: \u0026#34;CTF Repository\u0026#34;, \u0026#34;org.opencontainers.image.description\u0026#34;: \u0026#34;\\nThis is an OCM OCI Artifact Manifest that contains the component descriptor for the component github.com/acme.org/helloworld.\\nIt is used to store the component descriptor in an OCI registry and can be referrenced by the official OCM Binding Library.\\n\u0026#34;, \u0026#34;org.opencontainers.image.documentation\u0026#34;: \u0026#34;https://ocm.software\u0026#34;, \u0026#34;org.opencontainers.image.source\u0026#34;: \u0026#34;https://github.com/open-component-model/open-component-model\u0026#34;, \u0026#34;org.opencontainers.image.title\u0026#34;: \u0026#34;OCM Component Descriptor OCI Artifact Manifest for github.com/acme.org/helloworld in version 1.0.0\u0026#34;, \u0026#34;org.opencontainers.image.url\u0026#34;: \u0026#34;https://ocm.software\u0026#34;, \u0026#34;org.opencontainers.image.version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;software.ocm.componentversion\u0026#34;: \u0026#34;component-descriptors/github.com/acme.org/helloworld:1.0.0\u0026#34;, \u0026#34;software.ocm.creator\u0026#34;: \u0026#34;CTF Repository\u0026#34; } }\rNotice that the output of the component version above contains the component descriptor as one of the layers. It can be identified by its media type, which is application/vnd.ocm.software.component-descriptor.v2+yaml+tar. Since it is saved in tar format, it can be displayed using the following command:\ntar xvf transport-archive/blobs/sha256.74db132670ec370396ec10160c4e761591d0e9e6c5960c72d2e26c0f9d6f6a76 -O\rcomponent-descriptor.yaml component: componentReferences: null name: github.com/acme.org/helloworld provider: acme.org repositoryContexts: null resources: - access: localReference: sha256:70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8 mediaType: text/plain; charset=utf-8 type: localBlob/v1 digest: hashAlgorithm: SHA-256 normalisationAlgorithm: genericBlobDigest/v1 value: 70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8 name: mylocalfile relation: local type: blob version: 1.0.0 - access: imageReference: ghcr.io/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb type: ociArtifact digest: hashAlgorithm: SHA-256 normalisationAlgorithm: genericBlobDigest/v1 value: 262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb name: image relation: external type: ociImage version: 1.0.0 sources: null version: 1.0.0 meta: schemaVersion: v2\rThe other elements listed as layers describe the blobs for the local resources stored along with the component version. The digests can be seen in the localReference attributes of the component descriptor.\n","date":"0001-01-01","id":9,"permalink":"/dev/docs/getting-started/create-component-version/","summary":"\u003ch2 id=\"creating-and-storing-component-versions\"\u003eCreating and Storing Component Versions\u003c/h2\u003e\n\u003cp\u003eComponent Versions are created using a \u003ccode\u003ecomponent-constructor.yaml\u003c/code\u003e file, which is a description file that contains one or multiple components. The file describes the components and their artifacts - resources and sources, metadata in form of labels and references to other components.\u003c/p\u003e","tags":[],"title":"Create a Component Version"},{"content":"List Component Versions To show the list of all component versions of a specific component stored in an OCM repository or CTF archive (which technically is also an OCM repository), the [ocm get component-version]/dev/docs/reference/ocm-cli/ocm-get-component-version/ command can be used. Only specify the component name and skip the version.\nIn the example below we use the OCM component ocm.software/toi/demo/helmdemo.\nNotice the format of the specified component which has a prefix defining the OCM repository followed by a double slash // and then the component name.\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo\rCOMPONENT │ VERSION │ PROVIDER ────────────────────────────────┼─────────────┼────────────── ocm.software/toi/demo/helmdemo │ 0.21.0 │ ocm.software │ 0.21.0-rc.1 │ │ 0.20.1 │ │ 0.20.1-rc.1 │ │ 0.20.0 │ │ 0.20.0-rc.1 │ │ 0.19.1 │ ...\rGet Component Versions To see just a specific component version, add a version to the component name:\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.21.0\rCOMPONENT │ VERSION │ PROVIDER ────────────────────────────────┼─────────┼────────────── ocm.software/toi/demo/helmdemo │ 0.21.0 │ ocm.software\rTo get the component descriptor of that component version, use the output format option -o yaml (the output below has been shortened for better readability, digests have been removed and and only the image and chart resources are listed).\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.21.0 -o yaml\rcomponent: componentReferences: - componentName: ocm.software/toi/installers/helminstaller digest: ... name: installer version: 0.21.0 creationTime: \u0026#34;2025-03-06T07:37:08Z\u0026#34; name: ocm.software/toi/demo/helmdemo provider: ocm.software repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: open-component-model/ocm type: OCIRegistry resources: ... - access: imageReference: ghcr.io/open-component-model/ocm/google-containers/echoserver:1.10@sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229 type: ociArtifact digest: ... name: image relation: external type: ociImage version: \u0026#34;1.0\u0026#34; - access: imageReference: ghcr.io/open-component-model/ocm/ocm.software/toi/demo/helmdemo/echoserver:0.1.0@sha256:8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2 type: ociArtifact digest: ... name: chart relation: local type: helmChart version: 0.21.0 ...\rIn the example above, ghcr.io/open-component-model/ocm is the OCM repository, whereas ocm.software/toi/demo/helmdemo is the component stored in this component repository and 0.21.0 the component\u0026rsquo;s version.\nUnder Construction\nThe --recursive option is currently implemented from scratch and not available yet. Stay tuned for updates!\nWith the option --recursive, it is possible to show the complete component version, including the component versions it references.\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.21.0 --recursive\rREFERENCEPATH COMPONENT VERSION PROVIDER IDENTITY ocm.software/toi/demo/helmdemo 0.21.0 ocm.software ocm.software/toi/demo/helmdemo:0.21.0 ocm.software/toi/installers/helminstaller 0.21.0 ocm.software \u0026#34;name\u0026#34;=\u0026#34;installer\u0026#34;\rUnder Construction\nThe -o tree option is currently implemented from scratch and not available yet. Stay tuned for updates!\nTo get a tree view, add the option -o tree:\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.21.0 --recursive -o tree\rNESTING COMPONENT VERSION PROVIDER IDENTITY └─ ⊗ ocm.software/toi/demo/helmdemo 0.21.0 ocm.software └─ ocm.software/toi/installers/helminstaller 0.21.0 ocm.software \u0026#34;name\u0026#34;=\u0026#34;installer\u0026#34;\rAs mentioned before a CTF archive itself is an OCM repository, so we can execute the same commands on a CTF archive. So, let\u0026rsquo;s get the information about the component github.com/acme.org/helloworld we created in the previous step and that we stored in the CTF archive /tmp/helloworld/ctf-hello-world:\nocm get cv /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0\rCOMPONENT │ VERSION │ PROVIDER ────────────────────────────────┼─────────┼────────── github.com/acme.org/helloworld │ 1.0.0 │ acme.org\rList Resources of a Component Version Under Construction\nListing resources and sources most likely will become part of the ocm get cv command and become an additional option. Stay tuned for updates!\nTo list the resources found in a component version tree, the command ocm get resources can be used:\nocm get resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive -o tree\rCOMPONENT NAME VERSION IDENTITY TYPE RELATION └─ ocm.software/toi/demo/helmdemo 0.21.0 ├─ chart 0.21.0 helmChart local ├─ config-example 0.21.0 yaml local ├─ creds-example 0.21.0 yaml local ├─ image 1.0 ociImage external ├─ package 0.21.0 toiPackage local └─ ocm.software/toi/installers/helminstaller installer 0.21.0 ├─ toiexecutor 0.21.0 toiExecutor local └─ toiimage 0.21.0 ociImage local\r","date":"0001-01-01","id":10,"permalink":"/dev/docs/getting-started/ocm-cli/display-and-examine-component-versions/","summary":"\u003ch2 id=\"list-component-versions\"\u003eList Component Versions\u003c/h2\u003e\n\u003cp\u003eTo show the list of all component versions of a specific component stored in an OCM repository or CTF archive (which technically is also an OCM repository), the [\u003ccode\u003eocm get component-version\u003c/code\u003e]/dev/docs/reference/ocm-cli/ocm-get-component-version/ command can be used. Only specify the component name and skip the version.\u003c/p\u003e","tags":[],"title":"Display and Examine Component Versions"},{"content":"Download Resources of a Component Version Use the ocm download resources command to download specific resources from a component version. In this example we download the resource with name chart from the example component used in the last chapter and save it as local file:\nocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.21.0 --identity name=chart --output helmchart.tgz\r... time=2025-08-14T13:03:54.372+02:00 level=INFO msg=\u0026#34;resource downloaded successfully\u0026#34; output=helmchart.tgz\rBecause it is stored as OCI artifact in an OCI registry, the filesystem format used for OCI artifacts is the blob format.\nWhat happened? The file helmchart.tgz was downloaded.\ntar xvf helmchart.tgz\rblobs/sha256/ea8e5b44cd1aff1f3d9377d169ad795be20fbfcd58475a62341ed8fb74d4788c blobs/sha256/8702d8d550075e410f3aae545d1191df9e5ab8747e5c5a8eda5ed834fd135366 blobs/sha256/8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2 index.json oci-layout\rUnder Construction\nThe file permissions and ownership may not be preserved when extracting the archive. This needs to be fixed. Currently you have to add at least read permissions to continue: chmod +r index.json\njq . index.json\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2\u0026#34;, \u0026#34;size\u0026#34;: 410, \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.ref.name\u0026#34;: \u0026#34;ghcr.io/open-component-model/ocm/ocm.software/toi/demo/helmdemo/echoserver:0.1.0@sha256:8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2\u0026#34; } } ] }\rDownload using Transformers Under Construction\nTransformers are currently in development. We\u0026rsquo;ll extend the below section once they are ready to be used. Until then you can check out the Transformer ADR\nTo use a format more suitable for the content technology, you can use the --transformer to specify a transformer. The transformer will take care that the file will be saved using its correct media type, e.g. a Helm charts will be saved as .tgz file which on extraction will show the complete chart.\nocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 chart --identity name=chart --output helmchart.tgz --transformer helm\rhelmchart.tgz: 3763 byte(s) written\rWhat happened? The downloaded archive is now a regular Helm Chart archive:\ntar tvf helmchart.tgz\r-rw-r--r-- 0 0 0 136 Jul 19 16:32 echoserver/Chart.yaml -rw-r--r-- 0 0 0 1842 Jul 19 16:32 echoserver/values.yaml -rw-r--r-- 0 0 0 1755 Jul 19 16:32 echoserver/templates/NOTES.txt -rw-r--r-- 0 0 0 1802 Jul 19 16:32 echoserver/templates/_helpers.tpl -rw-r--r-- 0 0 0 1848 Jul 19 16:32 echoserver/templates/deployment.yaml -rw-r--r-- 0 0 0 922 Jul 19 16:32 echoserver/templates/hpa.yaml -rw-r--r-- 0 0 0 2083 Jul 19 16:32 echoserver/templates/ingress.yaml -rw-r--r-- 0 0 0 367 Jul 19 16:32 echoserver/templates/service.yaml -rw-r--r-- 0 0 0 324 Jul 19 16:32 echoserver/templates/serviceaccount.yaml -rw-r--r-- 0 0 0 385 Jul 19 16:32 echoserver/templates/tests/test-connection.yaml -rw-r--r-- 0 0 0 349 Jul 19 16:32 echoserver/.helmignore\r","date":"0001-01-01","id":11,"permalink":"/dev/docs/getting-started/ocm-cli/download-resources-from-component-versions/","summary":"\u003ch2 id=\"download-resources-of-a-component-version\"\u003eDownload Resources of a Component Version\u003c/h2\u003e\n\u003cp\u003eUse the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-resource/\"\u003e\u003ccode\u003eocm download resources\u003c/code\u003e\u003c/a\u003e command to download specific resources from a component version. In this example we download the resource with name \u003ccode\u003echart\u003c/code\u003e from the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/ocm-cli/display-and-examine-component-versions/#get-and-examine-component-versions\"\u003eexample component used in the last chapter\u003c/a\u003e and save it as local file:\u003c/p\u003e","tags":[],"title":"Download Resources from Component Versions"},{"content":"The following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\nThe component is publicly available in the GitHub container registry and can be inspected using the following command:\nocm componentversion get --repo ghcr.io/phoban01/ocm github.com/weaveworks/weave-gitops -oyaml\rmeta: # component schema version schemaVersion: v2 component: # name of the component. Must start with URL-prefix that should be controlled # by the owner of the component to avoid collisions # regex: ^[a-z][-a-z0-9]*([.][a-z][-a-z0-9]*)*[.][a-z]{2,}(/[a-z][-a-z0-9_]*([.][a-z][-a-z0-9_]*)*)+$ name: github.com/weaveworks/weave-gitops # version of the component. Must adhere to “relaxed SemVer” # major, minor (+ optional patch level) - optional v-prefix # regex: ^[v]?(0|[1-9]\\\\d*)(?:\\\\.(0|[1-9]\\\\d*))?(?:\\\\.(0|[1-9]\\\\d*))?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$ version: v1.0.0 # component provider provider: weaveworks # list of labels that can contain arbitrary metadata in form of K/V pairs # labels can be added on component root, resource, source and reference level labels: - name: link-to-documentation value: https://github.com/weaveworks/weave-gitops # list of repository context the component version \u0026#34;lived\u0026#34; in, # with the current one at the top repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: phoban01/ocm type: OCIRegistry # list of resources that describe the payload of the component resources: # resource name - name: image # resource location (external repository or internal to this repository) relation: external # resource type type: ociImage # resource version. Must also adhere to “relaxed SemVer” (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the resource access: # type of access information type: ociArtifact imageReference: ghcr.io/weaveworks/wego-app:v0.14.1 # signing metadata for the resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: ociArtifactDigest/v1 value: efa2b9980ca2de65dc5a0c8cc05638b1a4b4ce8f6972dc08d0e805e5563ba5bb # list of sources that describe the input for creating the resources sources: # source name - name: weave-gitops # source type type: git # source version. Must also adhere to “relaxed SemVer” (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the source access: commit: 727513969553bfcc603e1c0ae1a75d79e4132b58 ref: refs/tags/v0.14.1 repoUrl: github.com/weaveworks/weave-gitops type: gitHub # list of references to other components componentReferences: # reference name - name: prometheus # reference version version: v1.0.0 # referenced component name componentName: cncf.io/prometheus # signing metadata for the referenced resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 04eb20b6fd942860325caf7f4415d1acf287a1aabd9e4827719328ba25d6f801 # list of signatures used for signing and verification signatures: # name of the signature - name: ww-dev # digest of the signature including the algorithm used digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 4faff7822616305ecd09284d7c3e74a64f2269dcc524a9cdf0db4b592b8cee6a # signature including the algorithm used signature: algorithm: RSASSA-PSS mediaType: application/vnd.ocm.signature.rsa value: 26468587671bdbd2166cf5f69829f090c10768511b15e804294fcb26e552654316c8f4851ed396f279ec99335e5f4b11cb043feb97f1f9a42115f4fda2d31ae8b481b7303b9a913d3a4b92d446fbee9ed487c93b09e513f3f68355040ec08454675e1f407422062abbd2681f70dd5488ad29020b30cfa7e001455c550458da96166bc3243c8426977d73352aface5323fb2b5a374e9c31b272a59c160b85631231c9fc2f23c032401b80fef937029a39111cee34470c61ae86cd4942553466411a5a116159fdcc10e50fe9360c5184028e72d1fe9c7315f26e15d7b4849f62d197501b8cc6b6f1b1391ecc2fc2fc0c1290d2554594505b25fa8f9bfb28c8df24\r","date":"0001-01-01","id":12,"permalink":"/dev/docs/getting-started/component-descriptor-example/","summary":"\u003cp\u003eThe following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\u003c/p\u003e\n\u003cp\u003eThe component is publicly available in the GitHub container registry and can be inspected using the following command:\u003c/p\u003e","tags":[],"title":"Example of a Component Descriptor"},{"content":"","date":"0001-01-01","id":13,"permalink":"/dev/docs/getting-started/ocm-controllers/","summary":"","tags":[],"title":"OCM Controllers"},{"content":"\rThis project is in early development and not yet ready for production use.\nThe OCM Controller\nsupports the deployment of an OCM component and its resources, like Helm charts or other manifests, into a Kubernetes cluster with the help of kro and a deployer, e.g. FluxCD. provides a controller to transfer OCM components. What should I know before I start? You should be familiar with the following concepts:\nOpen Component Model Kubernetes ecosystem kro Kubernetes resource deployer such as FluxCD. Concept The following section provides a high-level overview of the OCM Controllers and their components regarding the deployment of an OCM resource in a very basic scenario. To learn more about the transfer of OCM component versions, please take a look at its architecture document.\nThe primary purpose of OCM Controllers is simple: Deploy an OCM resource from an OCM component version into a Kubernetes cluster.\nThe implementation, however, is a bit more complex as deployments must be secure and configurable. Additionally, an OCM Resource can, in theory, contain any form of deployable resource, for instance a Helm chart, a Kustomization, or plain Kubernetes manifests. Each of these resources has its own way of being deployed or configured. So, instead of creating a generic deployer that offers all these functionalities, we decided to use existing tools that are already available in the Kubernetes ecosystem.\nThe following diagram describes a basic scenario in which an OCM resource containing a Helm chart is deployed into a Kubernetes cluster using the OCM Controllers as well as kro and FluxCD. kro is used to orchestrate the deployment and to transport information about the location of the OCM resource to FluxCD. FluxCD takes the location of the OCM resource, downloads the chart, configures it if necessary, and deploys it into the Kubernetes cluster.\nflowchart TB classDef cluster fill:white,color:black,stroke:black; classDef reconciledBy fill:#dedede,stroke:black,stroke-dasharray: 5,color:black; classDef k8sObject fill:#b3b3b3,color:black,stroke:black; classDef information fill:#b3b3b3,color:black,stroke:black,stroke-dasharray: 2; classDef ocm fill:white,stroke:black,color:black; classDef legendStyle fill:white,stroke:black,color:black,stroke-dasharray: 2; classDef legendStartEnd height:0px; classDef legendItems fill:#b3b3b3,stroke:none,color:black; subgraph legend[Legend] start1[ ] ---references[referenced by] --\u0026gt; end1[ ] start2[ ] -.-creates -.-\u0026gt; end2[ ] start3[ ] ---instanceOf[instance of] --\u0026gt; end3[ ] start4[ ] ~~~reconciledBy[reconciled by] ~~~ end4[ ] start5[ ] ~~~k8sObject[k8s object] ~~~ end5[ ] start6[ ] ~~~templateOf[template of] ~~~ end6[ ] end subgraph background[ ] direction TB subgraph ocmRepo[OCM Repository] subgraph ocmCV[OCM Component Version] subgraph ocmResource[OCM Resource: HelmChart] end end end subgraph k8sCluster[Kubernetes Cluster] subgraph kroRGD[kro] subgraph rgd[RGD: Simple] direction LR rgdRepository[Repository] rgdComponent[Component] rgdResourceHelm[Resource: HelmChart] rgdSource[FluxCD: OCI Repository] rgdHelmRelease[FluxCD: HelmRelease] end end subgraph kroInstance[kro] subgraph instanceSimple[Instance: Simple] subgraph ocmControllers[OCM Controllers] k8sRepo[Repository] --\u0026gt; k8sComponent[Component] --\u0026gt; k8sResource[Resource: HelmChart] end subgraph fluxCD[FluxCD] source[OCI Repository] --\u0026gt; helmRelease[HelmRelease] end k8sResource --\u0026gt; source end end kroRGD \u0026amp; instanceSimple --\u0026gt; crdSimple[CRD: Simple] helmRelease --\u0026gt; deployment[Deployment: Helm chart] end ocmRepo --\u0026gt; k8sRepo end linkStyle default fill:none,stroke:black; linkStyle 2,3,16,18 stroke:black,stroke-dasharray: 10; linkStyle 4,5,17 stroke:black,stroke-dasharray: 4; class start1,end1,start2,end2,start3,end3,start4,end4,start5,end5,start6,end6 legendStartEnd; class references,creates,instanceOf legendItems; class templateOf,rgdRepository,rgdComponent,rgdResourceHelm,rgdSource,rgdHelmRelease information; class reconciledBy,ocmK8sToolkit,fluxCD,kroRGD,kroInstance reconciledBy; class k8sObject,rgd,k8sRepo,k8sComponent,k8sResource,source,helmRelease,deployment,crdSimple,instanceSimple k8sObject; class ocmRepo,ocmCV,ocmResource ocm; class k8sCluster cluster; class legend legendStyle; The above diagram shows an OCM resource of type helmChart. This resource is part of an OCM component version, which is located in an OCM repository.\nIn the Kubernetes Cluster we can see several Kubernetes (custom) resources. The ResourceGraphDefintion (RGD: Simple) contains the template of all the resources for deploying the Helm chart into the Kubernetes cluster. kro creates a Custom Resource Definition (CRD) Simple based on that ResourceGraphDefinition. By creating an instance of this CRD (Instance: Simple), the resources are created and reconciled by the respective controllers:\nRepository: Points to the OCM repository and checks if it is reachable by pinging it. Component: Refers to the Repository and downloads and verifies the OCM component version descriptor. Resource: Points to the Component, downloads the OCM component version descriptor from which it gets the location of the OCM resource. It then downloads the resource to verify its signature (optional) and publishes the location of the resource in its status. With FluxCD, this only works if the OCM resource has an access for which FluxCD has a corresponding Source type (e.g. an OCI or a GitHub repository)\nAs a result, FluxCD can now consume the information of the Resource and deploy the Helm chart:\nOCIRepository: Watches and downloads the resource from the location provided by the Resource status. HelmRelease: Refers to the OCIRepository, lets you configure the Helm chart, and creates the deployment into the Kubernetes cluster. Installation Currently, the OCM Controllers are available as image and Kustomization. A Helm chart is planned for the future.\nTo install the OCM Controllers into your running Kubernetes cluster, you can use the following commands:\n# In the open-component-model repository, folder kubernetes/controller task deploy or\nkubectl apply -k https://github.com/open-component-model/open-component-model/kubernetes/controller/config/default?ref=main While the OCM Controllers technically can be used standalone, it requires kro and a deployer, e.g. FluxCD, to deploy an OCM resource into a Kubernetes cluster. The OCM Controllers deployment, however, does not contain kro or any deployer. Please refer to the respective installation guides for these tools:\nkro FluxCD Getting Started Setup your (test) environment with kind, kro, and FluxCD Deploying a Helm chart using a ResourceGraphDefinition with FluxCD Deploying a Helm chart using a ResourceGraphDefinition inside the OCM component version (bootstrap) with FluxCD Configuring credentials for OCM Controllers resources to access private OCM repositories ","date":"0001-01-01","id":14,"permalink":"/dev/docs/getting-started/ocm-controllers/introduction/","summary":"\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \r\n    \u003cdiv class=\"callout-body\"\u003e\r\n      \u003cp\u003eThis project is in early development and not yet ready for production use.\u003c/p\u003e","tags":[],"title":"Introduction"},{"content":"This document describes how to set up a local environment for testing and running examples from the examples/ directory or the getting-started guides.\nPrerequisites kubectl ocm CLI (will not be used in this guide, but is required to follow the examples and getting-started guides) Start a local Kubernetes cluster with kind You don\u0026rsquo;t need to run kind if you are using a remote Kubernetes cluster you have access to. If so, you can skip this.\nFor download and installation instructions, see the kind documentation.\nTo create a local kind cluster run the following command:\nkind create cluster\rInstall kro Please follow the official installation guides for kro. You might need helm to install kro.\nIf kro is installed correctly, you should see some similar output when running the following command:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h28m ... Install a deployer Currently, we created our examples and getting-started guides using FluxCD as deployer. But, in theory, you could use any other deployer that is able to apply a deployable resource to a Kubernetes cluster, for instance ArgoCD.\nTo install FluxCD, please follow the official installation guide. After you installed the cli tool, you can run the following command to install the FluxCD controllers:\nflux install\rIf the FluxCD controllers are installed correctly, you should see some similar output when running the following command:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... flux-system helm-controller-b6767d66-zbwws 1/1 Running 0 3h29m flux-system kustomize-controller-57c7ff5596-v6fvr 1/1 Running 0 3h29m flux-system notification-controller-58ffd586f7-pr65t 1/1 Running 0 3h29m flux-system source-controller-6ff87cb475-2h2lv 1/1 Running 0 3h29m ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h28m ... Install the OCM Controllers To install the OCM Controllers, you can use one of the following commands:\n# In the open-component-model repository, folder kubernetes/controller task deploy\ror\nkubectl apply -k https://github.com/open-component-model/open-component-model/kubernetes/controller/config/default?ref=main\rIf the OCM Controllers are installed correctly, you should see some similar output when running the following command:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... flux-system helm-controller-b6767d66-zbwws 1/1 Running 0 3h39m flux-system kustomize-controller-57c7ff5596-v6fvr 1/1 Running 0 3h39m flux-system notification-controller-58ffd586f7-pr65t 1/1 Running 0 3h39m flux-system source-controller-6ff87cb475-2h2lv 1/1 Running 0 3h39m ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h38m ... ocm-k8s-toolkit-system ocm-k8s-toolkit-controller-manager-788f58d4bd-ntbx8 1/1 Running 0 57s ... Access to a registry As all examples and guides will create an OCM component version that will be consumed by the OCM Controllers, you will need access to a registry. You can either choose a public registry like ghcr.io or deploy a registry (like registry, zot, \u0026hellip;) into your Kubernetes cluster.\nIf you choose to deploy a registry into your Kubernetes cluster, you have to make sure it is accessible from outside the cluster (for ocm transfer to work) and inside the cluster (for the OCM Controllers to work).\nWe strongly recommend to use a registry that is publicly accessible, like [ghcr.io][ghcr.io]. (Deploying your own registry requires a lot of additional configuration. Especially, if you want to try out the localization example, you will need to configure a registry that is accessible with the same address from your CLI, kubelet, and inside the cluster.)\nIf you completed all of the above steps, you are ready to go. You can now play around with the examples in the examples/ directory or follow the Getting Started Guides.\n","date":"0001-01-01","id":15,"permalink":"/dev/docs/getting-started/ocm-controllers/set-up-your-environment/","summary":"\u003cp\u003eThis document describes how to set up a local environment for testing and running examples from the \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/open-component-model/tree/main/kubernetes/controller/examples\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eexamples/\u003c/code\u003e\u003c/a\u003e directory or the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"https://ocm.software/dev/docs/getting-started/ocm-controllers/\"\u003egetting-started guides\u003c/a\u003e.\u003c/p\u003e","tags":[],"title":"Set up your environment"},{"content":"This guide demonstrates how to deploy a Helm Chart from an OCM component version using OCM Controllers, kro, and FluxCD. It is a rather basic example, in which it is assumed that a developer created an application, packaged it as a Helm chart, and publishes it as OCM component version in an OCI registry. Then, an operator who wants to deploy the application via Helm chart in a Kubernetes cluster, creates a ResourceGraphDefinition with resources that point to this OCM component version. Using CEL expressions inside the ResourceGraphDefinition, the information about the resource location will be passed to FluxCD, which will then configure the Helm chart and deploy it into the Kubernetes cluster.\nBefore starting, make sure you have set up your environment as described in the setup guide.\nCreate the OCM component version First, we will create an OCM component version containing a Helm chart. For this example, we will use the podinfo Helm chart, which is a simple web application that serves a pod information page. For more details on how to create an OCM component version, please refer to the OCM documentation.\nTo create the OCM component version, we will use the following component-constructor.yaml file:\ncomponents: - name: ocm.software/ocm-k8s-toolkit/simple provider: name: ocm.software version: \u0026#34;1.0.0\u0026#34; resources: - name: helm-resource type: helmChart version: 1.0.0 access: type: ociArtifact imageReference: \u0026#34;ghcr.io/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a\u0026#34;\rAfter creating the file, we can create the OCM component version:\nocm add componentversion --create --file ./ctf component-constructor.yaml\rThis will create a local CTF (Component Transfer Format) directory ./ctf containing the OCM component version. Since the OCM component version must be accessible for the OCM Controllers, we will transfer the CTF to a registry. For this example, we will use GitHub\u0026rsquo;s container registry, but you can use any OCI registry:\nocm transfer ctf ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rIf you are using a registry that requires authentication, you need to provide credentials for ocm. Please refer to the [OCM CLI credentials documentation][ocm-credentials] for more information on how to set up and use credentials.\nIf everything went well, you should see the following output:\nocm get componentversion ghcr.io/\u0026lt;your-namespace\u0026gt;//ocm.software/ocm-k8s-toolkit/simple:1.0.0\rCOMPONENT VERSION PROVIDER ocm.software/ocm-k8s-toolkit/simple 1.0.0 ocm.software Deploy the Helm Chart To deploy the Helm chart from the OCM component version, we will first create a ResourceGraphDefinition that contains all required resources. Additionally, we will add a configuration to the HelmRelease resource that can be passed through the instance of that ResourceGraphDefinition. After the ResourceGraphDefinition is created and applied, we create the instance of the ResourceGraphDefinition that will deploy the Helm chart.\nCreate and apply the ResourceGraphDefinition The ResourceGraphDefinition is a custom resource that defines all the resources that should be applied. To proceed with the example, create a file named rgd.yaml and add the following content:\napiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: simple spec: schema: apiVersion: v1alpha1 # The name of the CRD that is created by this ResourceGraphDefinition when applied kind: Simple spec: # This spec defines values that can be referenced in the ResourceGraphDefinition and that can be set in the # instances of this ResourceGraphDefinition. # We will use it to pass a value to the Helm chart and configure the message the application shows # (see resource HelmRelease). message: string | default=\u0026#34;foo\u0026#34; resources: # Repository points to the OCM repository in which the OCM component version is stored and checks if it is # reachable by pinging it. - id: repository template: apiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: simple-repository spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # Component refers to the Repository, downloads and verifies the OCM component version descriptor. - id: component template: apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: simple-component spec: repositoryRef: name: ${repository.metadata.name} component: ocm.software/ocm-k8s-toolkit/simple semver: 1.0.0 interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # Resource points to the Component, downloads the resource passed by reference-name and verifies it. It then # publishes the location of the resource in its status. - id: resourceChart template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: simple-resource spec: componentRef: name: ${component.metadata.name} resource: byReference: resource: name: helm-resource # This must match the resource name set in the OCM component version (see above) interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # OCIRepository watches and downloads the resource from the location provided by the Resource status. # The Helm chart location (url) refers to the status of the above resource. - id: ocirepository template: apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: simple-ocirepository spec: interval: 1m0s layerSelector: mediaType: \u0026#34;application/vnd.cncf.helm.chart.content.v1.tar+gzip\u0026#34; operation: copy url: oci://${resourceChart.status.reference.registry}/${resourceChart.status.reference.repository} ref: tag: ${resourceChart.status.reference.tag} # secretRef is required, if the OCI repository requires credentials to access it. # secretRef: # HelmRelease refers to the OCIRepository, lets you configure the helm chart and deploys the Helm Chart into the # Kubernetes cluster. - id: helmrelease template: apiVersion: helm.toolkit.fluxcd.io/v2 kind: HelmRelease metadata: name: simple-helmrelease spec: releaseName: simple interval: 1m timeout: 5m chartRef: kind: OCIRepository name: ${ocirepository.metadata.name} namespace: default values: # We configure the Helm chart using FluxCDs HelmRelease \u0026#39;values\u0026#39; field. We pass the value that we set in # the instance of the CRD created by the ResourceGraphDefinition (see below). ui: message: ${schema.spec.message}\rIf you pushed the OCM component version to a private registry, you need to set up the credentials for the OCM Controller resources. You can do this by uncommenting the ocmConfig fields in the Repository, Component, and Resource resources and providing the necessary credentials. For more information on how to set up and pass the credentials, please check out the guide configure credentials for OCM Controller resources.\nBe aware that FluxCD\u0026rsquo;s OCIRepository also needs access to the OCI registry that contains the Helm chart. However, OCIRepository only accepts imagePullSecrets in the same namespace. If you want to use the same credentials for FluxCD and for the OCM Controller resources, create a Kubernetes secret of type dockerconfigjson and keep all the resources in the same namespace.\nAfter creating the file rgd.yaml with the above content and adjusting Repository\u0026rsquo;s baseUrl to point to your OCM repository, you can apply the ResourceGraphDefinition to your Kubernetes cluster:\nkubectl apply -f rgd.yaml\rIf everything went well, you should see the following output:\nkubectl get rgd\rNAME APIVERSION KIND STATE AGE simple v1alpha1 Simple Active 19s This creates a Kubernetes Custom Resource Definition (CRD) Simple that can be used to create instances. An applied instance of the CRD will create all resources defined in the ResourceGraphDefinition.\nCreate an Instance of \u0026ldquo;Simple\u0026rdquo; To create an instance of the Simple CRD, create a file named instance.yaml and add the following content:\napiVersion: kro.run/v1alpha1 # Kind is the CRD name that was created by the ResourceGraphDefinition kind: Simple metadata: name: simple spec: # This field is passed to the Helm chart and configures the message that podinfo will show message: \u0026#34;bar\u0026#34;\rProceed by applying the instance which will create all the resources defined in the ResourceGraphDefinition:\nkubectl apply -f instance.yaml\rThis will take some time, but if everything went well, you should see the following output:\nkubectl get simple\rNAME STATE SYNCED AGE simple ACTIVE True 5m28s and the deployment should be in the state Available:\nkubectl get deployments\rNAME READY UP-TO-DATE AVAILABLE AGE simple-podinfo 1/1 1 1 40m To make sure that the deployment was configured successfully, take a look at the pod itself or execute the following command:\nkubectl get pods -l app.kubernetes.io/name=simple-podinfo -o jsonpath=\u0026#39;{.items[0].spec.containers[0].env[?(@.name==\u0026#34;PODINFO_UI_MESSAGE\u0026#34;)].value}\u0026#39;\rwhich should return the value you passed in the instance:\nbar You now have successfully created an OCM component version containing a Helm chart and deployed as well as configured it using the OCM Controllers, kro, and FluxCD.\nTroubleshooting One common issue, when using GitHub\u0026rsquo;s container registry, is that the transferred OCM component is by default a private package. If so, you might see an error like the following:\nfailed to list versions: failed to list tags: GET \u0026#34;https://ghcr.io/v2...\u0026#34;: response status code 401: unauthorized: authentication required You can resolve this issue by making the package public or by providing credentials to the respective resources.\n","date":"0001-01-01","id":16,"permalink":"/dev/docs/getting-started/ocm-controllers/deploying-a-helm-chart/","summary":"\u003cp\u003eThis guide demonstrates how to deploy a Helm Chart from an OCM component version using OCM Controllers, kro, and FluxCD.\nIt is a rather basic example, in which it is assumed that a developer created an application, packaged it as a Helm\nchart, and publishes it as OCM component version in an OCI registry. Then, an operator who wants to deploy the\napplication via Helm chart in a Kubernetes cluster, creates a \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e with resources that point to\nthis OCM component version. Using CEL expressions inside the \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e, the information about the\nresource location will be passed to FluxCD, which will then configure the Helm chart and deploy it into the Kubernetes\ncluster.\u003c/p\u003e","tags":[],"title":"Deploying a Helm Chart"},{"content":"The concept and the previous guide showed a basic example of how to deploy a Helm chart from an OCM component. By defining a ResourceGraphDefinition that contains the all the required resources to deploy the Helm chart into a Kubernetes cluster.\nHowever, there are scenarios, where the developer already knows how the deployment instructions for the Helm chart should look like and what should be configured. Accordingly, the developer can create a ResourceGraphDefinition that contains all the required resources to deploy and configure the Helm chart, and deliver it with the OCM component version itself. This way, the deployment instructions can also be delivered securely through OCM and the operator does not need to know which resources are required.\nIn such a case, we need to bootstrap the ResourceGraphDefinition from the OCM component and apply it to the cluster.\nTo do so, we use the OCM Controller resource Deployer. By referencing the Resource containing the ResourceGraphDefinition by name, the deployer will download the content from the OCM component and apply it to the cluster.\nThe following guide demonstrates how to deploy a Helm chart using a ResourceGraphDefinition that is also delivered with the same OCM component. Additionally, it shows how to localize a Helm chart.\nLocalization describes the process of inserting a new image reference into the deployment instructions, e.g. a Helm chart. It is a two-step process:\nWhen an OCM component and its resources are transferred to another registry, referential resources can potentially update their reference to the new location. For instance, a resource with an access type ociArtifact will update its image reference in the component descriptor to the new registry location, if the OCM transfer is done with the flag --copy-resources. However, the deployment using the image is not aware of this change. Accordingly, we need to insert the new image reference into the deployment instruction. This can be done using deployment tools like FluxCDs HelmRelease and Kustomization or ArgoCDs Helm and Kustomize. The following diagram shows an overview of the resources and their relationships of this guide:\nflowchart TB classDef cluster fill:white,color:black,stroke:black; classDef reconciledBy fill:#dedede,stroke:black,stroke-dasharray: 5,color:black; classDef k8sObject fill:#b3b3b3,color:black,stroke:black; classDef information fill:#b3b3b3,color:black,stroke:none; classDef templateOf fill:#b3b3b3,color:black,stroke:black,stroke-dasharray: 2; classDef ocm fill:white,stroke:black,color:black; classDef legendStyle fill:white,stroke:black,color:black,stroke-dasharray: 2; classDef legendStartEnd height:0px; classDef legendItems fill:#b3b3b3,stroke:none,color:black; subgraph legend[Legend] start1[ ] ---references[referenced by] --\u0026gt; end1[ ] start2[ ] -.-creates -.-\u0026gt; end2[ ] start3[ ] ---instanceOf[instance of] --\u0026gt; end3[ ] start4[ ] ~~~reconciledBy[reconciled by] ~~~ end4[ ] start5[ ] ~~~k8sObject[k8s object] ~~~ end5[ ] start6[ ] ~~~templateOf[template of] ~~~ end6[ ] end subgraph background[ ] direction TB subgraph ocmRepo[OCM Repository] subgraph ocmCV[OCM Component Version] direction RL subgraph ocmResourceHelm[OCM Resource: HelmChart] end subgraph ocmResourceImage[OCM Resource: Image] end subgraph ocmResourceRGD[OCM Resource: RGD] end end end subgraph k8sCluster[Kubernetes Cluster] subgraph bootstrap[OCM Controllers] k8sRepo[OCMRepository] k8sComponent[Component] k8sResourceRGD[Resource: RGD] k8sDeployer[Deployer] end subgraph kro[kro] subgraph rgd[RGD: Bootstrap] rgdResourceHelm[Resource: HelmChart] rgdResourceImage[Resource: Image] rgdSource[FluxCD: OCI Repository] rgdHelmRelease[FluxCD: HelmRelease] end crdBootstrap[CRD: Bootstrap] subgraph instanceBootstrap[Instance: Bootstrap] subgraph ocmControllers[OCM Controllers] k8sResourceHelm[Resource: HelmChart] k8sResourceImage[Resource: Image] end subgraph fluxCD[FluxCD] source[OCI Repository] helmRelease[HelmRelease] end k8sResourceImage ---info[localization reference] --\u0026gt; helmRelease end end helmRelease --\u0026gt; deployment[Deployment: Helm chart] end ocmRepo --\u0026gt; k8sRepo --\u0026gt; k8sComponent --\u0026gt; k8sResourceRGD --\u0026gt; k8sDeployer --\u0026gt; rgd --\u0026gt; crdBootstrap --\u0026gt; instanceBootstrap k8sComponent --\u0026gt; k8sResourceHelm \u0026amp; k8sResourceImage k8sResourceHelm --\u0026gt; source --\u0026gt; helmRelease end linkStyle default fill:none,stroke:black,color:black; linkStyle 2,3,20 stroke:black,fill:none,color:black,stroke-dasharray: 10; linkStyle 4,5,21 stroke:black,fill:none,color:black,stroke-dasharray: 4; class start1,end1,start2,end2,start3,end3,start4,end4,start5,end5,start6,end6 legendStartEnd; class references,creates,instanceOf legendItems; class templateOf,rgdResourceHelm,rgdResourceImage,rgdSource,rgdHelmRelease templateOf; class info information; class reconciledBy,ocmK8sToolkit,bootstrap,fluxCD,kro reconciledBy; class k8sObject,rgd,k8sRepo,k8sComponent,k8sResourceRGD,k8sDeployer,k8sResourceHelm,k8sResourceImage,source,helmRelease,deployment,crdBootstrap,instanceBootstrap k8sObject; class ocmRepo,ocmCV,ocmResourceHelm,ocmResourceRGD,ocmResourceImage ocm; class k8sCluster cluster; class legend legendStyle; As the diagram shows, we will start by creating an OCM component that contains three resources:\nAn OCM Resource containing the \u0026ldquo;HelmChart\u0026rdquo; we want to deploy. An OCM Resource containing an access specification to an \u0026ldquo;Image\u0026rdquo; we want to use for the deployment and localization. An OCM Resource containing the ResourceGraphDefinition (RGD) that will deploy the Helm chart and configure the localization. To enable the bootstrap of the ResourceGraphDefinition, we will create the respective OCM Controller resources that point to the OCM repository (\u0026ldquo;Repository\u0026rdquo;), the OCM component version (\u0026ldquo;Component\u0026rdquo;), and the OCM Resource (\u0026ldquo;Resource: RGD\u0026rdquo;) that contains the ResourceGraphDefinition. The OCM Controller resource \u0026ldquo;Deployer\u0026rdquo; will refer to the aforementioned \u0026ldquo;Resource: RGD\u0026rdquo;, download the ResourceGraphDefinition, and apply it to the cluster.\nAfter applying the ResourceGraphDefinition, kro will reconcile it and create a Custom Resource Definition (\u0026ldquo;CRD: Bootstrap\u0026rdquo;). By creating an instance of that CRD, we will deploy the resources as defined in the ResourceGraphDefinition:\nAn OCM Controller resource \u0026ldquo;HelmChart\u0026rdquo; of type Resource that contains the location of the Helm chart in its status. An OCM Controller resource \u0026ldquo;Image\u0026rdquo; of type Resource that contains the localized image reference in its status. A FluxCD resource of type OCIRepository that points to the location of the Helm chart retrieved from the status of the resource \u0026ldquo;HelmChart\u0026rdquo;. A FluxCD resource of type HelmRelease that points to FluxCDs OCIRepository, gets the Helm chart, and replaces the image location in the deployment using its spec.values-field and the status of the resource \u0026ldquo;Image\u0026rdquo; that contains the localized image reference. Finally, we will check if the deployment was successful and if the localization was applied correctly.\nBefore starting, make sure you have set up your environment as described in the setup guide.\nCreate the OCM component version First, we will create an OCM component version containing a Helm chart, the application image that is used in the Helm chart, and the ResourceGraphDefinition that contains all required resource to deploy the Helm chart and configure the localization. For this example, we will use the podinfo Helm chart and image, which is a simple web application that serves a pod information page. For more details on how to create an OCM component version, please refer to the OCM documentation.\nTo create the OCM component version, we will use the following component-constructor.yaml file:\ncomponents: - name: ocm.software/ocm-k8s-toolkit/bootstrap version: \u0026#34;1.0.0\u0026#34; provider: name: ocm.software resources: - name: helm-resource type: helmChart version: \u0026#34;1.0.0\u0026#34; access: type: ociArtifact imageReference: \u0026#34;ghcr.io/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a\u0026#34; - name: image-resource type: ociArtifact version: \u0026#34;1.0.0\u0026#34; access: type: ociRegistry imageReference: \u0026#34;ghcr.io/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb\u0026#34; - name: resource-graph-definition type: blob version: \u0026#34;1.0.0\u0026#34; input: type: file path: ./resourceGraphDefinition.yaml\rAs you can see, the resource resource-graph-definition is of type blob and contains the path to a file resourceGraphDefinition.yaml. Before we can create the OCM component version, we need to create this file, with the following content:\napiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: bootstrap spec: schema: apiVersion: v1alpha1 kind: Bootstrap resources: # In this guide, we will not create a \u0026#34;Repository\u0026#34; and \u0026#34;Component\u0026#34; resource in this ResourceGraphDefinition. Those # resources will be created to bootstrap the ResourceGraphDefinition itself and will be present in the Kubernetes # cluster to be referenced by the following resources (see the bootstrap resource in one of the following sections). # This resource refers to the resource \u0026#34;helm-resource\u0026#34; defined in the OCM component version. It will be downloaded, # verified, and its location is made available in the status of the resource. - id: resourceChart template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-helm-resource spec: # This component will be part of the bootstrap resources that will be created later. componentRef: name: bootstrap-component resource: byReference: resource: name: helm-resource interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # This resource refers to the resource \u0026#34;image-resource\u0026#34; defined in the OCM component version. It will be downloaded, # verified, and its location is made available in the status of the resource. - id: resourceImage template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-image-resource spec: # This component will be part of the bootstrap resources that will be created later. componentRef: name: bootstrap-component resource: byReference: resource: name: image-resource interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # OCIRepository watches and downloads the resource from the location provided by the Resource status. # The Helm chart location (url) refers to the status of the resource helm-resource. - id: ocirepository template: apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: bootstrap-ocirepository spec: interval: 1m0s insecure: true layerSelector: mediaType: \u0026#34;application/vnd.cncf.helm.chart.content.v1.tar+gzip\u0026#34; operation: copy url: oci://${resourceChart.status.reference.registry}/${resourceChart.status.reference.repository} ref: tag: ${resourceChart.status.reference.tag} # secretRef is required, if the OCI repository requires credentials to access it. # secretRef: # HelmRelease refers to the OCIRepository, lets you configure the helm chart and deploys the Helm Chart into the # Kubernetes cluster. - id: helmrelease template: apiVersion: helm.toolkit.fluxcd.io/v2 kind: HelmRelease metadata: name: bootstrap-helmrelease spec: releaseName: bootstrap-release interval: 1m timeout: 5m chartRef: kind: OCIRepository name: ${ocirepository.metadata.name} namespace: default values: # This is the second step of the localization. We use the image reference from the resource \u0026#34;image-resource\u0026#34; # and insert it into the Helm chart values. image: repository: ${resourceImage.status.reference.registry}/${resourceImage.status.reference.repository} tag: ${resourceImage.status.reference.tag}\rIf you plan to push your OCM component version to a private registry, you need to provide credentials for the OCM Controllers and FluxCDs OCIRepository (if the Helm chart is also stored in a private registry). Accordingly, you have to specify the ocmConfig field in the Resource resources and the secretRef field in the OCIRepository.\nIf you want to use the same credentials for FluxCD and for the OCM Controller resources, create a Kubernetes secret of type dockerconfigjson and keep all the resources in the same namespace.\nAfter creating both files, we can create the OCM component version using the following command:\nocm add componentversion --create --file ./ctf component-constructor.yaml\rThis will create a local CTF (Component Transfer Format) directory ./ctf containing the OCM component version. Since the OCM component version must be accessible for the OCM Controllers, we will transfer the CTF to a registry. For this example, we will use GitHub\u0026rsquo;s container registry, but you can use any OCI registry. Additionally, we will use the flag --copy-resources to make sure that all referential resources, for instance the Helm chart, will be localized in the first step - so, the image reference is updated to the new registry location:\nocm transfer ctf --copy-resources ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rIf you are using a registry that requires authentication, you need to provide credentials for ocm. Please refer to the [OCM CLI credentials documentation][ocm-credentials] for more information on how to set up and use credentials.\nIf everything went well, you should see the following output:\nocm get componentversion ghcr.io/\u0026lt;your-namespace\u0026gt;//ocm.software/ocm-k8s-toolkit/bootstrap:1.0.0 -o yaml | yq .component.resources\r# Output is truncated for brevity - access: imageReference: ghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a type: ociArtifact digest: ... name: helm-resource relation: external type: helmChart version: 1.0.0 - access: imageReference: ghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb type: ociArtifact digest: ... name: image-resource relation: external type: ociArtifact version: 1.0.0 - access: localReference: sha256:ed5252ff70bfe93e763ff6afeafe8dafd14c128981e4ae1472e35afc3ebe7a63 mediaType: application/octet-stream type: localBlob digest: ... name: resource-graph-definition relation: local type: blob version: 1.0.0\rDeploy the Helm Chart To deploy the Helm chart from the OCM component, we first need to create all resources that are required to bootstrap the ResourceGraphDefinition from the OCM component. Afterwards, we will create an instance of the resulting Custom Resource Definition (CRD) which will deploy the Helm chart and configure the localization.\nBootstrapping The bootstrap process consists of creating the OCM Controller resources that will download and apply the ResourceGraphDefinition. First, we will create a Repository and Component resource that point to the OCM component in the registry (the Component resource is reused in the ResourceGraphDefinition (see above) as reference for the Resource resources). Then, we create the Resource resource that references by name to the OCM resource containing the ResourceGraphDefinition. Finally, we will create a Deployer resource that will download the ResourceGraphDefinition and apply it to the cluster.\nTo proceed, create the following file named bootstrap.yaml containing the above-mentioned resources:\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: bootstrap-repository spec: repositorySpec: # Adjust to your OCM repository baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: bootstrap-component spec: component: ocm.software/ocm-k8s-toolkit/bootstrap repositoryRef: name: bootstrap-repository semver: 1.0.0 interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-rgd namespace: default spec: componentRef: name: bootstrap-component resource: byReference: resource: name: resource-graph-definition interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Deployer metadata: name: bootstrap-deployer spec: resourceRef: # Reference to the Kubernetes resource OCM resource that contains the ResourceGraphDefinition. name: bootstrap-rgd # As kro processes resources in cluster-scope*, the deployer must also be cluster-scoped. Accordingly, we have to # set the namespace of the resource here (usually, when the namespace is not specified, it is derived from the # referencing Kubernetes resource). # Check out the kro documentation for more details: # https://github.com/kro-run/kro/blob/8f53372bfde232db7ddd6809eebb6a1d69b34f2e/website/docs/docs/concepts/20-access-control.md namespace: default # ocmConfig is required, if the OCM repository requires credentials to access it. # (You also need to specify the namespace of the reference as the \u0026#39;deployer\u0026#39; is cluster-scoped.) # ocmConfig:\rAgain, if your OCM component version is stored in a private registry, you need to provide credentials for the OCM Controller resources to access the OCM repository. You can do so by specifying the ocmConfig field in the Repository, Component, Resource, and Deployer resources. For more information on how to set up credentials, please refer to the OCM Controllers credentials guide.\nAfterwards, apply the bootstrap.yaml to the cluster:\nkubectl apply -f bootstrap.yaml\rThis will create all the defined resources in the cluster and reconcile them. This can take a few seconds. As a result, you should see the ResourceGraphDefinition being created in the cluster:\nkubectl get rgd\rNAME APIVERSION KIND STATE AGE bootstrap v1alpha1 Bootstrap Active 2m56s By applying the ResourceGraphDefinition successfully, a Custom Resource Definition (CRD) named Bootstrap is created in the cluster. Check if the CRD is available by using the following command:\nkubectl get crd bootstraps.kro.run\rNAME CREATED AT bootstraps.kro.run 2025-05-28T11:40:38Z Troubleshooting You can check the status of the ResourceGraphDefinition by investigating the status of the resources or the logs of the ocm-k8s-toolkit-controller-manager.\nOne common issue, when using GitHub\u0026rsquo;s container registry, is that the transferred OCM component is by default a private package. If so, you might see an error like the following:\nfailed to list versions: failed to list tags: GET \u0026#34;https://ghcr.io/v2...\u0026#34;: response status code 401: unauthorized: authentication required You can resolve this issue by making the package public or by providing credentials to the respective resources.\nCreating an instance After applying the ResourceGraphDefinition and making sure that the resulting CRD is available, we can create an instance of the CRD, which will deploy the Helm chart and configure the localization. To do so, create a file containing the following content and name it instance.yaml:\napiVersion: kro.run/v1alpha1 kind: Bootstrap metadata: name: bootstrap\rThen, apply the instance to the cluster:\nkubectl apply -f instance.yaml\rIf successful, you should see the following output:\nkubectl get bootstrap\rNAME STATE SYNCED AGE bootstrap ACTIVE True 3m23s If the instance is in the ACTIVE state, the resources defined in the ResourceGraphDefinition were created and reconciled. This includes the OCM Controller resources for the Helm chart and the image, as well as FluxCDs resources for the OCI repository and the Helm release. Accordingly, you should see the following deployment in the cluster. To see, if the deployment was successful, you can use the following command:\nkubectl get deployments\rNAME READY UP-TO-DATE AVAILABLE AGE bootstrap-release-podinfo 1/1 1 1 4m25s Finally, you can check the pod itself to see if the localization was applied correctly by checking the image name in the container::\nkubectl get pods -l app.kubernetes.io/name=bootstrap-release-podinfo -o jsonpath=\u0026#39;{.items[0].spec.containers[0].image}\u0026#39;\rghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/podinfo:6.9.1 You now have successfully created an OCM component containing a Helm chart, the respective image for localization, and a ResourceGraphDefintion to deploy your Helm chart and localize the image. By creating the required bootstrap-resources you bootstrapped the ResourceGraphDefinition from the OCM component and created the resulting CRD. Finally, you created an instance of the CRD which deployed the Helm chart and configured the localization using the OCM Controllers, kro, and FluxCD.\n","date":"0001-01-01","id":17,"permalink":"/dev/docs/getting-started/ocm-controllers/deploying-a-helm-chart-with-bootstrap/","summary":"\u003cp\u003eThe \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/ocm-controllers/introduction/#concept\"\u003econcept\u003c/a\u003e and the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/ocm-controllers/deploying-a-helm-chart/\"\u003eprevious guide\u003c/a\u003e showed a basic example of how to deploy a Helm chart from an OCM component.\nBy defining a \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e that contains the all the required resources to deploy the Helm chart into a\nKubernetes cluster.\u003c/p\u003e","tags":[],"title":"Deploying a Helm Chart (with Bootstrap)"},{"content":"OCM Controller resources need access to OCM components and their resources. If these OCM components are stored in a private OCM repository, we need to configure credentials to allow OCM Controller resources to access these repositories.\nHow to configure credentials? Currently, OCM Controllers supports two ways to configure credentials for accessing private OCM repositories:\nKubernetes secret of type dockerconfigjson Kubernetes secret or configmap containing an .ocmconfig file Create a Kubernetes secret of type dockerconfigjson If you already have an existing Docker configuration file that you use to access your private OCM repository, you can create a Kubernetes secret of type dockerconfigjson that contains the credentials:\nkubectl create secret docker-registry ocm-secret --from-file=\u0026lt;path-to-your-docker-config-file\u0026gt;\rBe aware that Kubernetes secrets are only base64 encoded and not encrypted. This means that anyone with access to the Kubernetes secret can access the credentials.\nAccordingly, you should make sure that the Docker configuration file only contains information required for accessing the private OCM repository.\nIn case you want to create the secret manually, you can use the following command to create a Kubernetes secret of type dockerconfigjson:\nkubectl create secret docker-registry ocm-secret \\ --docker-username=\u0026lt;your-name\u0026gt; \\ --docker-password=\u0026lt;your-password\u0026gt; \\ --docker-server=\u0026lt;your-OCM-repository-url\u0026gt;\rCreate a Kubernetes secret or configmap from .ocmconfig file To create a Kubernetes secret or configmap containing an OCM configuration that allows OCM Controller resources to access private OCM repositories, you can use the .ocmconfig file used to transfer the OCM component in the first place.\nUsually, the .ocmconfig file is located in your HOME directory. However, this .ocmconfig could contain more configurations than just the credentials for accessing private OCM repositories. As this .ocmconfig will be used to create a Kubernetes secret or configmap to which other users might have access to, you have to make sure that it only contains the configuration you want to share.\nWe recommend to create a new .ocmconfig file that only contains the credentials for accessing the private OCM repository.\nFor more information on how to create and use the .ocmconfig file, please refer to the [OCM CLI credentials documentation][ocm-credentials].\nFor instance, consider you used the following command and .ocmconfig file to transfer the OCM component:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: \u0026lt;your-namespace\u0026gt; credentials: - type: Credentials properties: username: \u0026lt;your-username\u0026gt; password: \u0026lt;your-password/token\u0026gt;\rocm --config ./.ocmconfig transfer ctf ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rYou can now create a secret in the Kubernetes cluster that contains the .ocmconfig file:\nkubectl create secret generic ocm-secret --from-file=./.ocmconfig\rMake sure that the secret or configmap containing an OCM config has the correct key to the OCM config file .ocmconfig. This is required for OCM Controller resources to be able to read the OCM configuration. Using the filename .ocmconfig in the --from-file option takes care of that.\nHow to use the configured credentials? Every OCM Controller resource offers a spec.ocmConfig field that can be used to specify the credentials for accessing private OCM repositories. It expects an OCMConfiguration that contains a NamespacedObjectKindReference to the secret or configmap that contains the credentials.\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: helm-configuration-localization-repository spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m ocmConfig: - kind: secret name: ocm-secret\rBy default, the ocmConfig of a resource is propagated and can be consumed by other resources. So, instead of specifying the secret or configmap again, you can reference the resource in the ocmConfig field:\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: guide-repository namespace: default spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m ocmConfig: - kind: Secret name: ocm-secret --- apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: guide-component spec: component: ocm.software/ocm-k8s-toolkit/guide-component repositoryRef: name: guide-repository semver: 1.0.0 interval: 1m ocmConfig: - kind: Repository apiVersion: delivery.ocm.software/v1alpha1 name: guide-repository namespace: default\rThe above example shows how to use the ocmConfig field in an Repository and a Component. The Repository references a secret named ocm-secret that contains the credentials for accessing the private OCM repository. The Component then references the Repository in ocmConfigand uses the same credentials.\nHowever, you always need to specify a reference to the credentials either as secret, configmap, or as OCM Controller resource for each resource. The credentials will not be propagated automatically to all OCM Controller resources in the cluster.\nIn some cases, you do not want to propagate the ocmConfig of a resource. To do so, you can set the policy to DoNotPropagate:\napiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: guide-component spec: component: ocm.software/ocm-k8s-toolkit/guide-component repositoryRef: name: guide-repository semver: 1.0.0 interval: 1m ocmConfig: - kind: Repository apiVersion: delivery.ocm.software/v1alpha1 name: guide-repository namespace: default policy: DoNotPropagate\r","date":"0001-01-01","id":18,"permalink":"/dev/docs/getting-started/ocm-controllers/configuring-credentials/","summary":"\u003cp\u003eOCM Controller resources need access to OCM components and their resources. If these OCM components are stored in a\nprivate OCM repository, we need to configure credentials to allow OCM Controller resources to access these\nrepositories.\u003c/p\u003e","tags":[],"title":"Configuring credentials"},{"content":"","date":"0001-01-01","id":19,"permalink":"/dev/docs/tutorials/","summary":"","tags":[],"title":"Tutorials"},{"content":"Introduction In this tutorial software products are comprised of logical units called components. A component version consists of a set of technical artifacts (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called resources in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named sources in this specification.\nOCM introduces a Component Version for every component version that describes the resources, sources, and other component versions belonging to a particular component version and how to access them.\nUsually, however, real-life applications are composed of multiple components. For example, an application might consist of a frontend, a backend, a database, and a web server. During the software development process new component versions are created and third-party components might be consumed from a public registry and updated from time to time.\nNot all component version combinations of frontend, backend, database, etc. are compatible and form a valid product version. In order to define reasonable version combinations for the software product, we could use another feature of OCM\u0026rsquo;s Component Version, called a Component Reference (or reference in short), which allows the aggregation of component versions.\nFor each sub-component and each version in use, there is a Component Version. For the entire application, we introduce a new component that describes the overall software product referencing all components. This describes the entire application or product.\nA particular version of this application is again described by a Component Version, which contains references to the Component Versions of its sub-components in their version in use. You are not restricted to this approach. It is, e.g., possible to create multi-level hierarchies or you could just maintain a list of component version combinations which build a valid product release.\nIn a nutshell, OCM provides a simple approach to specify what belongs to a product version. Starting with the Component Version for a product version and following the component references, you could collect all artifacts belonging to this product version.\nPrerequisites We assume that you have already read the guides in the Getting Started section, as this guide discusses a more complex scenario.\nConstructing the Component We are going to use podinfo in microservices mode. This describes a setup with multiple microservices forming a larger application.\npodinfo has three services which we are going to model using individual component versions:\nbackend frontend cache (redis) We will use the following example application to demonstrate a multi-component structure using podinfo: Podinfo Component.\nThis repository contains the following items:\nComponent File The following component-constructor file describes four components: three components, each representing a podinfo microservice and one aggregated component that brings together the podinfo components using references. We refer to the aggregated component as the product component. A component-constructor file can contain one or multiple components and references to other components. The file is a YAML file and can be validated using the OCM schema.\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: # -- product component - name: ocm.software/podinfo version: 1.0.2 labels: - name: ocm.software/labels/podinfo/purpose value: - kind: test type: manual provider: name: open-component-model componentReferences: - name: backend componentName: ocm.software/podinfo/backend version: 1.0.0 - name: frontend componentName: ocm.software/podinfo/frontend version: 1.0.0 - name: redis componentName: ocm.software/redis version: 1.0.0 sources: - access: commit: ac0afafcf4aa333546634cba631f0090a0a4cbe3 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- backend component - name: ocm.software/podinfo/backend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: backend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: backend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: backend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- frontend component - name: ocm.software/podinfo/frontend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: frontend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: frontend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: frontend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- redis component - name: ocm.software/redis version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: redis resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: redis/config.yaml compress: true - name: image relation: external type: ociImage version: 6.0.1 access: type: ociArtifact imageReference: redis:6.0.1 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: redis/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0\rWith the components modeled we can start to build a component archive using the ocm cli:\nocm add componentversions --create --file component-archive component-constructor.yaml processing component-constructor.yaml... processing document 1... processing index 1 processing index 2 processing index 3 processing index 4 found 4 components adding component ocm.software/podinfo:1.0.2... adding reference ocm.software/podinfo/backend: \u0026#34;name\u0026#34;=\u0026#34;backend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/podinfo/frontend: \u0026#34;name\u0026#34;=\u0026#34;frontend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/redis: \u0026#34;name\u0026#34;=\u0026#34;redis\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding component ocm.software/podinfo/backend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/podinfo/frontend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/redis:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.0.1\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;...\rThis will create a folder called component-archive. The structure of that should look something like this:\ntree . . ├── artifact-index.json └── blobs ├── sha256.03ac3a7611e118d08fcf70e9b7be263c4a7082066f9763f71d8901d7fa2afc9d ├── sha256.118b6e8282ee1d335b1638a76a20022b6acc319177dbbce3089700da835afb6a ├── sha256.12073781e4fba95f19f046c51c90f0c4e1338d47afe4795bf6fcca163ae46eb8 ├── sha256.1f239399104ec0cc7680956eb60960d212b3368609feb83dac2c95040d24b480 ├── sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e ├── sha256.3dc6209959eb782fa6f5f44892f66e9657276735bfb40407bd00ddca30d0a9d1 ├── sha256.654debd65dbadbcee73e55b675980865ddf22acffcec166c59a5e48a213e4dd5 ├── sha256.699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0 ├── sha256.70a47378c043721e3099801dec02c44b1dd9cdef0ebf79c55784eb4666bdbc29 ├── sha256.773b28fb63f1195ff73e328744639ddc1c574d58c1e723d6e386fcd66b45bd9c ├── sha256.893be914eebd8230ef848ea82b3433c6201152f5d9925e7b5b8d68e0cec7133e ├── sha256.92991cf391167c928f3afe6891001f3dd325b64ce800cf34fad4c038141fc57f ├── sha256.98ca4d46130f5c09a704b3d8ee9af94de3c0ac73d7e990df53e64606c418fea8 ├── sha256.a779270c2fea310835d3125de90e089e423c9730a98f1acdda328470d21fced0 ├── sha256.a7dd532f80e8417ed33cf0c97328582847017895fc5146e499bdf4c94a9d17b5 ├── sha256.cae4365f264251c616210707aa4765bd95f23fd22f98abc68bae9f58d6e4506d ├── sha256.ee79c92bbcce9e7a98f07c6577fd56dd45cf6f7c2d3115216ee249f42119030e └── sha256.f6a82a23220752c232e5f66ce46f0be28b27a5af19474072c77dac6d1feb0c16 2 directories, 19 files\rThese blobs contain the resources we described when modelling our podinfo application. If we cat a random blob we get something like this:\ncat sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e {\u0026#34;componentDescriptorLayer\u0026#34;:{\u0026#34;mediaType\u0026#34;:\u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;,\u0026#34;digest\u0026#34;:\u0026#34;sha256:699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0\u0026#34;,\u0026#34;size\u0026#34;:2560}}%\rNext, we transfer this component to an OCI registry of your choice. Here \u0026lt;your-location\u0026gt; for me was ghcr.io/skarlso/demo-component.\nocm transfer component ./component-archive \u0026lt;your-location\u0026gt; transferring version \u0026#34;ocm.software/podinfo:1.0.2\u0026#34;... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/backend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/frontend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/redis:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... 4 versions transferred\rWith the transfer completed, we now have a product *Component Version* that describes a set of sub-components using *Component References*. It bundles all required artifacts for a successful deployment of the complete product.\nConclusion We saw how to create a complex, multi-service architecture product component and store it in an OCI registry.\n","date":"0001-01-01","id":20,"permalink":"/dev/docs/tutorials/structuring-software-products-with-ocm/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial software products are comprised of logical units called \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/overview/important-terms/#components-in-ocm\"\u003e\u003cem\u003ecomponents\u003c/em\u003e\u003c/a\u003e. A component version consists of a set of technical \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm-spec/blob/main/doc/04-extensions/01-artifact-types/README.md\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003eartifacts\u003c/em\u003e\u003c/a\u003e (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called \u003cem\u003eresources\u003c/em\u003e in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named \u003cem\u003esources\u003c/em\u003e in this specification.\u003c/p\u003e","tags":[],"title":"Structuring Software Products with OCM"},{"content":" Overview Input Types binary dir docker dockermulti file helm ociImage spiff utf-8 Access Types gitHub helm npm ociArtifact s3 Overview The Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\nAn Input type adds content by value, along with the component descriptor and stores it in the same target repository where the component is stored. After pushing the content to the target registry this always resolves to the attribute\nrelation: local\rin a component descriptor.\nAn Access Type just adds content by reference to an external location, e.g., an OCI registry. It is a kind of pointer in a component descriptor. It resolves to the attribute\nrelation: external\rin a component descriptor.\nThe following input types are supported:\nbinary dir docker dockermulti file helm ociImage spiff utf-8 Please use the latest ocm-cli to check available input types:\nocm add resources --help | grep \u0026#39; - Input type\u0026#39; | sort -f\rThe following list of access types is supported:\ngitHub localBlob ociArtifact ociBlob s3 Please use the latest ocm-cli to check available access types:\nocm ocm-accessmethods | grep \u0026#39; - Access type\u0026#39; | sort -f\rNot all access and input types can be combined in useful ways with all artifact types. But the OCM specification does not define any restrictions on possible combinations.\nThe following sections give an overview and typical usage examples for access and input types. It does not describe the full list of possible fields and their meaning. For a complete list of attributes, please see the command reference. The examples below are meant to be used in a component that looks like this:\n- name: github.com/open-component-model/megacomponent version: 0.1.0\rInput Types binary Allows to define resources with binary content being base64 encoded. Should only be used for smaller blobs.\nresources: - name: noticeencoded type : blob input: data: VGhpcyBpcyBzb21lIGJhc2U2NCBlbmNvZGVkIGRhdGEK mediaType: text/plain compress: false type: binary\rdir Defines a resource from content of a directory in the local file system. It is packed with tar and optionally compressed.\nresources: - name: megadir type : fileSystem input: type: dir path: ./logos\rdocker Takes an image from the local docker registry and adds it as a resource. Requires a running docker daemon.\nresources: - name: megaimage type : ociImage input: type: docker repository: images/mega path: megacomp:${VERSION}\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0 9aab9cbca56e 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/mega:1.10.\ndockermulti Takes multiple images from the local docker registry and adds them as single multi-arch image. Requires a running docker daemon. The images have to be built for different architectures/os and need a unique tag identifying them. As docker does not support multi-arch images at the time of writing this is a workaround.\nresources: - name: megaimagemulti type : ociImage input: type: dockermulti repository: images/megamulti variants: - megacomp:${VERSION}-linux-amd64 - megacomp:${VERSION}-linux-arm64\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0-linux-amd64 96659c4f7a35 5 days ago 7.05MB megacomp 0.1.0-linux-arm64 64f209acb814 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/megamulti:1.10.\nfile Imports a file from the local file system and adds it as a resource.\nresources: - name: mega-file type: blob input: type: file path: ./logos/logo-image.png\rhelm Imports a helm chart from the local file system and adds it as a resource.\nresources: - name: mega-chart type: helmChart input: type: helm path: ./megachart repository: charts/mega\rAfter transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mega prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mega. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used.\nIt is also possible to import a helm chart from a helm chart repository:\nresources: - name: mariadb-chart type: helmChart input: type: helm helmRepository: https://charts.bitnami.com/bitnami path: mariadb version: 12.2.7 repository: charts/mariadb\rHere the helm chart version 12.2.7 is copied from the path mariadb in helm chart repository https://charts.bitnami.com/bitnami. After transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mariadb prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mariadb. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used. There are additional optional fields caCert and caCertFile to specify a TLS certificate for the helm chart repository.\nociImage Takes an image that is located in an OCI registry and adds it as a resource.\nresources: - name: mega-image type: ociImage input: type: ociImage path: gcr.io/google_containers/echoserver:1.10 repository: images/echo\rThe target location of the image after transporting to an OCI registry can be set with the repository field. Here the resulting image will be prefixed with the name of the component version, e.g., github.com/open-component-model/megacomponent/images/echo:1.10. This auto-prefix can be disabled by using a leading slash /images/echo.\nspiff Processes a resource using the spiff templater and can provide values for variables.\nresources: - name: mega-package type: toiPackage input: type: spiff mediaType: application/vnd.toi.ocm.software.package.v1+yaml path: packagespec.yaml values: RELEASE_NAME: megacomp\rutf-8 Adds a resource from inline text.\nresources: - name: noticeplain type : blob input: text: \u0026#34;Here is some text\u0026#34; mediaType: text/plain compress: false type: utf8\rAccess Types gitHub Refers to a Git repository at a certain commit or tag.\nresources: - name: git-ocm type: blob version: ${VERSION} access: type: gitHub repoUrl: https://github.com/open-component-model/ocm commit: 42cc249aec77aa64984b2b91eb0f3b96dd63aacd\rhelm Refers to a helm chart located in a helm chart repository.\n- name: mariadb-chart type: helmChart version: ${VERSION} access: type: helm helmChart: mariadb:12.2.7 helmRepository: https://charts.bitnami.com/bitnami\rnpm Refers to an npm package located in a Javascript package registry.\n- name: prime-npm type: ocm/npmPackage version: ${VERSION} access: type: npm package: random-prime version: 4.0.0 registry: https://registry.npmjs.org\rociArtifact Refers to an image in an (external) OCI registry.\nresources: - name: echo-image version: \u0026#34;1.10\u0026#34; type: ociImage access: type: ociArtifact imageReference: gcr.io/google_containers/echoserver:1.10\rs3 Refers to an object in an AWS S3 store.\nresources: - name: gardenlinux-meta type: blob version: ${VERSION} access: type: s3 bucket: gardenlinux key: meta/singles/gcp-cloud-gardener-_prod-890.0-53b732\r","date":"0001-01-01","id":21,"permalink":"/dev/docs/tutorials/input-and-access-types/","summary":"\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#overview\"\u003eOverview\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#input-types\"\u003eInput Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#binary\"\u003ebinary\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dir\"\u003edir\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#docker\"\u003edocker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dockermulti\"\u003edockermulti\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#file\"\u003efile\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociimage\"\u003eociImage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#spiff\"\u003espiff\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#utf-8\"\u003eutf-8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#access-types\"\u003eAccess Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#github\"\u003egitHub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm-1\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#npm\"\u003enpm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociartifact\"\u003eociArtifact\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#s3\"\u003es3\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\u003c/p\u003e","tags":[],"title":"Input and Access Types"},{"content":"Overview The OCM command line client can be configured by supplying it with a configuration file. By default, the CLI looks for configuration in $HOME/.ocmconfig, if it exists.\nThe configuration file can be used in particular to specify the credentials, which are required for the CLI to be able to access the artifact repositories referenced in CLI commands.\nExamples This page contains basic examples of credentials configuration for a few most common artifact repository types. The examples below are complete .ocmconfig files, not snippets.\nFor comprehensive documentation on the credentials topic, including usage of certificates or HashiCorp Vault, execute the command ocm credential-handling.\nRepositories and Consumers In the examples below, some configuration is located under configurations[0].repositories, and some other under configurations[0].consumers. This chapter explains the difference between repositories and consumers, which is potentially not as obvious as one could think.\nIn this context, repository is a place where credentials can be stored, i.e., it is a credentials repository. For example, Docker\u0026rsquo;s config.json can store multiple credentials, and in that sense the file serves as a repository that can store and provide credentials. That is why its location is configured under repositories. Other examples of credentials repositories can be the NPM\u0026rsquo;s .npmrc file or a HashiCorp Vault instance.\nA consumer is something the credentials are required for. For example, if you need to configure credentials that are required to log in to an OCI registry, one could say that the registry will be consuming these credentials, i.e., the registry is a credentials consumer. That is why it is configured under consumers.\nReuse Credentials Configured for Docker This .ocmconfig file will tell the OCM CLI to use credentials configuration from Docker\u0026rsquo;s config.json file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34;\rReuse Credentials Configured for npm This .ocmconfig file will tell OCM CLI to use credentials configuration from npm\u0026rsquo;s .npmrc file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: NPMConfig/v1 npmrcFile: \u0026#39;~/.npmrc\u0026#39;\rAccessing OCI Registries HTTPS and Path To access artifacts in https://ghcr.io/open-component-model:\nThe different parts of the URL have to be specified in separate fields: scheme, hostname, and pathprefix The fields scheme and pathprefix are optional. If not specified, the OCM CLI will use the credentials for all schemes and paths on that host The password is the user\u0026rsquo;s basic authentication password. Some OCI registries allow to generate user access tokens, which can also be used for basic authentication type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rHTTP, Port Number, Empty Path To access artifacts in http://127.0.0.1:5001:\nThe fields scheme and port are optional. If not specified, the OCM CLI will use the credentials for all schemes and ports on that host As the URL has no path behind the port number, the pathprefix element can be removed type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: http hostname: 127.0.0.1 port: 5001 credentials: - type: Credentials properties: username: admin password: admin\rAccessing Helm Chart Repositories Similar to OCI registries, but uses HelmChartRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: HelmChartRepository hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rAccessing Maven Repositories Similar to OCI registries, but uses MavenRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: MavenRepository hostname: maven.repo.host pathprefix: path/to/repo credentials: - type: Credentials properties: username: some-user password: some-password\rAccessing npm Registries Similar to OCI registries, but uses NpmRegistry as identity type. In addition, it is required to specify the email address matching with the one in the user record in the npm registry.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: NpmRegistry hostname: npm.registry.host pathprefix: path/to/registry credentials: - type: Credentials properties: username: some-user password: some-password email: foo.bar@acme.org\rAccessing GitHub Repositories To access code in https://my.github.enterprise/my-org/my-repo:\nUse Github as identity type hostname is the domain name of the GitHub instance pathprefix is a combination of organization and repository names token is a personal access token generated in GitHub Developer Settings type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\rAccessing Several Systems It is, of course, possible to configure credentials for several systems in the same .ocmconfig file. To do that, you can combine as many repositories and consumers as you need.\nThe example below instructs OCM CLI to look for credentials in Docker\u0026rsquo;s config.json, and in addition specifies dedicated credentials for an OCI registry and a GitHub repository.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true consumers: - identity: type: OCIRegistry hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\r","date":"0001-01-01","id":22,"permalink":"/dev/docs/tutorials/creds-in-ocmconfig/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm.md\" target=\"_blank\" rel=\"noopener\"\u003eOCM command line client\u003c/a\u003e can be configured by supplying it with a \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_configfile.md\" target=\"_blank\" rel=\"noopener\"\u003econfiguration file\u003c/a\u003e. By default, the CLI looks for configuration in \u003ccode\u003e$HOME/.ocmconfig\u003c/code\u003e, if it exists.\u003c/p\u003e","tags":[],"title":"Credentials in .ocmconfig File"},{"content":"","date":"0001-01-01","id":23,"permalink":"/dev/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":24,"permalink":"/dev/community/","summary":"","tags":[],"title":"Communities"},{"content":"","date":"0001-01-01","id":25,"permalink":"/dev/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":26,"permalink":"/dev/docs/","summary":"","tags":[],"title":"Documentation"},{"content":"ocm The official Open Component Model (OCM) CLI\nSynopsis The Open Component Model command line client supports the work with OCM artifacts, like Component Archives, Common Transport Archive, Component Repositories, and Component Versions.\nocm [sub-command] [flags]\rOptions --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. -h, --help help for ocm --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm add\t- Add anything to OCM ocm completion\t- Generate the autocompletion script for the specified shell ocm download\t- Download anything from OCM ocm generate\t- Generate documentation for the OCM CLI ocm get\t- Get anything from OCM ocm version\t- Retrieve the build version of the OCM CLI ","date":"0001-01-01","id":27,"permalink":"/dev/docs/reference/ocm-cli/ocm/","summary":"\u003ch2 id=\"ocm\"\u003eocm\u003c/h2\u003e\n\u003cp\u003eThe official Open Component Model (OCM) CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eThe Open Component Model command line client supports the work with OCM\nartifacts, like Component Archives, Common Transport Archive,\nComponent Repositories, and Component Versions.\u003c/p\u003e","tags":[],"title":"ocm"},{"content":"ocm add Add anything to OCM\nocm add {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for add\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm add component-version\t- Add component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file ","date":"0001-01-01","id":28,"permalink":"/dev/docs/reference/ocm-cli/ocm-add/","summary":"\u003ch2 id=\"ocm-add\"\u003eocm add\u003c/h2\u003e\n\u003cp\u003eAdd anything to OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for add\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG_PATH environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-add-component-version/\"\u003eocm add component-version\u003c/a\u003e\t - Add component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm add"},{"content":"ocm add component-version Add component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file\nSynopsis Add component version(s) to an OCM repository that can be reused for transfers.\nA \u0026ldquo;component-constructor\u0026rdquo; file is used to specify the component version(s) to be added. It can contain both a single component or many components.\nBy default, the command will look for a file named \u0026ldquo;component-constructor.yaml\u0026rdquo; or \u0026ldquo;component-constructor.yml\u0026rdquo; in the current directory. If given a path to a directory, the command will look for a file named \u0026ldquo;component-constructor.yaml\u0026rdquo; or \u0026ldquo;component-constructor.yml\u0026rdquo; in that directory. If given a path to a file, the command will attempt to use that file as the \u0026ldquo;component-constructor\u0026rdquo; file.\nIf you provide a working directory, all paths in the \u0026ldquo;component-constructor\u0026rdquo; file will be resolved relative to that directory. Otherwise the path to the \u0026ldquo;component-constructor\u0026rdquo; file will be used as the working directory. You are only allowed to reference files within the working directory or sub-directories of the working directory.\nRepository Reference Format: [type::]{repository}\nFor known types, currently only {OCIRepository|CommonTransportFormat} are supported, which can be shortened to {OCI|oci|CTF|ctf} respectively for convenience.\nIf no type is given, the repository specification is interpreted based on introspection and heuristics:\nURL schemes or domain patterns -\u0026gt; OCI registry Local paths -\u0026gt; CTF archive In case the CTF archive does not exist, it will be created by default. If not specified, it will be created with the name \u0026ldquo;transport-archive\u0026rdquo;.\nocm add component-version [flags]\rExamples Adding component versions to a CTF archive: add component-version --repository ./path/to/transport-archive --constructor ./path/to/component-constructor.yaml add component-version --repository /tmp/my-archive --constructor constructor.yaml Adding component versions to an OCI registry: add component-version --repository ghcr.io/my-org/my-repo --constructor component-constructor.yaml add component-version --repository https://my-registry.com/my-repo --constructor component-constructor.yaml add component-version --repository localhost:5000/my-repo --constructor component-constructor.yaml Specifying repository types explicitly: add component-version --repository ctf::./local/archive --constructor component-constructor.yaml add component-version --repository oci::http://localhost:8080/my-repo --constructor component-constructor.yaml\rOptions --blob-cache-directory string path to the blob cache directory (default \u0026#34;.ocm/cache\u0026#34;) --component-version-conflict-policy enum policy to apply when a component version already exists in the repository (must be one of [abort-and-fail replace skip]) (default abort-and-fail) --concurrency-limit int maximum number of component versions that can be constructed concurrently. (default 4) -c, --constructor path path to the component constructor file (default component-constructor.yaml) -h, --help help for component-version -r, --repository string repository ref (default \u0026#34;transport-archive\u0026#34;) --skip-reference-digest-processing skip digest processing for resources and sources. Any resource referenced via access type will not have their digest updated.\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm add\t- Add anything to OCM ","date":"0001-01-01","id":29,"permalink":"/dev/docs/reference/ocm-cli/ocm-add-component-version/","summary":"\u003ch2 id=\"ocm-add-component-version\"\u003eocm add component-version\u003c/h2\u003e\n\u003cp\u003eAdd component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eAdd component version(s) to an OCM repository that can be reused for transfers.\u003c/p\u003e","tags":[],"title":"ocm add component-version"},{"content":"","date":"0001-01-01","id":30,"permalink":"/dev/docs/reference/ocm-cli/","summary":"","tags":[],"title":"OCM CLI"},{"content":"ocm completion Generate the autocompletion script for the specified shell\nSynopsis Generate the autocompletion script for ocm for the specified shell. See each sub-command\u0026rsquo;s help for details on how to use the generated script.\nOptions -h, --help help for completion\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm completion bash\t- Generate the autocompletion script for bash ocm completion fish\t- Generate the autocompletion script for fish ocm completion powershell\t- Generate the autocompletion script for powershell ocm completion zsh\t- Generate the autocompletion script for zsh ","date":"0001-01-01","id":31,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion/","summary":"\u003ch2 id=\"ocm-completion\"\u003eocm completion\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for the specified shell\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for ocm for the specified shell.\nSee each sub-command\u0026rsquo;s help for details on how to use the generated script.\u003c/p\u003e","tags":[],"title":"ocm completion"},{"content":"ocm completion bash Generate the autocompletion script for bash\nSynopsis Generate the autocompletion script for the bash shell.\nThis script depends on the \u0026lsquo;bash-completion\u0026rsquo; package. If it is not installed already, you can install it via your OS\u0026rsquo;s package manager.\nTo load completions in your current shell session:\nsource \u0026lt;(ocm completion bash) To load completions for every new session, execute once:\nLinux: ocm completion bash \u0026gt; /etc/bash_completion.d/ocm macOS: ocm completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/ocm You will need to start a new shell for this setup to take effect.\nocm completion bash\rOptions -h, --help help for bash --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":32,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-bash/","summary":"\u003ch2 id=\"ocm-completion-bash\"\u003eocm completion bash\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for bash\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the bash shell.\u003c/p\u003e\n\u003cp\u003eThis script depends on the \u0026lsquo;bash-completion\u0026rsquo; package.\nIf it is not installed already, you can install it via your OS\u0026rsquo;s package manager.\u003c/p\u003e","tags":[],"title":"ocm completion bash"},{"content":"ocm completion fish Generate the autocompletion script for fish\nSynopsis Generate the autocompletion script for the fish shell.\nTo load completions in your current shell session:\nocm completion fish | source To load completions for every new session, execute once:\nocm completion fish \u0026gt; ~/.config/fish/completions/ocm.fish You will need to start a new shell for this setup to take effect.\nocm completion fish [flags]\rOptions -h, --help help for fish --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":33,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-fish/","summary":"\u003ch2 id=\"ocm-completion-fish\"\u003eocm completion fish\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for fish\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the fish shell.\u003c/p\u003e\n\u003cp\u003eTo load completions in your current shell session:\u003c/p\u003e","tags":[],"title":"ocm completion fish"},{"content":"ocm completion powershell Generate the autocompletion script for powershell\nSynopsis Generate the autocompletion script for powershell.\nTo load completions in your current shell session:\nocm completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your powershell profile.\nocm completion powershell [flags]\rOptions -h, --help help for powershell --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":34,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-powershell/","summary":"\u003ch2 id=\"ocm-completion-powershell\"\u003eocm completion powershell\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for powershell\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for powershell.\u003c/p\u003e\n\u003cp\u003eTo load completions in your current shell session:\u003c/p\u003e","tags":[],"title":"ocm completion powershell"},{"content":"ocm completion zsh Generate the autocompletion script for zsh\nSynopsis Generate the autocompletion script for the zsh shell.\nIf shell completion is not already enabled in your environment you will need to enable it. You can execute the following once:\necho \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc To load completions in your current shell session:\nsource \u0026lt;(ocm completion zsh) To load completions for every new session, execute once:\nLinux: ocm completion zsh \u0026gt; \u0026quot;${fpath[1]}/_ocm\u0026quot; macOS: ocm completion zsh \u0026gt; $(brew --prefix)/share/zsh/site-functions/_ocm You will need to start a new shell for this setup to take effect.\nocm completion zsh [flags]\rOptions -h, --help help for zsh --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":35,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-zsh/","summary":"\u003ch2 id=\"ocm-completion-zsh\"\u003eocm completion zsh\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for zsh\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the zsh shell.\u003c/p\u003e\n\u003cp\u003eIf shell completion is not already enabled in your environment you will need\nto enable it.  You can execute the following once:\u003c/p\u003e","tags":[],"title":"ocm completion zsh"},{"content":"ocm download Download anything from OCM\nocm download {resource|resources|plugin|plugins} [flags]\rOptions -h, --help help for download\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm download plugin\t- Download plugin binaries from a component version. ocm download resource\t- Download resources described in a component version in an OCM Repository ","date":"0001-01-01","id":36,"permalink":"/dev/docs/reference/ocm-cli/ocm-download/","summary":"\u003ch2 id=\"ocm-download\"\u003eocm download\u003c/h2\u003e\n\u003cp\u003eDownload anything from OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download {resource|resources|plugin|plugins} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for download\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG_PATH environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-plugin/\"\u003eocm download plugin\u003c/a\u003e\t - Download plugin binaries from a component version.\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-resource/\"\u003eocm download resource\u003c/a\u003e\t - Download resources described in a component version in an OCM Repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm download"},{"content":"ocm download plugin Download plugin binaries from a component version.\nSynopsis Download a plugin binary from a component version located in a component version.\nThis command fetches a specific plugin resource from the given OCM component version and stores it at the specified output location. The plugin binary can be identified by resource name and version, with optional extra identity parameters for platform-specific binaries.\nResources can be accessed either locally or via a plugin that supports remote fetching, with optional credential resolution.\nocm download plugin [flags]\rExamples # Download a plugin binary with resource name \u0026#39;ocm-plugin\u0026#39; and version \u0026#39;v1.0.0\u0026#39; ocm download plugin ghcr.io/org/component:v1 --resource-name ocm-plugin --resource-version v1.0.0 --output ./plugins/ocm-plugin # Download a platform-specific plugin binary with extra identity parameters ocm download plugin ghcr.io/org/component:v1 --resource-name ocm-plugin --resource-version v1.0.0 --extra-identity os=linux,arch=amd64 --output ./plugins/ocm-plugin-linux-amd64 # Download plugin using only resource name (uses component version if resource version not specified) ocm download plugin ghcr.io/org/component:v1 --resource-name ocm-plugin --output ./plugins/ocm-plugin\rOptions --extra-identity strings extra identity parameters for resource matching (e.g., os=linux,arch=amd64) -h, --help help for plugin --output string output location to download the plugin binary to (required) (default \u0026#34;.\u0026#34;) -f, --output-format enum output format of the plugin information, defaults to table (must be one of [json table yaml]) (default table) --resource-name string name of the plugin resource to download (required) --resource-version string version of the plugin resource to download (optional, defaults to component version) --skip-validation skip validation of the downloaded plugin binary\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm download\t- Download anything from OCM ","date":"0001-01-01","id":37,"permalink":"/dev/docs/reference/ocm-cli/ocm-download-plugin/","summary":"\u003ch2 id=\"ocm-download-plugin\"\u003eocm download plugin\u003c/h2\u003e\n\u003cp\u003eDownload plugin binaries from a component version.\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDownload a plugin binary from a component version located in a component version.\u003c/p\u003e","tags":[],"title":"ocm download plugin"},{"content":"ocm download resource Download resources described in a component version in an OCM Repository\nSynopsis Download a resource from a component version located in an Open Component Model (OCM) repository.\nThis command fetches a specific resource from the given OCM component version reference and stores it at the specified output location. It supports optional transformation of the resource using a registered transformer plugin.\nIf no transformer is specified, the resource is written directly in its original format. If the media type is known, the appropriate file extension will be added to the output file name if no output location is given.\nResources can be accessed either locally or via a plugin that supports remote fetching, with optional credential resolution.\nocm download resource [flags]\rExamples # Download a resource with identity \u0026#39;name=example\u0026#39; and write to default output ocm download resource ghcr.io/org/component:v1 --identity name=example # Download a resource and specify an output file ocm download resource ghcr.io/org/component:v1 --identity name=example --output ./my-resource.tar.gz # Download a resource and apply a transformer ocm download resource ghcr.io/org/component:v1 --identity name=example --transformer my-transformer\rOptions --extraction-policy enum policy to apply when extracting a resource. If set to \u0026#39;disable\u0026#39;, the resource will not be extracted, even if they could be. If set to \u0026#39;auto\u0026#39;, the resource will be automatically extracted if the returned resource is a recognized archive format. (must be one of [auto disable]) (default auto) -h, --help help for resource --identity string resource identity to download --output string output location to download to. If no transformer is specified, and no format was discovered that can be written to a directory, the resource will be written to a file. --transformer string transformer to use for the output. If not specified, the resource will be written as is. Options inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm download\t- Download anything from OCM ","date":"0001-01-01","id":38,"permalink":"/dev/docs/reference/ocm-cli/ocm-download-resource/","summary":"\u003ch2 id=\"ocm-download-resource\"\u003eocm download resource\u003c/h2\u003e\n\u003cp\u003eDownload resources described in a component version in an OCM Repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDownload a resource from a component version located in an Open Component Model (OCM) repository.\u003c/p\u003e","tags":[],"title":"ocm download resource"},{"content":"ocm generate Generate documentation for the OCM CLI\nSynopsis A longer description that spans multiple lines and likely contains examples and usage of using your command. For example:\nCobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.\nOptions -h, --help help for generate\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm generate docs\t- Generate Documentation for the CLI ","date":"0001-01-01","id":39,"permalink":"/dev/docs/reference/ocm-cli/ocm-generate/","summary":"\u003ch2 id=\"ocm-generate\"\u003eocm generate\u003c/h2\u003e\n\u003cp\u003eGenerate documentation for the OCM CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eA longer description that spans multiple lines and likely contains examples\nand usage of using your command. For example:\u003c/p\u003e","tags":[],"title":"ocm generate"},{"content":"ocm generate docs Generate Documentation for the CLI\nSynopsis Generate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.\nocm generate docs [-d \u0026lt;directory\u0026gt;] [--mode \u0026lt;format\u0026gt;] [flags]\rOptions -d, --directory string directory to generate docs to. If not set, current working directory is used. -h, --help help for docs --mode enum generation mode to use (must be one of [hugo man markdown restructured yaml]) (default markdown)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm generate\t- Generate documentation for the OCM CLI ","date":"0001-01-01","id":40,"permalink":"/dev/docs/reference/ocm-cli/ocm-generate-docs/","summary":"\u003ch2 id=\"ocm-generate-docs\"\u003eocm generate docs\u003c/h2\u003e\n\u003cp\u003eGenerate Documentation for the CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.\u003c/p\u003e","tags":[],"title":"ocm generate docs"},{"content":"ocm get Get anything from OCM\nocm get {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for get\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm get component-version\t- Get component version(s) from an OCM repository ","date":"0001-01-01","id":41,"permalink":"/dev/docs/reference/ocm-cli/ocm-get/","summary":"\u003ch2 id=\"ocm-get\"\u003eocm get\u003c/h2\u003e\n\u003cp\u003eGet anything from OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for get\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG_PATH environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-get-component-version/\"\u003eocm get component-version\u003c/a\u003e\t - Get component version(s) from an OCM repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm get"},{"content":"ocm get component-version Get component version(s) from an OCM repository\nSynopsis Get component version(s) from an OCM repository.\nThe format of a component reference is: [type::]{repository}/[valid-prefix]/{component}[:version]\nFor valid prefixes {component-descriptors|none} are available. If is used, it defaults to \u0026ldquo;component-descriptors\u0026rdquo;. This is because by default, OCM components are stored within a specific sub-repository.\nFor known types, currently only {OCIRepository|CommonTransportFormat} are supported, which can be shortened to {OCI|oci|CTF|ctf} respectively for convenience.\nIf no type is given, the repository path is interpreted based on introspection and heuristics.\nocm get component-version {reference} [flags]\rExamples Getting a single component version: get component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 get cv ./path/to/ctf//ocm.software/ocmcli:0.23.0 get cv ./path/to/ctf/component-descriptors/ocm.software/ocmcli:0.23.0 Listing many component versions: get component-versions ghcr.io/open-component-model/ocm//ocm.software/ocmcli get cvs ghcr.io/open-component-model/ocm//ocm.software/ocmcli --output json get cvs ghcr.io/open-component-model/ocm//ocm.software/ocmcli -oyaml Specifying types and schemes: get cv ctf::github.com/locally-checked-out-repo//ocm.software/ocmcli:0.23.0 get cvs oci::http://localhost:8080//ocm.software/ocmcli\rOptions --concurrency-limit int maximum amount of parallel requests to the repository for resolving component versions (default 4) --display-mode enum display mode can be used in combination with --recursive static: print the output once the complete component graph is discovered live (experimental): continuously updates the output to represent the current discovery state of the component graph (must be one of [live static]) (default static) -h, --help help for component-version --latest if set, only the latest version of the component is returned -o, --output enum output format of the component descriptors (must be one of [json ndjson table tree yaml]) (default table) --recursive int[=-1] depth of recursion for resolving referenced component versions (0=none, -1=unlimited, \u0026gt;0=levels (not implemented yet)) --semver-constraint string semantic version constraint restricting which versions to output (default \u0026#34;\u0026gt; 0.0.0-0\u0026#34;)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm get\t- Get anything from OCM ","date":"0001-01-01","id":42,"permalink":"/dev/docs/reference/ocm-cli/ocm-get-component-version/","summary":"\u003ch2 id=\"ocm-get-component-version\"\u003eocm get component-version\u003c/h2\u003e\n\u003cp\u003eGet component version(s) from an OCM repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGet component version(s) from an OCM repository.\u003c/p\u003e\n\u003cp\u003eThe format of a component reference is:\n[type::]{repository}/[valid-prefix]/{component}[:version]\u003c/p\u003e","tags":[],"title":"ocm get component-version"},{"content":"ocm version Retrieve the build version of the OCM CLI\nSynopsis The version command retrieves the build version of the OCM CLI.\nThe build version can be formatted in different ways depending on the specified format flag. The default format is \u0026ldquo;legacyjson\u0026rdquo;, which outputs the version in a format compatible with OCM v1 specifications, with slight modifications:\n\u0026ldquo;gitTreeState\u0026rdquo; is removed in favor of \u0026ldquo;meta\u0026rdquo; field, which contains the git tree state. \u0026ldquo;buildDate\u0026rdquo; and \u0026ldquo;gitCommit\u0026rdquo; are derived from the input version string, and are parsed according to the go module version specification. When the format is set to \u0026ldquo;gobuildinfo\u0026rdquo;, it outputs the Go build information as a string. The format is standardized and unified across all golang applications.\nWhen the format is set to \u0026ldquo;gobuildinfojson\u0026rdquo;, it outputs the Go build information in JSON format. This is equivalent to \u0026ldquo;gobuildinfo\u0026rdquo;, but in a structured JSON format.\nThe build info by default is drawn from the go module build information, which is set at build time of the CLI. When officially built, it is possibly overwritten with the released version of the OCM CLI.\nocm version [flags]\rExamples ocm version --format legacyjson\rOptions -f, --format string format of the generated documentation (default \u0026#34;legacyjson\u0026#34;) -h, --help help for version\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG_PATH environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ","date":"0001-01-01","id":43,"permalink":"/dev/docs/reference/ocm-cli/ocm-version/","summary":"\u003ch2 id=\"ocm-version\"\u003eocm version\u003c/h2\u003e\n\u003cp\u003eRetrieve the build version of the OCM CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eThe version command retrieves the build version of the OCM CLI.\u003c/p\u003e","tags":[],"title":"ocm version"},{"content":"","date":"0001-01-01","id":44,"permalink":"/dev/","summary":"","tags":[],"title":"Open Component Model"},{"content":"","date":"0001-01-01","id":45,"permalink":"/dev/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"","date":"0001-01-01","id":46,"permalink":"/dev/tags/","summary":"","tags":[],"title":"Tags"},{"content":" How to engage with us # The Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\nGitHub # Our GitHub repositories are the central hub for all project development. Connect with our codebase, report issues, submit pull requests, and follow our project\u0026rsquo;s progress. New contributors can find issues labeled good first issue to get started, and our detailed contribution guidelines will help you make your first successful submission.\nSlack # Join our #open-component-model channel in the Kubernetes Slack workspace and connect with us and other community members.\nKubernetes Slack Membership\nIf you aren\u0026rsquo;t already a member in the Kubernetes Slack workspace, please request an invitation\nOur team is passionate about delving into diverse deployment processes, exploring patterns, aiding in design, and troubleshooting issues. Who knows? Your inquiry might inspire the development of the next useful OCM feature!\nCommunity Calls # We\u0026rsquo;re excited to announce our regular community calls:\nSchedule # Frequency: Every first Wednesday of the months Time: 15:00-16:00 UTC (17:00-18:00 CEST, 11:00-12:00 EDT, 08:00-09:00 PDT) Duration: 1 hour Location: Use this Zoom Link to join the call. iCal (Apple/Outlook) # Download the .ics file to add the community call meeting series to your calendar.\nCall History # This page contains the history of the Open Component Model community calls and links to slides and recordings.\nWhat to Expect # Join us to see and discuss project updates, share your feedback, ask questions, and connect with other community members. The community calls should be an open discussion space and give a voice to any interested stakeholder. At the same time we want our community to be diverse, helpful, collaborative and fun.\nThese calls are open to everyone and will be moderated by at least one OCM Core Maintainer. We will answer anything you might bring up!\nWhat to Bring # We want to hear from you! This is your chance to share your thoughts and ideas with the community. You can bring anything, including:\nIdeas how to make OCM better Issues you would like to talk about and that should be addressed Concepts you would like to work on together Questions you have about the community or upcoming work Contributing # We welcome community contributions! Please see the Contributing Guideline for instructions on how to submit changes. If you are planning on making more elaborate or potentially controversial changes, please discuss them with the maintainers in the Slack channel before sending a pull request.\nCode of Conduct # To make OCM a welcoming and harassment-free experience for everyone, we follow the CNCF Code of Conduct.\nSpecial Interest Groups (SIGs) # OCM grows when people build together — and our Special Interest Groups (SIGs) are where ideas turn into impact.\nSIGs are focused working groups that take ownership of a specific area of the project and move it forward.\nFollowing the example of other CNCF projects, we defined a framework for SIGs to help contributors collaborate effectively.\nThe SIG Handbook covers:\ngoals and motivation behind SIGs roles and responsibilities how to propose, establish, and run a SIG Status: We’re in the kick-off phase — there are no active SIGs yet. That’s your chance to shape the very first ones! As SIGs form, we’ll list them here.\nHow to get involved # Curious? Start with the SIG Handbook. Have a topic in mind? Follow the handbook’s steps to propose a SIG and gather interested contributors. Prefer to join later? Keep an eye on this page — we’ll announce and list new SIGs here. Security Guideline # In case you want to report any security vulnerabilities inside the Open Component Model project, please do not report them through public GitHub issues.\nPlease visit the Open Source Security Policy for more information.\n","date":"0001-01-01","id":47,"permalink":"/dev/community/engagement/","summary":"\u003ch2 id=\"how-to-engage-with-us\"\u003e\n  How to engage with us\n  \u003ca href=\"#how-to-engage-with-us\" class=\"anchor\" aria-hidden=\"true\"\u003e#\u003c/a\u003e\n\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\u003c/p\u003e","tags":[],"title":"The OCM Community"}]