[{"content":"","date":"0001-01-01","id":0,"permalink":"/dev/docs/overview/","summary":"","tags":[],"title":"Overview"},{"content":"The Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It‚Äôs built to support secure, reliable delivery and deployment of software‚Äîacross cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\nBelow are the main projects, but please also check out the others in our Github org.\nOCM Specification - The ocm-spec repository contains the OCM specification, which provides a formal description of OCM and its format to describe software artifacts and a storage layer to persist those and make them accessible from remote. OCM Core Library - The ocm core library contains an API for interacting with OCM elements. A guided tour on how to work with the library can be found here. OCM CLI - With the ocm command line interface end users can interact with OCM elements, helping them create component versions and embed them in CI and CD processes. Examples can be found in this Makefile. OCM Controller - The ocm-controllers are designed to enable the automated deployment of software using the Open Component Model and Flux. OCM Website - The ocm-website you are currently visiting. It is built using Hugo and hosted on Github Pages. ","date":"0001-01-01","id":1,"permalink":"/dev/docs/overview/about-the-ocm-project/","summary":"\u003cp\u003eThe Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It‚Äôs built to support secure, reliable delivery and deployment of software‚Äîacross cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\u003c/p\u003e","tags":[],"title":"About the OCM Project"},{"content":"The Open Component Model (OCM) is an open-source toolset for secure software delivery.\nOCM gives you full visibility and control across the supply chain, streamlining compliance checks, security scans, and deployments. OCM works everywhere ‚Äî cloud, on-premises, hybrid, and air-gapped environments. OCM integrates seamlessly with your existing tools and is easy to extend. With OCM, you gain control, reduce risk, and keep your delivery approach adaptable.\nWhy choose OCM Create a Software Bill of Delivery With OCM, you can describe everything you deliver in a unified, machine-readable format. This enables you to create a Software Bill of Delivery (SBoD). Unlike a Software Bill of Materials (SBOM), which lists all components inside an application, a Software Bill of Delivery focuses on everything you need for a successful deployment ‚Äî including container images, Helm charts, configuration files, and binaries. It is a complete, verifiable record of all deliverables and how to access them.\nProtect Your Supply Chain Security is built into OCM. You can cryptographically sign and verify every component in your supply chain to ensure its integrity or confirm its provenance.\nBeyond signatures, OCM uses immutable, globally unique component identities. These act like tracking IDs, linking all lifecycle phases. They make compliance checks, audits, and vulnerability scans easier and more reliable. With OCM, your software is fully traceable from build to deployment.\nDeploy Anywhere, Even Air-Gapped You can deliver across boundaries and deploy anywhere ‚Äî public cloud, on-premises, or air-gapped environments. OCM separates the identity of software artifacts from their location. Identities remain stable while locations can change as needed. You can store software artifacts in local registries, move them between systems, and work in environments with limited or no internet access ‚Äî all without losing integrity or traceability.\nWorks with Your Existing Tools OCM seamlessly integrates with your current ecosystem. It is compatible with any implementation technology, whether container images, NPM packages, or binaries. You can manage both cloud-native and legacy software without rewriting existing tools or processes.\nAdapts to Your Needs OCM is built for flexibility. Its plugin system lets you extend functionality without changing the core. You can integrate new technologies, customize workflows, and scale from small teams to enterprise environments. OCM ensures that your supply chain remains agile and future-proof.\nCommitted to Open Source OCM has open development and transparent governance. We welcome contributions of any kind. The design of OCM makes it easy to add new features, so anyone can suggest, review, and merge improvements in a transparent way.\nOur commitment to open source goes beyond OCM. We are active members of the open-source community and have maintainers in projects such as kro, Flux, and External Secrets Operator. We believe in open source and work to shape its future.\nTry OCM Out Does OCM sound like the right fit for your project? Check out our Getting Started guides to see how easy a secure delivery can be.\n","date":"0001-01-01","id":2,"permalink":"/dev/docs/overview/benefits-of-ocm/","summary":"\u003cp\u003eThe Open Component Model (OCM) is an open-source toolset for secure software delivery.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOCM gives you full visibility and control across the supply chain, streamlining compliance checks, security scans, and deployments.\u003c/li\u003e\n\u003cli\u003eOCM works everywhere ‚Äî cloud, on-premises, hybrid, and air-gapped environments.\u003c/li\u003e\n\u003cli\u003eOCM integrates seamlessly with your existing tools and is easy to extend.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith OCM, you gain control, reduce risk, and keep your delivery approach adaptable.\u003c/p\u003e","tags":[],"title":"Benefits of OCM"},{"content":"","date":"0001-01-01","id":3,"permalink":"/dev/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"The new major version of the OCM CLI is currently under active development. While we\u0026rsquo;re working on providing pre-built releases through various package managers and distribution channels, the only way to install the OCM CLI right now is to build it from source.\nThis guide will walk you through building the OCM CLI from the source code and configuring the necessary credentials.\nPrerequisites Install Git. Install Task. Install Go (version 1.24 or later). Obtain access to an OCM repository. This can be any OCI registry for which you have write permission (e.g., GitHub Packages). An OCM repository based on an OCI registry is identified by a leading OCI repository prefix. For example: ghcr.io/\u0026lt;YOUR-ORG\u0026gt;/ocm. Build from Source Step 1: Clone the Repository First, clone the OCM repository from GitHub:\ngit clone https://github.com/open-component-model/open-component-model\rStep 2: Navigate to the CLI Directory Change into the CLI directory:\ncd open-component-model/cli\rStep 3: Build the CLI Use the Task build tool to compile the OCM CLI:\ntask build\rAfter the build completes successfully, you should see output similar to:\ntask: [build] ln -sf /path/to/your/open-component-model/cli/tmp/bin/ocm-\u0026lt;os\u0026gt;-\u0026lt;arch\u0026gt; /path/to/your/open-component-model/cli/tmp/bin/ocm\rThe exact path will vary depending on your system and where you cloned the repository.\nUsing the OCM CLI Once the build is complete, you have three options for using the OCM CLI:\nOption 1: Create a Permanent Alias Add an alias to your shell configuration file for permanent access:\nFor Zsh users (~/.zshrc):\necho \u0026#39;alias ocm=\u0026#34;/path/to/your/open-component-model/cli/tmp/bin/ocm\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc\rFor Bash users (~/.bashrc):\necho \u0026#39;alias ocm=\u0026#34;/path/to/your/open-component-model/cli/tmp/bin/ocm\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc\rReplace /path/to/your/ with the actual path where you cloned the repository.\nOption 2: Create a Session Alias For temporary use in your current terminal session:\nalias ocm=\u0026#34;/path/to/your/open-component-model/cli/tmp/bin/ocm\u0026#34;\rOption 3: Use the Full Path You can also run the OCM CLI directly using the full path:\n/path/to/your/open-component-model/cli/tmp/bin/ocm\rVerify Installation To verify that the OCM CLI is working correctly, run:\nocm version\rThis should display the version information and confirm that the installation was successful.\nConfigure the OCM Command Line Client Credentials to be used by the OCM CLI can be configured by supplying it with a configuration file. By default, the CLI looks for the file in $HOME/.ocmconfig.\nUsing the Docker Configuration File The easiest way to configure credentials for the OCM CLI is to reuse an existing Docker configuration json file.\nCreate a file named .ocmconfig in your home directory with the following content:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 # The path to the Docker configuration file dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true - type: attributes.config.ocm.software attributes: cache: ~/.ocm/cache\rUsing Basic Authentication Alternatively, you can use basic authentication. Create a file named .ocmconfig with the following content in your home directory:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: ociRegistry hostname: \u0026lt;YOUR-REGISTRY\u0026gt;/\u0026lt;YOUR-REPO\u0026gt; # e.g. ghcr.io/acme/acme credentials: - type: Credentials properties: username: \u0026lt;YOUR-USERNAME\u0026gt; password: \u0026lt;YOUR-PASSWORD\u0026gt;\rMore information on how to deal with credentials can be found in this guide with many examples for different repository types.\nWindows Support Caution\nWindows support for the OCM CLI is currently best-effort and not guaranteed.\nWhile the CLI is designed to handle Windows-specific conventions such as drive-letter paths (e.g., C:\\path\\to\\archive) and backslash path separators, there is no dedicated Windows CI infrastructure in place to continuously validate these code paths.\nWhat this means Windows builds are cross-compiled and checked for compilation correctness. Windows-specific logic (such as path detection and normalization) might tested via simulated OS behavior on non-Windows runners. There is no runtime testing on actual Windows environments in CI. Bugs specific to Windows runtime behavior may go undetected until reported. Reporting issues If you encounter a Windows-specific issue, please report it at github.com/open-component-model/open-component-model/issues.\nWhat\u0026rsquo;s Next? Now that you have the OCM CLI installed and configured, you can start exploring its capabilities. Check out our Getting Started Guides to learn how to use the OCM CLI to work with your component.\nFuture Installation Methods We\u0026rsquo;re actively working on providing more convenient installation methods, including:\nHomebrew packages Docker images Pre-built binaries for GitHub Releases and more Stay tuned for updates as we continue to improve the installation experience!\n","date":"0001-01-01","id":4,"permalink":"/dev/docs/getting-started/install-the-ocm-cli/","summary":"\u003cp\u003eThe new major version of the OCM CLI is currently under active development. While we\u0026rsquo;re working on providing pre-built releases through various package managers and distribution channels, the only way to install the OCM CLI right now is to \u003cstrong\u003ebuild it from source\u003c/strong\u003e.\u003c/p\u003e","tags":[],"title":"Install the OCM CLI"},{"content":"How It Works Component versions are created using a component-constructor.yaml file, which is a description file that contains one or multiple components. The file describes the components and their artifacts ‚Äì resources and sources, metadata in form of labels, and references to other components.\nComponent versions are locally stored in archives using the Common Transfer Format (CTF). A CTF archive may contain any number of component versions and is used to transfer components to and between component repositories.\nNote that a CTF archive itself is also an OCM repository, so it can be used as source or target for component transfer operations using the OCM CLI.\nThe command ocm add component-version directly creates a component version from a component-constructor.yaml file and stores it in a local CTF archive.\nPrerequisites Install the OCM CLI. Install jq. Create a Component Version In this example, we will use the ocm CLI tool to create a very basic component version that contains a local resource and a resource that is accessed from a remote location. The local resource is an arbitrary file that we will create from scratch the remote resource is a Docker image stored in an OCI registry.\nOCM components can contain any kind of resource, including Helm charts, Docker images, any content from local file systems, and more. Take a look at the tutorial about Input and Access Types to see how to define and use different resource types.\nStart by creating a test folder where we will execute all required steps for this example, and then navigate into it:\nmkdir /tmp/helloworld cd /tmp/helloworld\rQuickly create a simple test file with some content in:\necho \u0026#34;My first local Resource for an OCM component\u0026#34; \u0026gt; my-local-resource.txt\rNow, create a file named component-constructor.yaml:\ntouch component-constructor.yaml\rThe component-constructor.yaml file will define all elements of your component. In our example, the component contains a local file and a remote Docker image as resources.\nTo create the example component, save the following YAML configuration to component-constructor.yaml:\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: - name: github.com/acme.org/helloworld # version needs to follow \u0026#34;relaxed\u0026#34; SemVer version: 1.0.0 provider: name: acme.org resources: # local file resource - name: mylocalfile type: blob input: type: file path: ./my-local-resource.txt # remote image resource - name: image type: ociImage version: 1.0.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.9.4\rYou can use our public configuration schema to validate the configuration. The schema is available at https://ocm.software/schemas/configuration-schema.yaml and can be used in your editor to validate the configuration (e.g., in Visual Studio Code).\nComponent versions need to have at least a name, version and provider attribute. All other attributes are optional. Check out an example component descriptor or the OCM Specification to see all available attributes.\nA resource is described either by its access information to a remote repository or by locally provided resources.\nFor remote access, the field access is used to describe the access method. The type field is used to specify the kind of access.\nIf the resource content is taken from local resources, the field input is used to specify the access to the local resources. Similarly to the access attribute, the kind of the input source is described by the field type.\nAvailable access and input types are described in the tutorial about Input and Access Types.\nAdd a Component Version to a CTF Archive To store our component version locally and to make it transportable, add it to a CTF archive using the following command:\nocm add component-version\ror the short form (which we will use from now on):\nocm add cv\rThis is the most basic form of the command. When executed, the OCM CLI defaults the constructor file name to component-constructor.yaml and the CTF archive name to transport-archive. If the CTF archive doesn‚Äôt exist yet, it will be created automatically.\nIf you want to specify a different constructor file name or CTF archive name, you can use the --constructor and --repository flags.\nocm add cv --repository /path/to/my-own-ctf -c /path/to/my-component-constructor.yaml\rIf the component version was created successfully, you will see the following output:\n... component github.com/acme.org/helloworld/1.0.0 constructed ... done! [1 component version in 482ms]\rWhat happened? The command created a CTF archive and added the listed components with the described resources.\ntree transport-archive transport-archive ‚îú‚îÄ‚îÄ artifact-index.json ‚îî‚îÄ‚îÄ blobs ‚îú‚îÄ‚îÄ sha256.096322a7affa6a26a4549e347399f835b2350454946b4967ffdc570dbed78066 ‚îú‚îÄ‚îÄ sha256.70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8 ‚îú‚îÄ‚îÄ sha256.74db132670ec370396ec10160c4e761591d0e9e6c5960c72d2e26c0f9d6f6a76 ‚îî‚îÄ‚îÄ sha256.c8359dfaa6353b1b3166449f7ff3a8ef6f1d3a6c6f837cca9cd2ad7e8ef8546e 2 directories, 5 files\rThe transport archive\u0026rsquo;s contents can be found in artifact-index.json. This file contains the list of component version artifacts to be transported.\njq . transport-archive/artifact-index.json\r{ \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;artifacts\u0026#34;: [ { \u0026#34;repository\u0026#34;: \u0026#34;component-descriptors/github.com/acme.org/helloworld\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:c8359dfaa6353b1b3166449f7ff3a8ef6f1d3a6c6f837cca9cd2ad7e8ef8546e\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34; } ] }\rThe content of the transport archive is stored as OCI artifacts. Notice that the repository name of component version artifacts (found at artifacts.respository) are prefixed by component-descriptors/.\nThe component version is described as an OCI manifest, including OCM specific annotations.\njq . transport-archive/blobs/sha256.c8359dfaa6353b1b3166449f7ff3a8ef6f1d3a6c6f837cca9cd2ad7e8ef8546e\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;artifactType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software/ocm.component.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:096322a7affa6a26a4549e347399f835b2350454946b4967ffdc570dbed78066\u0026#34;, \u0026#34;size\u0026#34;: 201 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:74db132670ec370396ec10160c4e761591d0e9e6c5960c72d2e26c0f9d6f6a76\u0026#34;, \u0026#34;size\u0026#34;: 3072 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;text/plain; charset=utf-8\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8\u0026#34;, \u0026#34;size\u0026#34;: 45, \u0026#34;annotations\u0026#34;: { \u0026#34;software.ocm.artifact\u0026#34;: \u0026#34;[{\\\u0026#34;identity\\\u0026#34;:{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;mylocalfile\\\u0026#34;,\\\u0026#34;version\\\u0026#34;:\\\u0026#34;1.0.0\\\u0026#34;},\\\u0026#34;kind\\\u0026#34;:\\\u0026#34;resource\\\u0026#34;}]\u0026#34; } } ], \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.authors\u0026#34;: \u0026#34;CTF Repository\u0026#34;, \u0026#34;org.opencontainers.image.description\u0026#34;: \u0026#34;\\nThis is an OCM OCI Artifact Manifest that contains the component descriptor for the component github.com/acme.org/helloworld.\\nIt is used to store the component descriptor in an OCI registry and can be referrenced by the official OCM Binding Library.\\n\u0026#34;, \u0026#34;org.opencontainers.image.documentation\u0026#34;: \u0026#34;https://ocm.software\u0026#34;, \u0026#34;org.opencontainers.image.source\u0026#34;: \u0026#34;https://github.com/open-component-model/open-component-model\u0026#34;, \u0026#34;org.opencontainers.image.title\u0026#34;: \u0026#34;OCM Component Descriptor OCI Artifact Manifest for github.com/acme.org/helloworld in version 1.0.0\u0026#34;, \u0026#34;org.opencontainers.image.url\u0026#34;: \u0026#34;https://ocm.software\u0026#34;, \u0026#34;org.opencontainers.image.version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;software.ocm.componentversion\u0026#34;: \u0026#34;component-descriptors/github.com/acme.org/helloworld:1.0.0\u0026#34;, \u0026#34;software.ocm.creator\u0026#34;: \u0026#34;CTF Repository\u0026#34; } }\rNotice that the output of the component version above contains the component descriptor as one of the layers. It can be identified by its media type, which is application/vnd.ocm.software.component-descriptor.v2+yaml+tar. Since it is saved in tar format, it can be displayed using the following command:\ntar xvf transport-archive/blobs/sha256.74db132670ec370396ec10160c4e761591d0e9e6c5960c72d2e26c0f9d6f6a76 -O\rcomponent-descriptor.yaml\ncomponent: componentReferences: null name: github.com/acme.org/helloworld provider: acme.org repositoryContexts: null resources: - access: localReference: sha256:70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8 mediaType: text/plain; charset=utf-8 type: localBlob/v1 digest: hashAlgorithm: SHA-256 normalisationAlgorithm: genericBlobDigest/v1 value: 70a2577d7b649574cbbba99a2f2ebdf27904a4abf80c9729923ee67ea8d2d9d8 name: mylocalfile relation: local type: blob version: 1.0.0 - access: imageReference: ghcr.io/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb type: ociArtifact digest: hashAlgorithm: SHA-256 normalisationAlgorithm: genericBlobDigest/v1 value: 262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb name: image relation: external type: ociImage version: 1.0.0 sources: null version: 1.0.0 meta: schemaVersion: v2\rThe other elements listed as layers describe the blobs for the local resources stored along with the component version. The digests can be seen in the localReference attributes of the component descriptor.\nExamine Component Versions To view a component version stored in an OCM repository or CTF archive (which is technically also an OCM repository), you can use the ocm get component-version command:\nocm get cv /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0\rCOMPONENT ‚îÇ VERSION ‚îÇ PROVIDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ github.com/acme.org/helloworld ‚îÇ 1.0.0 ‚îÇ acme.org\rNotice the format of the specified component version: The component path starts with the OCM repository prefix (/tmp/helloworld/transport-archive), followed by //, then the component name and version (github.com/acme.org/helloworld:1.0.0).\nTo list all versions of a component, only specify the component name and skip the version. Let us view all versions of the component with the name ocm.software/demos/podinfo, which is stored in the the OCM repository ghcr.io/open-component-model:\nocm get cv ghcr.io/open-component-model//ocm.software/demos/podinfo\rCOMPONENT ‚îÇ VERSION ‚îÇ PROVIDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ocm.software/demos/podinfo ‚îÇ 6.8.0 ‚îÇ ocm.software ‚îÇ 6.7.1 ‚îÇ ‚îÇ 6.7.0 ‚îÇ To get the component descriptor of that component version, use the output format option -o yaml:\nocm get cv /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0 -o yaml\rUnder Construction\nThe following options are currently being implemented from scratch and are not yet available:\n--recursive: shows the complete component version, including the component versions it references -o tree: outputs a tree view Stay tuned for updates!\n","date":"0001-01-01","id":5,"permalink":"/dev/docs/getting-started/create-and-examine-component-versions/","summary":"\u003ch2 id=\"how-it-works\"\u003eHow It Works\u003c/h2\u003e\n\u003cp\u003eComponent versions are created using a \u003ccode\u003ecomponent-constructor.yaml\u003c/code\u003e file, which is a description file that contains one or multiple components. The file describes the components and their artifacts ‚Äì resources and sources, metadata in form of labels, and references to other components.\u003c/p\u003e","tags":[],"title":"Create and Examine Component Versions"},{"content":"Prerequisites Install the OCM CLI. Install jq. Download Resources from a Component Version Use the ocm download resources command to download specific resources from a component version.\nIn this example, we download the resource with the name chart from the component ocm.software/demos/podinfo with version 6.8.0, which is stored in the the OCM repository ghcr.io/open-component-model:\nocm download resource ghcr.io/open-component-model//ocm.software/demos/podinfo:6.8.0 --identity name=chart --output helmchart.tgz\r... time=2025-08-14T13:03:54.372+02:00 level=INFO msg=\u0026#34;resource downloaded successfully\u0026#34; output=helmchart.tgz\rBecause it is stored as an OCI artifact in an OCI registry, the filesystem format used for OCI artifacts is the blob format.\nWhat happened? The file helmchart.tgz was downloaded.\ntar xvf helmchart.tgz\rblobs/sha256/ea8e5b44cd1aff1f3d9377d169ad795be20fbfcd58475a62341ed8fb74d4788c blobs/sha256/8702d8d550075e410f3aae545d1191df9e5ab8747e5c5a8eda5ed834fd135366 blobs/sha256/8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2 index.json oci-layout\rUnder Construction\nThe file permissions and ownership may not be preserved when extracting the archive. This needs to be fixed. Currently, you have to add at least read permissions to continue: chmod +r index.json\njq . index.json\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2\u0026#34;, \u0026#34;size\u0026#34;: 410, \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.ref.name\u0026#34;: \u0026#34;ghcr.io/open-component-model/ocm/ocm.software/toi/demo/helmdemo/echoserver:0.1.0@sha256:8ab41f82c9a28535f1add8ffbcd6d625a19ece63c4e921f9c8358820019d1ec2\u0026#34; } } ] }\rDownload Using Transformers Under Construction\nTransformers are currently in development. We\u0026rsquo;ll extend the below section once they are ready to be used. Until then, you can check out the Transformer ADR\nTo use a format more suitable for the content technology, you can use the --transformer flag to specify a transformer. The transformer will take care that the file is saved using its correct media type. For example, a Helm chart will be saved as a .tgz file, which on extraction will show the complete chart.\nocm download resource ghcr.io/open-component-model//ocm.software/demos/podinfo:6.8.0 chart --identity name=chart --output helmchart.tgz --transformer helm\rhelmchart.tgz: 3763 byte(s) written\rWhat happened? The downloaded archive is now a regular Helm Chart archive:\ntar tvf helmchart.tgz\r-rw-r--r-- 0 0 0 136 Jul 19 16:32 echoserver/Chart.yaml -rw-r--r-- 0 0 0 1842 Jul 19 16:32 echoserver/values.yaml -rw-r--r-- 0 0 0 1755 Jul 19 16:32 echoserver/templates/NOTES.txt -rw-r--r-- 0 0 0 1802 Jul 19 16:32 echoserver/templates/_helpers.tpl -rw-r--r-- 0 0 0 1848 Jul 19 16:32 echoserver/templates/deployment.yaml -rw-r--r-- 0 0 0 922 Jul 19 16:32 echoserver/templates/hpa.yaml -rw-r--r-- 0 0 0 2083 Jul 19 16:32 echoserver/templates/ingress.yaml -rw-r--r-- 0 0 0 367 Jul 19 16:32 echoserver/templates/service.yaml -rw-r--r-- 0 0 0 324 Jul 19 16:32 echoserver/templates/serviceaccount.yaml -rw-r--r-- 0 0 0 385 Jul 19 16:32 echoserver/templates/tests/test-connection.yaml -rw-r--r-- 0 0 0 349 Jul 19 16:32 echoserver/.helmignore\r","date":"0001-01-01","id":6,"permalink":"/dev/docs/getting-started/download-resources-from-component-versions/","summary":"\u003ch2 id=\"prerequisites\"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/install-the-ocm-cli/\"\u003eInstall the OCM CLI\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eInstall \n\n\n\n\n\n\n\u003ca href=\"https://jqlang.org/\" target=\"_blank\" rel=\"noopener\"\u003ejq\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"download-resources-from-a-component-version\"\u003eDownload Resources from a Component Version\u003c/h2\u003e\n\u003cp\u003eUse the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-resource/\"\u003e\u003ccode\u003eocm download resources\u003c/code\u003e\u003c/a\u003e command to download specific resources from a component version.\u003c/p\u003e","tags":[],"title":"Download Resources from Component Versions"},{"content":"Signing ensures the authenticity and integrity of component versions in OCM.\nPrerequisites Install the OCM CLI. Get a key pair (private + public key). Don\u0026rsquo;t have a key pair yet? Follow our guide: Key Pair Generation. To follow the examples, you need the component version from the guide Create and Examine Component Versions. Minimal .ocmconfig for Signing Add the following to your .ocmconfig file. If the file is present in your home directory (~/.ocmconfig), the OCM CLI will use it by default.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: default credentials: - type: Credentials/v1 properties: private_key_pem_file: \u0026#34;\u0026lt;path-to-your-private-key\u0026gt;\u0026#34;\rReplace \u0026lt;path-to-your-private-key\u0026gt; with the corresponding path. If you followed the Key Pair Generation guide, you can use the path ~/.ocm/keys/dev/private.pem.\nThe identity attributes define the consumer type for RSA signing:\ntype must be RSA/v1alpha1 for RSA-based signing. algorithm specifies the signing algorithm (RSASSA-PSS is recommended, RSASSA-PKCS1V15 is legacy). signature specifies the signature name/label for this configuration (default is default). The credentials properties contain the actual key material:\nprivate_key_pem_file is the path to a private key file in PEM format. Sign a Component Version An .ocmconfig file can contain multiple signature profiles which can be specified during signing using the --signature option.\nIf no signature is specified, the signature named default will be looked up in the .ocmconfig and used for signing.\nLet\u0026rsquo;s sign the component we created earlier in the Create a Component Version section, assuming you used the default name for the CTF:\nocm sign cv /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0 --config \u0026lt;path-to-your-.ocmconfig\u0026gt;\rThis command signs the specified component version and stores the signature in the repository:\ndigest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v4alpha1 value: a7d15e55e5a9d6c988b73983270d04a33b1b133aa77bd486f4b22f052615fd90 name: default signature: algorithm: RSASSA-PSS mediaType: application/vnd.ocm.signature.rsa.pss value: 57cfd281dc43fdba5d73547aed13226c2358b3bfbc6c600dd42e80144cb944faf4c...\rWhen looking at the component descriptor, we can also see the new signature entry at the end of the descriptor:\nocm get cv /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0 -oyaml\r- component: componentReferences: null name: github.com/acme.org/helloworld provider: acme.org repositoryContexts: null resources: - access: localReference: sha256:f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2 mediaType: text/plain; charset=utf-8 type: localBlob/v1 digest: hashAlgorithm: SHA-256 normalisationAlgorithm: genericBlobDigest/v1 value: f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2 name: mylocalfile relation: local type: blob version: 1.0.0 - access: imageReference: ghcr.io/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb type: ociArtifact digest: hashAlgorithm: SHA-256 normalisationAlgorithm: genericBlobDigest/v1 value: 262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb name: image relation: external type: ociImage version: 1.0.0 sources: null version: 1.0.0 meta: schemaVersion: v2 signatures: - digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v4alpha1 value: a7d15e55e5a9d6c988b73983270d04a33b1b133aa77bd486f4b22f052615fd90 name: default signature: algorithm: RSASSA-PSS mediaType: application/vnd.ocm.signature.rsa.pss value: 57cfd281dc43fdba5d73547aed13226c2358b3bfbc6c600dd42e8014...\rReplace an Existing Signature In case you want to replace an existing signature, use the --force flag. Otherwise you will get an error like Error: signature \u0026quot;default\u0026quot; already exists.\nocm sign cv /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0 --force\r‚ö†Ô∏è Only overwrite signatures if you are sure no other process relies on the existing one.\nMultiple Signatures (Multi-Environment) For multi-environment setups, you can use named signatures. Configure different keys in .ocmconfig:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 signature: dev credentials: - type: Credentials/v1 properties: private_key_pem_file: \u0026#34;\u0026lt;path-to-the-first-private-key\u0026gt;\u0026#34; - identity: type: RSA/v1alpha1 signature: prod credentials: - type: Credentials/v1 properties: private_key_pem_file: \u0026#34;\u0026lt;path-to-the-second-private-key\u0026gt;\u0026#34;\rReplace \u0026lt;path-to-the-first-private-key\u0026gt; and \u0026lt;path-to-the-second-private-key\u0026gt; with the corresponding paths. If you followed the Key Pair Generation guide, you can use the following paths:\n~/.ocm/keys/dev/private.pem for the dev signature ~/.ocm/keys/prod/private.pem for the prod signature Then sign with the appropriate signature name:\n# Sign for development ocm sign cv --signature dev /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0 # Sign for production ocm sign cv --signature prod /tmp/helloworld/transport-archive//github.com/acme.org/helloworld:1.0.0\rSee the Multi-Environment Configuration section for complete examples.\nTroubleshooting For support with common issues, see the Troubleshooting section of the Signing and Verification guide.\n","date":"0001-01-01","id":7,"permalink":"/dev/docs/getting-started/sign-component-versions/","summary":"\u003cp\u003eSigning ensures the \u003cstrong\u003eauthenticity\u003c/strong\u003e and \u003cstrong\u003eintegrity\u003c/strong\u003e of component versions in OCM.\u003c/p\u003e\n\u003ch2 id=\"prerequisites\"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/install-the-ocm-cli/\"\u003eInstall the OCM CLI\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eGet a key pair (private + public key). Don\u0026rsquo;t have a key pair yet? Follow our guide: \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/tutorials/signing-and-verification/#key-pair-generation\"\u003eKey Pair Generation\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eTo follow the examples, you need the component version from the  guide \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/create-and-examine-component-versions/\"\u003eCreate and Examine Component Versions\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"minimal-ocmconfig-for-signing\"\u003eMinimal .ocmconfig for Signing\u003c/h2\u003e\n\u003cp\u003eAdd the following to your \u003ccode\u003e.ocmconfig\u003c/code\u003e file. If the file is present in your home directory (\u003ccode\u003e~/.ocmconfig\u003c/code\u003e), the OCM CLI will use it by default.\u003c/p\u003e","tags":[],"title":"Sign Component Versions"},{"content":"Verifying a component version ensures that a signature was created by a trusted key and that the component descriptor has not been modified.\nPrerequisites Install the OCM CLI. You need a signed component version and the public key for the signature. The following examples use the signed component version from the Sign Component Versions guide. Minimal .ocmconfig for Verification To verify a signature, OCM needs a public key.\nWe recommend referring to key files rather than embedding PEM blocks directly.\nAdd the following to your .ocmconfig. If the file is present in your home directory (~/.ocmconfig), the OCM CLI will use it by default.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: default credentials: - type: Credentials/v1 properties: public_key_pem_file: \u0026#34;\u0026lt;path-to-your-public-key\u0026gt;\u0026#34;\rReplace \u0026lt;path-to-your-public-key\u0026gt; with the corresponding path. If you followed the Key Pair Generation guide, you can use the path ~/.ocm/keys/dev/public.pem.\nThe identity attributes define the consumer type for RSA verification:\ntype must be RSA/v1alpha1 for RSA-based verification. algorithm specifies the signing algorithm (RSASSA-PSS is recommended, RSASSA-PKCS1V15 is legacy). signature specifies the signature name/label for this configuration (default is default). The credentials properties contain the actual key material:\npublic_key_pem_file is the path to a public key file in PEM format. üí° Path Consistency: Use the same directory structure as for signing.\nIf you signed with ~/.ocm/keys/dev/private.key, verify with ~/.ocm/keys/dev/public.pem.\nVerify a Component Version Assuming you created and signed a component version in the previous steps, you can verify it with:\nocm verify cv transport-archive//github.com/acme.org/helloworld:1.0.0\rIf the signature matches the public key specified in the default signature, the OCM CLI prints a verification success message and exits with status code 0.\ntime=2025-11-19T15:58:22.421+01:00 level=INFO msg=\u0026#34;no resolvers configured, using component reference as resolver\u0026#34; time=2025-11-19T15:58:22.421+01:00 level=INFO msg=\u0026#34;Resolving credentials via repository\u0026#34; identity=\u0026#34;path=transport-archive,type=OCIRepository\u0026#34; config=DockerConfig/v1(~/.docker/config.json) time=2025-11-19T15:58:22.425+01:00 level=INFO msg=\u0026#34;fetching descriptor\u0026#34; descriptor.mediaType=application/vnd.oci.image.manifest.v1+json descriptor.digest=sha256:a01d26fdfde80d01b725d92a2c6aefe0a34ec1a98935e8fae13b422e816054f0 descriptor.size=1418 time=2025-11-19T15:58:22.431+01:00 level=INFO msg=\u0026#34;no verifier specification file given, using default RSASSA-PSS\u0026#34; time=2025-11-19T15:58:22.431+01:00 level=INFO msg=\u0026#34;verifying signature\u0026#34; name=default time=2025-11-19T15:58:22.435+01:00 level=INFO msg=\u0026#34;signature verification completed\u0026#34; name=default duration=4.287541ms time=2025-11-19T15:58:22.435+01:00 level=INFO msg=\u0026#34;SIGNATURE VERIFICATION SUCCESSFUL\u0026#34;\rVerify a Specific Signature Name If your component contains multiple signatures (e.g., dev, prod), you can explicitly specify the signature for verification. Your .ocmconfig must contain the corresponding public key for that signature. OCM then selects the credentials associated with the specified signature.\n# Verify specific signature ocm verify cv --signature dev transport-archive//github.com/acme.org/helloworld:1.0.0\rMultiple Signatures (Multi-Environment) For multi-environment setups with multiple different keys:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 signature: dev credentials: - type: Credentials/v1 properties: public_key_pem_file: \u0026#34;\u0026lt;path-to-the-first-public-key\u0026gt;\u0026#34; - identity: type: RSA/v1alpha1 signature: prod credentials: - type: Credentials/v1 properties: public_key_pem_file: \u0026#34;\u0026lt;path-to-the-first-public-key\u0026gt;\u0026#34;\rReplace \u0026lt;path-to-the-first-public-key\u0026gt; and \u0026lt;path-to-the-second-public-key\u0026gt; with the corresponding paths. If you followed the Key Pair Generation guide, you can use the following paths:\n~/.ocm/keys/dev/public.pem for the dev signature ~/.ocm/keys/prod/cert-chain.pem for the prod signature Then verify the appropriate signature:\n# Verify development signature ocm verify cv --signature dev transport-archive//github.com/acme.org/helloworld:1.0.0 # Verify production signature ocm verify cv --signature prod transport-archive//github.com/acme.org/helloworld:1.0.0\rCommon Issues Verification fails?\nEnsure the public key matches the signature. Check that you\u0026rsquo;re verifying the correct signature name. Verify the component hasn\u0026rsquo;t been modified after signing. Public key not found?\nCheck the file path in public_key_pem_file and the signature profile. Wrong signature name?\nList signatures: ocm get cv ... --signatures. Use --signature \u0026lt;name\u0026gt; to specify the correct signature. Need more help?\nSee Troubleshooting. ","date":"0001-01-01","id":8,"permalink":"/dev/docs/getting-started/verify-component-versions/","summary":"\u003cp\u003eVerifying a component version ensures that a signature was created by a trusted key and that the component descriptor has not been modified.\u003c/p\u003e","tags":[],"title":"Verify Component Versions"},{"content":"This document describes how to set up a local environment for running examples from the Deploy a Helm Chart guide. You will create a local Kubernetes cluster with kind and then install kro, Flux, and the OCM controllers.\nPrerequisites Install kubectl. Install kind. Install Git. Install Task. Start a Local Kubernetes Cluster With kind You don\u0026rsquo;t need to run kind if you are using a remote Kubernetes cluster you have access to. If so, you can skip this.\nCreate a local kind cluster:\nkind create cluster\rInstall kro Please follow the official installation guides for kro. You might need helm to install kro.\nVerify the installation:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h28m ... Install a Deployer Currently, we created our examples and getting-started guides using Flux as deployer. But, in theory, you could use any other deployer that is able to apply a deployable resource to a Kubernetes cluster, for instance Argo CD.\nTo install the Flux CLI, please follow the official installation guide. After you have installed the CLI tool, you can proceed with the steps below.\nInstall the Flux controllers:\nflux install\rVerify the installation:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... flux-system helm-controller-b6767d66-zbwws 1/1 Running 0 3h29m flux-system kustomize-controller-57c7ff5596-v6fvr 1/1 Running 0 3h29m flux-system notification-controller-58ffd586f7-pr65t 1/1 Running 0 3h29m flux-system source-controller-6ff87cb475-2h2lv 1/1 Running 0 3h29m ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h28m ... Install the OCM Controllers Install the OCM controllers with one of the following commands:\nhelm install ocm-k8s-toolkit oci://ghcr.io/open-component-model/charts/ocm-k8s-toolkit \\ --namespace ocm-k8s-toolkit-system \\ --create-namespace\rFor local development, you can install directly from the source:\n# In the ocm mono-repo root directory cd kubernetes/controller task helm/install\rVerify the installation:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... flux-system helm-controller-b6767d66-zbwws 1/1 Running 0 3h39m flux-system kustomize-controller-57c7ff5596-v6fvr 1/1 Running 0 3h39m flux-system notification-controller-58ffd586f7-pr65t 1/1 Running 0 3h39m flux-system source-controller-6ff87cb475-2h2lv 1/1 Running 0 3h39m ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h38m ... ocm-k8s-toolkit-system ocm-k8s-toolkit-controller-manager-788f58d4bd-ntbx8 1/1 Running 0 57s ... Get Access to a Registry As all examples and guides will create an OCM component version that will be consumed by the OCM controllers, you will need access to a registry. You can either choose a public registry like ghcr.io or deploy a registry (like registry, zot, \u0026hellip;) into your Kubernetes cluster.\nIf you choose to deploy a registry into your Kubernetes cluster, you have to make sure it is accessible from outside the cluster (for ocm transfer to work) and inside the cluster (for the OCM controllers to work).\nWe strongly recommend to use a registry that is publicly accessible, like ghcr.io. (Deploying your own registry requires a lot of additional configuration. Especially, if you want to try out the localization example, you will need to configure a registry that is accessible with the same address from your CLI, kubelet, and inside the cluster.)\nIf you completed all of the above steps, you are ready to go. You can now start with the Deploy a Helm Chart guide or play around with the examples in the examples/ directory on GitHub.\n","date":"0001-01-01","id":9,"permalink":"/dev/docs/getting-started/set-up-an-ocm-controller-environment/","summary":"\u003cp\u003eThis document describes how to set up a local environment for running examples from the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/deploy-helm-charts/\"\u003eDeploy a Helm Chart\u003c/a\u003e guide. You will create a local Kubernetes cluster with kind and then install kro, Flux, and the OCM controllers.\u003c/p\u003e","tags":[],"title":"Set Up an OCM Controller Environment"},{"content":"This guide demonstrates how to deploy a Helm chart from an OCM component version using OCM controllers, kro, and Flux.\nFor the following example, it is assumed that a developer created an application, packaged it as a Helm chart, and publishes it as OCM component version in an OCI registry. Then, an operator who wants to deploy the application via Helm chart in a Kubernetes cluster, creates a ResourceGraphDefinition with resources that point to the OCM component version. Using CEL expressions inside the ResourceGraphDefinition, the information about the resource location will be passed to Flux, which will then configure the Helm chart and deploy it into the Kubernetes cluster.\nPrerequisites Install the OCM CLI. Set up an OCM controller environment. Create the OCM Component Version First, we will create an OCM component version containing a Helm chart. For this example, we will use the podinfo Helm chart, which is a simple web application that serves a pod information page. For more details on how to create an OCM component version, please refer to the OCM documentation.\nTo create the OCM component version, we will use the following component-constructor.yaml file:\ncomponents: - name: ocm.software/ocm-k8s-toolkit/simple provider: name: ocm.software version: \u0026#34;1.0.0\u0026#34; resources: - name: helm-resource type: helmChart version: 1.0.0 access: type: ociArtifact imageReference: \u0026#34;ghcr.io/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a\u0026#34;\rAfter creating the file, we can create the OCM component version:\nocm add componentversion --create --file ./ctf component-constructor.yaml\rThis will create a local CTF (Component Transfer Format) directory ./ctf containing the OCM component version. Since the OCM component version must be accessible for the OCM controllers, we will transfer the CTF to a registry. For this example, we will use GitHub\u0026rsquo;s container registry, but you can use any OCI registry:\nocm transfer ctf ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rIf you are using a registry that requires authentication, you need to provide credentials for ocm. Please refer to the OCM CLI credentials documentation for more information on how to set up and use credentials.\nIf everything went well, you should see the following output:\nocm get component-version ghcr.io/\u0026lt;your-namespace\u0026gt;//ocm.software/ocm-k8s-toolkit/simple:1.0.0\rCOMPONENT VERSION PROVIDER ocm.software/ocm-k8s-toolkit/simple 1.0.0 ocm.software Deploy the Helm Chart To deploy the Helm chart from the OCM component version, we will first create a ResourceGraphDefinition that contains all required resources. Additionally, we will add a configuration to the HelmRelease resource that can be passed through the instance of that ResourceGraphDefinition. After the ResourceGraphDefinition is created and applied, we create the instance of the ResourceGraphDefinition that will deploy the Helm chart.\nCreate and Apply the ResourceGraphDefinition The ResourceGraphDefinition is a custom resource that defines all the resources that should be applied. To proceed with the example, create a file named rgd.yaml and add the following content:\napiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: simple spec: schema: apiVersion: v1alpha1 # The name of the CRD that is created by this ResourceGraphDefinition when applied kind: Simple spec: # This spec defines values that can be referenced in the ResourceGraphDefinition and that can be set in the # instances of this ResourceGraphDefinition. # We will use it to pass a value to the Helm chart and configure the message the application shows # (see resource HelmRelease). message: string | default=\u0026#34;foo\u0026#34; resources: # Repository points to the OCM repository in which the OCM component version is stored and checks if it is # reachable by pinging it. - id: repository template: apiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: simple-repository spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # Component refers to the Repository, downloads and verifies the OCM component version descriptor. - id: component template: apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: simple-component spec: repositoryRef: name: ${repository.metadata.name} component: ocm.software/ocm-k8s-toolkit/simple semver: 1.0.0 interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # Resource points to the Component, downloads the resource passed by reference-name and verifies it. It then # publishes the location of the resource in its status. - id: resourceChart template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: simple-resource spec: componentRef: name: ${component.metadata.name} resource: byReference: resource: name: helm-resource # This must match the resource name set in the OCM component version (see above) additionalStatusFields: # The additional status fields are useful for splitting the imageReference into its components, so that # they can be used in depending deployers # Example: ghcr.io/stefanprodan/charts/podinfo:6.7.1 would be # registry: ghcr.io # repository: stefanprodan/charts/podinfo # reference/tag: 6.7.1 registry: resource.access.imageReference.toOCI().registry repository: resource.access.imageReference.toOCI().repository tag: resource.access.imageReference.toOCI().tag interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # OCIRepository watches and downloads the resource from the location provided by the Resource status. # The Helm chart location (url) refers to the status of the above resource. - id: ocirepository template: apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: simple-ocirepository spec: interval: 1m0s layerSelector: mediaType: \u0026#34;application/vnd.cncf.helm.chart.content.v1.tar+gzip\u0026#34; operation: copy url: oci://${resourceChart.status.additional.registry}/${resourceChart.status.additional.repository} ref: tag: ${resourceChart.status.additional.tag} # secretRef is required, if the OCI repository requires credentials to access it. # secretRef: # HelmRelease refers to the OCIRepository, lets you configure the Helm chart and deploys the Helm chart into the # Kubernetes cluster. - id: helmrelease template: apiVersion: helm.toolkit.fluxcd.io/v2 kind: HelmRelease metadata: name: simple-helmrelease spec: releaseName: simple interval: 1m timeout: 5m chartRef: kind: OCIRepository name: ${ocirepository.metadata.name} namespace: default values: # We configure the Helm chart using FluxCDs HelmRelease \u0026#39;values\u0026#39; field. We pass the value that we set in # the instance of the CRD created by the ResourceGraphDefinition (see below). ui: message: ${schema.spec.message}\rIf you pushed the OCM component version to a private registry, you need to set up the credentials for the OCM controller resources. You can do this by uncommenting the ocmConfig fields in the Repository, Component, and Resource resources and providing the necessary credentials. For more information on how to set up and pass the credentials, please check out the guide configure credentials for OCM controller resources.\nBe aware that FluxCD\u0026rsquo;s OCIRepository also needs access to the OCI registry that contains the Helm chart. However, OCIRepository only accepts imagePullSecrets in the same namespace. If you want to use the same credentials for FluxCD and for the OCM controller resources, create a Kubernetes secret of type dockerconfigjson and keep all the resources in the same namespace.\nAfter creating the file rgd.yaml with the above content and adjusting Repository\u0026rsquo;s baseUrl to point to your OCM repository, you can apply the ResourceGraphDefinition to your Kubernetes cluster:\nkubectl apply -f rgd.yaml\rIf everything went well, you should see the following output:\nkubectl get rgd\rNAME APIVERSION KIND STATE AGE simple v1alpha1 Simple Active 19s This creates a Kubernetes Custom Resource Definition (CRD) Simple that can be used to create instances. An applied instance of the CRD will create all resources defined in the ResourceGraphDefinition.\nCreate an Instance of Simple To create an instance of the Simple CRD, create a file named instance.yaml and add the following content:\napiVersion: kro.run/v1alpha1 # Kind is the CRD name that was created by the ResourceGraphDefinition kind: Simple metadata: name: simple spec: # This field is passed to the Helm chart and configures the message that podinfo will show message: \u0026#34;bar\u0026#34;\rProceed by applying the instance which will create all the resources defined in the ResourceGraphDefinition:\nkubectl apply -f instance.yaml\rThis will take some time, but if everything went well, you should see the following output:\nkubectl get simple\rNAME STATE SYNCED AGE simple ACTIVE True 5m28s and the deployment should be in the state Available:\nkubectl get deployments\rNAME READY UP-TO-DATE AVAILABLE AGE simple-podinfo 1/1 1 1 40m To make sure that the deployment was configured successfully, take a look at the pod itself or execute the following command:\nkubectl get pods -l app.kubernetes.io/name=simple-podinfo -o jsonpath=\u0026#39;{.items[0].spec.containers[0].env[?(@.name==\u0026#34;PODINFO_UI_MESSAGE\u0026#34;)].value}\u0026#39;\rwhich should return the value you passed in the instance:\nbar You now have successfully created an OCM component version containing a Helm chart and deployed as well as configured it using the OCM controllers, kro, and FluxCD.\nTroubleshooting One common issue, when using GitHub\u0026rsquo;s container registry, is that the transferred OCM component is by default a private package. If so, you might see an error like the following:\nfailed to list versions: failed to list tags: GET \u0026#34;https://ghcr.io/v2...\u0026#34;: response status code 401: unauthorized: authentication required You can resolve this issue by making the package public or by providing credentials to the respective resources.\n","date":"0001-01-01","id":10,"permalink":"/dev/docs/getting-started/deploy-helm-charts/","summary":"\u003cp\u003eThis guide demonstrates how to deploy a Helm chart from an OCM component version using OCM controllers, \n\n\n\n\n\n\n\u003ca href=\"https://kro.run/\" target=\"_blank\" rel=\"noopener\"\u003ekro\u003c/a\u003e, and \n\n\n\n\n\n\n\u003ca href=\"https://fluxcd.io/\" target=\"_blank\" rel=\"noopener\"\u003eFlux\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor the following example, it is assumed that a developer created an application, packaged it as a Helm\nchart, and publishes it as OCM component version in an OCI registry. Then, an operator who wants to deploy the\napplication via Helm chart in a Kubernetes cluster, creates a \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e with resources that point to\nthe OCM component version. Using CEL expressions inside the \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e, the information about the\nresource location will be passed to Flux, which will then configure the Helm chart and deploy it into the Kubernetes\ncluster.\u003c/p\u003e","tags":[],"title":"Deploy Helm Charts"},{"content":"","date":"0001-01-01","id":11,"permalink":"/dev/docs/concepts/","summary":"","tags":[],"title":"Concepts"},{"content":"In OCM, components group a set of semantically related component versions. Each component version is uniquely and globally identified by a component identity and can reference other components. A component version can also contain artifacts and a formal description of how to access them. These artifacts come in two categories: resources, which describe the payload (e.g., OCI images), and sources, which describe the input for creating resources (e.g., source code).\nFor a detailed exploration of OCM components and other key elements of the Open Component Model, please refer to the OCM Specification and its Glossary.\n","date":"0001-01-01","id":12,"permalink":"/dev/docs/concepts/ocm-components/","summary":"\u003cp\u003eIn OCM, \u003cem\u003ecomponents\u003c/em\u003e group a set of semantically related \u003cem\u003ecomponent versions\u003c/em\u003e. Each component version is uniquely and globally identified by a \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/concepts/ocm-coordinates/\"\u003e\u003cem\u003ecomponent identity\u003c/em\u003e\u003c/a\u003e and can reference other components. A component version can also contain \u003cem\u003eartifacts\u003c/em\u003e and a formal description of how to access them. These artifacts come in two categories: \u003cem\u003eresources\u003c/em\u003e, which describe the payload (e.g., OCI images), and \u003cem\u003esources\u003c/em\u003e, which describe the input for creating resources (e.g., source code).\u003c/p\u003e","tags":[],"title":"OCM Components"},{"content":"OCM coordinates are used to reference OCM component versions and the artifacts within OCM component versions. Coordinates referring to an OCM component version are also called component identity, whereas relative coordinates referring to an artifact are called artifact identity.\nComponent Identity Component identities are globally unique and may be used to refer to full component versions. They are defined through the following attributes:\nname: Identifies a component. Must start with a URL prefix that should be controlled by the owner of the component to avoid collisions. version: If used with a component name, identifies a specific component version. Must adhere to \u0026ldquo;relaxed SemVer\u0026rdquo; (major, minor (+ optional patch level) - optional v-prefix). Artifact Identity Artifact identities are always relative to a component version and may only be used in conjunction with a component identity. Within a component version, all artifacts must have a unique identity.\nArtifact identities are defined through the following attributes:\nname: Identifies an artifact. Typically expresses the intended purpose. extraIdentity (optional): Contributes to the identity of the artifact. String-to-string map. Examples Let\u0026rsquo;s assume there is a component named example.org/my-component with two versions, 1.2.3 and 1.3.0, declaring a resource with the name my-resource. The following OCM coordinates can be used to reference different elements:\nexample.org/my-component: all versions of the component (1.2.3 + 1.3.0) example.org/my-component:1.2.3: version 1.2.3 of the component example.org/my-component:1.2.3:resource/my-resource: my-resource as declared by the component version ","date":"0001-01-01","id":13,"permalink":"/dev/docs/concepts/ocm-coordinates/","summary":"\u003cp\u003e\u003cem\u003eOCM coordinates\u003c/em\u003e are used to reference OCM component versions and the artifacts within OCM component versions. Coordinates referring to an OCM component version are also called \u003cem\u003ecomponent identity\u003c/em\u003e, whereas relative coordinates referring to an artifact are called \u003cem\u003eartifact identity\u003c/em\u003e.\u003c/p\u003e","tags":[],"title":"OCM Coordinates"},{"content":"\rThis project is in early development and not yet ready for production use.\nThe OCM controllers\nsupport the deployment of an OCM component and its resources, like Helm charts or other manifests, into a Kubernetes cluster with the help of kro and a deployer, e.g. FluxCD. provide a controller to transfer OCM components. Before You Begin You should be familiar with the following concepts:\nOpen Component Model Kubernetes ecosystem kro Kubernetes resource deployer such as FluxCD. Concept The following section provides a high-level overview of the OCM controllers and their components regarding the deployment of an OCM resource in a very basic scenario. To learn more about the transfer of OCM component versions, please take a look at its architecture document.\nThe primary purpose of OCM controllers is simple: Deploy an OCM resource from an OCM component version into a Kubernetes cluster.\nThe implementation, however, is a bit more complex as deployments must be secure and configurable. Additionally, an OCM Resource can, in theory, contain any form of deployable resource, for instance a Helm chart, a Kustomization, or plain Kubernetes manifests. Each of these resources has its own way of being deployed or configured. So, instead of creating a generic deployer that offers all these functionalities, we decided to use existing tools that are already available in the Kubernetes ecosystem.\nThe following diagram describes a basic scenario in which an OCM resource containing a Helm chart is deployed into a Kubernetes cluster using the OCM controllers as well as kro and FluxCD. kro is used to orchestrate the deployment and to transport information about the location of the OCM resource to FluxCD. FluxCD takes the location of the OCM resource, downloads the chart, configures it if necessary, and deploys it into the Kubernetes cluster.\nflowchart TB classDef cluster fill:white,color:black,stroke:black; classDef reconciledBy fill:#dedede,stroke:black,stroke-dasharray: 5,color:black; classDef k8sObject fill:#b3b3b3,color:black,stroke:black; classDef information fill:#b3b3b3,color:black,stroke:black,stroke-dasharray: 2; classDef ocm fill:white,stroke:black,color:black; classDef legendStyle fill:white,stroke:black,color:black,stroke-dasharray: 2; classDef legendStartEnd height:0px; classDef legendItems fill:#b3b3b3,stroke:none,color:black; subgraph legend[Legend] start1[ ] ---references[referenced by] --\u0026gt; end1[ ] start2[ ] -.-creates -.-\u0026gt; end2[ ] start3[ ] ---instanceOf[instance of] --\u0026gt; end3[ ] start4[ ] ~~~reconciledBy[reconciled by] ~~~ end4[ ] start5[ ] ~~~k8sObject[k8s object] ~~~ end5[ ] start6[ ] ~~~templateOf[template of] ~~~ end6[ ] end subgraph background[ ] direction TB subgraph ocmRepo[OCM Repository] subgraph ocmCV[OCM Component Version] subgraph ocmResource[OCM Resource: HelmChart] end end end subgraph k8sCluster[Kubernetes Cluster] subgraph kroRGD[kro] subgraph rgd[RGD: Simple] direction LR rgdRepository[Repository] rgdComponent[Component] rgdResourceHelm[Resource: HelmChart] rgdSource[FluxCD: OCI Repository] rgdHelmRelease[FluxCD: HelmRelease] end end subgraph kroInstance[kro] subgraph instanceSimple[Instance: Simple] subgraph ocmControllers[OCM Controllers] k8sRepo[Repository] --\u0026gt; k8sComponent[Component] --\u0026gt; k8sResource[Resource: HelmChart] end subgraph fluxCD[FluxCD] source[OCI Repository] --\u0026gt; helmRelease[HelmRelease] end k8sResource --\u0026gt; source end end kroRGD \u0026amp; instanceSimple --\u0026gt; crdSimple[CRD: Simple] helmRelease --\u0026gt; deployment[Deployment: Helm chart] end ocmRepo --\u0026gt; k8sRepo end linkStyle default fill:none,stroke:black; linkStyle 2,3,16,18 stroke:black,stroke-dasharray: 10; linkStyle 4,5,17 stroke:black,stroke-dasharray: 4; class start1,end1,start2,end2,start3,end3,start4,end4,start5,end5,start6,end6 legendStartEnd; class references,creates,instanceOf legendItems; class templateOf,rgdRepository,rgdComponent,rgdResourceHelm,rgdSource,rgdHelmRelease information; class reconciledBy,ocmK8sToolkit,fluxCD,kroRGD,kroInstance reconciledBy; class k8sObject,rgd,k8sRepo,k8sComponent,k8sResource,source,helmRelease,deployment,crdSimple,instanceSimple k8sObject; class ocmRepo,ocmCV,ocmResource ocm; class k8sCluster cluster; class legend legendStyle; The above diagram shows an OCM resource of type helmChart. This resource is part of an OCM component version, which is located in an OCM repository.\nIn the Kubernetes Cluster we can see several Kubernetes (custom) resources. The ResourceGraphDefintion (RGD: Simple) contains the template of all the resources for deploying the Helm chart into the Kubernetes cluster. kro creates a Custom Resource Definition (CRD) Simple based on that ResourceGraphDefinition. By creating an instance of this CRD (Instance: Simple), the resources are created and reconciled by the respective controllers:\nRepository: Points to the OCM repository and checks if it is reachable by pinging it. Component: Refers to the Repository and downloads and verifies the OCM component version descriptor. Resource: Points to the Component, downloads the OCM component version descriptor from which it gets the location of the OCM resource. It then downloads the resource to verify its signature (optional) and publishes the location of the resource in its status. With FluxCD, this only works if the OCM resource has an access for which FluxCD has a corresponding Source type (e.g. an OCI or a GitHub repository)\nAs a result, FluxCD can now consume the information of the Resource and deploy the Helm chart:\nOCIRepository: Watches and downloads the resource from the location provided by the Resource status. HelmRelease: Refers to the OCIRepository, lets you configure the Helm chart, and creates the deployment into the Kubernetes cluster. Installation Currently, the OCM controllers are available as image and Kustomization. A Helm chart is planned for the future.\nTo install the OCM controllers into your running Kubernetes cluster, you can use the following commands:\n# In the open-component-model repository, folder kubernetes/controller task deploy or\nkubectl apply -k https://github.com/open-component-model/open-component-model/kubernetes/controller/config/default?ref=main While the OCM controllers technically can be used standalone, it requires kro and a deployer, e.g. FluxCD, to deploy an OCM resource into a Kubernetes cluster. The OCM controllers deployment, however, does not contain kro or any deployer. Please refer to the respective installation guides for these tools:\nkro FluxCD Getting Started Setup your (test) environment with kind, kro, and FluxCD Deploying a Helm chart using a ResourceGraphDefinition with FluxCD Deploying a Helm chart using a ResourceGraphDefinition inside the OCM component version (bootstrap) with FluxCD Configuring credentials for OCM controller resources to access private OCM repositories ","date":"0001-01-01","id":14,"permalink":"/dev/docs/concepts/ocm-controllers/","summary":"\u003cdiv class=\"callout callout-danger d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \r\n    \u003cdiv class=\"callout-body\"\u003e\r\n      \u003cp\u003eThis project is in early development and not yet ready for production use.\u003c/p\u003e","tags":[],"title":"OCM Controllers"},{"content":"","date":"0001-01-01","id":15,"permalink":"/dev/docs/how-to/","summary":"","tags":[],"title":"How-to Guides"},{"content":"","date":"0001-01-01","id":16,"permalink":"/dev/docs/tutorials/","summary":"","tags":[],"title":"Tutorials"},{"content":"Introduction In this tutorial software products are comprised of logical units called components. A component version consists of a set of technical artifacts (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called resources in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named sources in this specification.\nOCM introduces a Component Version for every component version that describes the resources, sources, and other component versions belonging to a particular component version and how to access them.\nUsually, however, real-life applications are composed of multiple components. For example, an application might consist of a frontend, a backend, a database, and a web server. During the software development process new component versions are created and third-party components might be consumed from a public registry and updated from time to time.\nNot all component version combinations of frontend, backend, database, etc. are compatible and form a valid product version. In order to define reasonable version combinations for the software product, we could use another feature of OCM\u0026rsquo;s Component Version, called a Component Reference (or reference in short), which allows the aggregation of component versions.\nFor each sub-component and each version in use, there is a Component Version. For the entire application, we introduce a new component that describes the overall software product referencing all components. This describes the entire application or product.\nA particular version of this application is again described by a Component Version, which contains references to the Component Versions of its sub-components in their version in use. You are not restricted to this approach. It is, e.g., possible to create multi-level hierarchies or you could just maintain a list of component version combinations which build a valid product release.\nIn a nutshell, OCM provides a simple approach to specify what belongs to a product version. Starting with the Component Version for a product version and following the component references, you could collect all artifacts belonging to this product version.\nPrerequisites We assume that you have already read the guides in the Getting Started section, as this guide discusses a more complex scenario.\nConstructing the Component We are going to use podinfo in microservices mode. This describes a setup with multiple microservices forming a larger application.\npodinfo has three services which we are going to model using individual component versions:\nbackend frontend cache (redis) We will use the following example application to demonstrate a multi-component structure using podinfo: Podinfo Component.\nThis repository contains the following items:\nComponent File The following component-constructor file describes four components: three components, each representing a podinfo microservice and one aggregated component that brings together the podinfo components using references. We refer to the aggregated component as the product component. A component-constructor file can contain one or multiple components and references to other components. The file is a YAML file and can be validated using the OCM schema.\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: # -- product component - name: ocm.software/podinfo version: 1.0.2 labels: - name: ocm.software/labels/podinfo/purpose value: - kind: test type: manual provider: name: open-component-model componentReferences: - name: backend componentName: ocm.software/podinfo/backend version: 1.0.0 - name: frontend componentName: ocm.software/podinfo/frontend version: 1.0.0 - name: redis componentName: ocm.software/redis version: 1.0.0 sources: - access: commit: ac0afafcf4aa333546634cba631f0090a0a4cbe3 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- backend component - name: ocm.software/podinfo/backend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: backend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: backend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: backend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- frontend component - name: ocm.software/podinfo/frontend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: frontend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: frontend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: frontend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- redis component - name: ocm.software/redis version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: redis resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: redis/config.yaml compress: true - name: image relation: external type: ociImage version: 6.0.1 access: type: ociArtifact imageReference: redis:6.0.1 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: redis/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0\rWith the components modeled we can start to build a component archive using the ocm cli:\nocm add componentversions --create --file component-archive component-constructor.yaml processing component-constructor.yaml... processing document 1... processing index 1 processing index 2 processing index 3 processing index 4 found 4 components adding component ocm.software/podinfo:1.0.2... adding reference ocm.software/podinfo/backend: \u0026#34;name\u0026#34;=\u0026#34;backend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/podinfo/frontend: \u0026#34;name\u0026#34;=\u0026#34;frontend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/redis: \u0026#34;name\u0026#34;=\u0026#34;redis\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding component ocm.software/podinfo/backend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/podinfo/frontend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/redis:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.0.1\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;...\rThis will create a folder called component-archive. The structure of that should look something like this:\ntree . . ‚îú‚îÄ‚îÄ artifact-index.json ‚îî‚îÄ‚îÄ blobs ‚îú‚îÄ‚îÄ sha256.03ac3a7611e118d08fcf70e9b7be263c4a7082066f9763f71d8901d7fa2afc9d ‚îú‚îÄ‚îÄ sha256.118b6e8282ee1d335b1638a76a20022b6acc319177dbbce3089700da835afb6a ‚îú‚îÄ‚îÄ sha256.12073781e4fba95f19f046c51c90f0c4e1338d47afe4795bf6fcca163ae46eb8 ‚îú‚îÄ‚îÄ sha256.1f239399104ec0cc7680956eb60960d212b3368609feb83dac2c95040d24b480 ‚îú‚îÄ‚îÄ sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e ‚îú‚îÄ‚îÄ sha256.3dc6209959eb782fa6f5f44892f66e9657276735bfb40407bd00ddca30d0a9d1 ‚îú‚îÄ‚îÄ sha256.654debd65dbadbcee73e55b675980865ddf22acffcec166c59a5e48a213e4dd5 ‚îú‚îÄ‚îÄ sha256.699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0 ‚îú‚îÄ‚îÄ sha256.70a47378c043721e3099801dec02c44b1dd9cdef0ebf79c55784eb4666bdbc29 ‚îú‚îÄ‚îÄ sha256.773b28fb63f1195ff73e328744639ddc1c574d58c1e723d6e386fcd66b45bd9c ‚îú‚îÄ‚îÄ sha256.893be914eebd8230ef848ea82b3433c6201152f5d9925e7b5b8d68e0cec7133e ‚îú‚îÄ‚îÄ sha256.92991cf391167c928f3afe6891001f3dd325b64ce800cf34fad4c038141fc57f ‚îú‚îÄ‚îÄ sha256.98ca4d46130f5c09a704b3d8ee9af94de3c0ac73d7e990df53e64606c418fea8 ‚îú‚îÄ‚îÄ sha256.a779270c2fea310835d3125de90e089e423c9730a98f1acdda328470d21fced0 ‚îú‚îÄ‚îÄ sha256.a7dd532f80e8417ed33cf0c97328582847017895fc5146e499bdf4c94a9d17b5 ‚îú‚îÄ‚îÄ sha256.cae4365f264251c616210707aa4765bd95f23fd22f98abc68bae9f58d6e4506d ‚îú‚îÄ‚îÄ sha256.ee79c92bbcce9e7a98f07c6577fd56dd45cf6f7c2d3115216ee249f42119030e ‚îî‚îÄ‚îÄ sha256.f6a82a23220752c232e5f66ce46f0be28b27a5af19474072c77dac6d1feb0c16 2 directories, 19 files\rThese blobs contain the resources we described when modelling our podinfo application. If we cat a random blob we get something like this:\ncat sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e {\u0026#34;componentDescriptorLayer\u0026#34;:{\u0026#34;mediaType\u0026#34;:\u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;,\u0026#34;digest\u0026#34;:\u0026#34;sha256:699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0\u0026#34;,\u0026#34;size\u0026#34;:2560}}%\rNext, we transfer this component to an OCI registry of your choice. Here \u0026lt;your-location\u0026gt; for me was ghcr.io/skarlso/demo-component.\nocm transfer component ./component-archive \u0026lt;your-location\u0026gt; transferring version \u0026#34;ocm.software/podinfo:1.0.2\u0026#34;... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/backend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/frontend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/redis:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... 4 versions transferred\rWith the transfer completed, we now have a product *Component Version* that describes a set of sub-components using *Component References*. It bundles all required artifacts for a successful deployment of the complete product.\nConclusion We saw how to create a complex, multi-service architecture product component and store it in an OCI registry.\n","date":"0001-01-01","id":17,"permalink":"/dev/docs/tutorials/structure-software-products-with-ocm/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial software products are comprised of logical units called \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/concepts/ocm-components/\"\u003e\u003cem\u003ecomponents\u003c/em\u003e\u003c/a\u003e. A component version consists of a set of technical \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm-spec/blob/main/doc/04-extensions/01-artifact-types/README.md\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003eartifacts\u003c/em\u003e\u003c/a\u003e (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called \u003cem\u003eresources\u003c/em\u003e in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named \u003cem\u003esources\u003c/em\u003e in this specification.\u003c/p\u003e","tags":[],"title":"Structure Software Products with OCM"},{"content":"The following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\nThe component is publicly available in the GitHub container registry and can be inspected using the following command:\nocm componentversion get --repo ghcr.io/phoban01/ocm github.com/weaveworks/weave-gitops -oyaml\rmeta: # component schema version schemaVersion: v2 component: # name of the component. Must start with URL-prefix that should be controlled # by the owner of the component to avoid collisions # regex: ^[a-z][-a-z0-9]*([.][a-z][-a-z0-9]*)*[.][a-z]{2,}(/[a-z][-a-z0-9_]*([.][a-z][-a-z0-9_]*)*)+$ name: github.com/weaveworks/weave-gitops # version of the component. Must adhere to ‚Äúrelaxed SemVer‚Äù # major, minor (+ optional patch level) - optional v-prefix # regex: ^[v]?(0|[1-9]\\\\d*)(?:\\\\.(0|[1-9]\\\\d*))?(?:\\\\.(0|[1-9]\\\\d*))?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$ version: v1.0.0 # component provider provider: weaveworks # list of labels that can contain arbitrary metadata in form of K/V pairs # labels can be added on component root, resource, source and reference level labels: - name: link-to-documentation value: https://github.com/weaveworks/weave-gitops # list of repository context the component version \u0026#34;lived\u0026#34; in, # with the current one at the top repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: phoban01/ocm type: OCIRegistry # list of resources that describe the payload of the component resources: # resource name - name: image # resource location (external repository or internal to this repository) relation: external # resource type type: ociImage # resource version. Must also adhere to ‚Äúrelaxed SemVer‚Äù (see `component.version` above`) version: v0.14.1 # metadata describing how to access the resource access: # type of access information type: ociArtifact imageReference: ghcr.io/weaveworks/wego-app:v0.14.1 # signing metadata for the resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: ociArtifactDigest/v1 value: efa2b9980ca2de65dc5a0c8cc05638b1a4b4ce8f6972dc08d0e805e5563ba5bb # list of sources that describe the input for creating the resources sources: # source name - name: weave-gitops # source type type: git # source version. Must also adhere to ‚Äúrelaxed SemVer‚Äù (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the source access: commit: 727513969553bfcc603e1c0ae1a75d79e4132b58 ref: refs/tags/v0.14.1 repoUrl: github.com/weaveworks/weave-gitops type: gitHub # list of references to other components componentReferences: # reference name - name: prometheus # reference version version: v1.0.0 # referenced component name componentName: cncf.io/prometheus # signing metadata for the referenced resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 04eb20b6fd942860325caf7f4415d1acf287a1aabd9e4827719328ba25d6f801 # list of signatures used for signing and verification signatures: # name of the signature - name: ww-dev # digest of the signature including the algorithm used digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 4faff7822616305ecd09284d7c3e74a64f2269dcc524a9cdf0db4b592b8cee6a # signature including the algorithm used signature: algorithm: RSASSA-PSS mediaType: application/vnd.ocm.signature.rsa value: 26468587671bdbd2166cf5f69829f090c10768511b15e804294fcb26e552654316c8f4851ed396f279ec99335e5f4b11cb043feb97f1f9a42115f4fda2d31ae8b481b7303b9a913d3a4b92d446fbee9ed487c93b09e513f3f68355040ec08454675e1f407422062abbd2681f70dd5488ad29020b30cfa7e001455c550458da96166bc3243c8426977d73352aface5323fb2b5a374e9c31b272a59c160b85631231c9fc2f23c032401b80fef937029a39111cee34470c61ae86cd4942553466411a5a116159fdcc10e50fe9360c5184028e72d1fe9c7315f26e15d7b4849f62d197501b8cc6b6f1b1391ecc2fc2fc0c1290d2554594505b25fa8f9bfb28c8df24\r","date":"0001-01-01","id":18,"permalink":"/dev/docs/tutorials/example-component-descriptor/","summary":"\u003cp\u003eThe following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\u003c/p\u003e\n\u003cp\u003eThe component is publicly available in the GitHub container registry and can be inspected using the following command:\u003c/p\u003e","tags":[],"title":"Example Component Descriptor"},{"content":" Overview Input Types binary dir docker dockermulti file helm ociImage spiff utf-8 Access Types gitHub helm npm ociArtifact s3 wget Overview The Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\nFor the real comprehensive official documentation, please have a look on GitHub (or ocm-cli help).\nAn Input type adds content by value, along with the component descriptor and stores it in the same target repository where the component is stored. After pushing the content to the target registry this always resolves to the attribute\nrelation: local\rin a component descriptor.\nAn Access Type just adds content by reference to an external location, e.g., an OCI registry. It is a kind of pointer in a component descriptor. It resolves to the attribute\nrelation: external\rin a component descriptor.\nThe following input types are supported:\nbinary dir docker dockermulti file helm ociImage spiff utf-8 Please use the latest ocm-cli to check available input types:\nocm add resources --help | grep \u0026#39; - Input type\u0026#39; | sort -f\rThe following list of access types is supported:\ngitHub localBlob ociArtifact ociBlob s3 Please use the latest ocm-cli to check available access types:\nocm ocm-accessmethods | grep \u0026#39; - Access type\u0026#39; | sort -f\rNot all access and input types can be combined in useful ways with all artifact types. But the OCM specification does not define any restrictions on possible combinations.\nThe following sections give an overview and typical usage examples for access and input types. It does not describe the full list of possible fields and their meaning. For a complete list of attributes, please see the command reference. The examples below are meant to be used in a component that looks like this:\n- name: github.com/open-component-model/megacomponent version: 0.1.0\rInput Types binary Allows to define resources with binary content being base64 encoded. Should only be used for smaller blobs.\nresources: - name: noticeencoded type : blob input: data: VGhpcyBpcyBzb21lIGJhc2U2NCBlbmNvZGVkIGRhdGEK mediaType: text/plain compress: false type: binary\rdir Defines a resource from content of a directory in the local file system. It is packed with tar and optionally compressed.\nresources: - name: megadir type : fileSystem input: type: dir path: ./logos\rdocker Takes an image from the local docker registry and adds it as a resource. Requires a running docker daemon.\nresources: - name: megaimage type : ociImage input: type: docker repository: images/mega path: megacomp:${VERSION}\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0 9aab9cbca56e 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/mega:1.10.\ndockermulti Takes multiple images from the local docker registry and adds them as single multi-arch image. Requires a running docker daemon. The images have to be built for different architectures/os and need a unique tag identifying them. As docker does not support multi-arch images at the time of writing this is a workaround.\nresources: - name: megaimagemulti type : ociImage input: type: dockermulti repository: images/megamulti variants: - megacomp:${VERSION}-linux-amd64 - megacomp:${VERSION}-linux-arm64\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0-linux-amd64 96659c4f7a35 5 days ago 7.05MB megacomp 0.1.0-linux-arm64 64f209acb814 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/megamulti:1.10.\nfile Imports a file from the local file system and adds it as a resource.\nresources: - name: mega-file type: blob input: type: file path: ./logos/logo-image.png\rhelm Imports a helm chart from the local file system and adds it as a resource.\nresources: - name: mega-chart type: helmChart input: type: helm path: ./megachart repository: charts/mega\rAfter transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mega prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mega. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used.\nIt is also possible to import a helm chart from a helm chart repository:\nresources: - name: mariadb-chart type: helmChart input: type: helm helmRepository: https://charts.bitnami.com/bitnami path: mariadb version: 12.2.7 repository: charts/mariadb\rHere the helm chart version 12.2.7 is copied from the path mariadb in helm chart repository https://charts.bitnami.com/bitnami. After transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mariadb prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mariadb. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used. There are additional optional fields caCert and caCertFile to specify a TLS certificate for the helm chart repository.\nociImage Takes an image that is located in an OCI registry and adds it as a resource.\nresources: - name: mega-image type: ociImage input: type: ociImage path: gcr.io/google_containers/echoserver:1.10 repository: images/echo\rThe target location of the image after transporting to an OCI registry can be set with the repository field. Here the resulting image will be prefixed with the name of the component version, e.g., github.com/open-component-model/megacomponent/images/echo:1.10. This auto-prefix can be disabled by using a leading slash /images/echo.\nspiff Processes a resource using the spiff templater and can provide values for variables.\nresources: - name: mega-package type: toiPackage input: type: spiff mediaType: application/vnd.toi.ocm.software.package.v1+yaml path: packagespec.yaml values: RELEASE_NAME: megacomp\rutf-8 Adds a resource from inline text.\nresources: - name: noticeplain type : blob input: text: \u0026#34;Here is some text\u0026#34; mediaType: text/plain compress: false type: utf8\rAccess Types gitHub Refers to a Git repository at a certain commit or tag.\nresources: - name: git-ocm type: blob version: ${VERSION} access: type: gitHub repoUrl: https://github.com/open-component-model/ocm commit: 42cc249aec77aa64984b2b91eb0f3b96dd63aacd\rhelm Refers to a helm chart located in a helm chart repository.\n- name: mariadb-chart type: helmChart version: ${VERSION} access: type: helm helmChart: mariadb:12.2.7 helmRepository: https://charts.bitnami.com/bitnami\rnpm Refers to an npm package located in a Javascript package registry.\n- name: prime-npm type: ocm/npmPackage version: ${VERSION} access: type: npm package: random-prime version: 4.0.0 registry: https://registry.npmjs.org\rociArtifact Refers to an image in an (external) OCI registry.\nresources: - name: echo-image version: ${VERSION} type: ociImage access: type: ociArtifact imageReference: gcr.io/google_containers/echoserver:1.10\rs3 Refers to an object in an AWS S3 store.\nresources: - name: gardenlinux-meta type: blob version: ${VERSION} access: type: s3 bucket: gardenlinux key: meta/singles/gcp-cloud-gardener-_prod-890.0-53b732\rwget Refers to resources stored on an http server.\nresources: - name: busybox-binary type: blob version: ${VERSION} access: type: wget url: https://busybox.net/downloads/binaries/1.21.1/busybox-x86_64\r","date":"0001-01-01","id":19,"permalink":"/dev/docs/tutorials/input-and-access-types/","summary":"\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#overview\"\u003eOverview\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#input-types\"\u003eInput Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#binary\"\u003ebinary\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dir\"\u003edir\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#docker\"\u003edocker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dockermulti\"\u003edockermulti\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#file\"\u003efile\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociimage\"\u003eociImage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#spiff\"\u003espiff\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#utf-8\"\u003eutf-8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#access-types\"\u003eAccess Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#github\"\u003egitHub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm-1\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#npm\"\u003enpm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociartifact\"\u003eociArtifact\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#s3\"\u003es3\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#wget\"\u003ewget\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\u003c/p\u003e","tags":[],"title":"Input and Access Types"},{"content":"OCM controller resources need access to OCM components and their resources. If these OCM components are stored in a private OCM repository, we need to configure credentials to allow OCM controller resources to access these repositories.\nHow to Configure Credentials? Currently, OCM controllers supports two ways to configure credentials for accessing private OCM repositories:\nKubernetes secret of type dockerconfigjson Kubernetes secret or configmap containing an .ocmconfig file Create a Kubernetes Secret of Type dockerconfigjson If you already have an existing Docker configuration file that you use to access your private OCM repository, you can create a Kubernetes secret of type dockerconfigjson that contains the credentials:\nkubectl create secret docker-registry ocm-secret --from-file=\u0026lt;path-to-your-docker-config-file\u0026gt;\rBe aware that Kubernetes secrets are only base64 encoded and not encrypted. This means that anyone with access to the Kubernetes secret can access the credentials.\nAccordingly, you should make sure that the Docker configuration file only contains information required for accessing the private OCM repository.\nIn case you want to create the secret manually, you can use the following command to create a Kubernetes secret of type dockerconfigjson:\nkubectl create secret docker-registry ocm-secret \\ --docker-username=\u0026lt;your-name\u0026gt; \\ --docker-password=\u0026lt;your-password\u0026gt; \\ --docker-server=\u0026lt;your-OCM-repository-url\u0026gt;\rCreate a Kubernetes Secret or Configmap from an .ocmconfig file To create a Kubernetes secret or configmap containing an OCM configuration that allows OCM controller resources to access private OCM repositories, you can use the .ocmconfig file used to transfer the OCM component in the first place.\nUsually, the .ocmconfig file is located in your HOME directory. However, this .ocmconfig could contain more configurations than just the credentials for accessing private OCM repositories. As this .ocmconfig will be used to create a Kubernetes secret or configmap to which other users might have access to, you have to make sure that it only contains the configuration you want to share.\nWe recommend to create a new .ocmconfig file that only contains the credentials for accessing the private OCM repository.\nFor more information on how to create and use the .ocmconfig file, please refer to the OCM CLI credentials guide.\nFor instance, consider you used the following command and .ocmconfig file to transfer the OCM component:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: \u0026lt;your-namespace\u0026gt; credentials: - type: Credentials properties: username: \u0026lt;your-username\u0026gt; password: \u0026lt;your-password/token\u0026gt;\rocm --config ./.ocmconfig transfer ctf ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rYou can now create a secret in the Kubernetes cluster that contains the .ocmconfig file:\nkubectl create secret generic ocm-secret --from-file=./.ocmconfig\rMake sure that the secret or configmap containing an OCM config has the correct key to the OCM config file .ocmconfig. This is required for OCM controller resources to be able to read the OCM configuration. Using the filename .ocmconfig in the --from-file option takes care of that.\nHow to Use the Configured Credentials? Every OCM controller resource offers a spec.ocmConfig field that can be used to specify the credentials for accessing private OCM repositories. It expects an OCMConfiguration that contains a NamespacedObjectKindReference to the secret or configmap that contains the credentials.\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: helm-configuration-localization-repository spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m ocmConfig: - kind: Secret name: ocm-secret\rBy default, the ocmConfig of a resource is propagated and can be consumed by other resources. So, instead of specifying the secret or configmap again, you can reference the resource in the ocmConfig field:\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: guide-repository namespace: default spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m ocmConfig: - kind: Secret name: ocm-secret --- apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: guide-component spec: component: ocm.software/ocm-k8s-toolkit/guide-component repositoryRef: name: guide-repository semver: 1.0.0 interval: 1m ocmConfig: - kind: Repository apiVersion: delivery.ocm.software/v1alpha1 name: guide-repository namespace: default\rThe above example shows how to use the ocmConfig field in an Repository and a Component. The Repository references a secret named ocm-secret that contains the credentials for accessing the private OCM repository. The Component then references the Repository in ocmConfigand uses the same credentials.\nHowever, you always need to specify a reference to the credentials either as secret, configmap, or as OCM controller resource for each resource. The credentials will not be propagated automatically to all OCM controller resources in the cluster.\nIn some cases, you do not want to propagate the ocmConfig of a resource. To do so, you can set the policy to DoNotPropagate:\napiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: guide-component spec: component: ocm.software/ocm-k8s-toolkit/guide-component repositoryRef: name: guide-repository semver: 1.0.0 interval: 1m ocmConfig: - kind: Repository apiVersion: delivery.ocm.software/v1alpha1 name: guide-repository namespace: default policy: DoNotPropagate\r","date":"0001-01-01","id":20,"permalink":"/dev/docs/tutorials/credentials-for-ocm-controllers/","summary":"\u003cp\u003eOCM controller resources need access to OCM components and their resources. If these OCM components are stored in a\nprivate OCM repository, we need to configure credentials to allow OCM controller resources to access these\nrepositories.\u003c/p\u003e","tags":[],"title":"Credentials for OCM Controllers"},{"content":"Overview The OCM command line client can be configured by supplying it with a configuration file. By default, the CLI looks for configuration in $HOME/.ocmconfig, if it exists.\nThe configuration file can be used in particular to specify the credentials, which are required for the CLI to be able to access the artifact repositories referenced in CLI commands.\nExamples This page contains basic examples of credentials configuration for a few most common artifact repository types. The examples below are complete .ocmconfig files, not snippets.\nFor comprehensive documentation on the credentials topic, including usage of certificates or HashiCorp Vault, execute the command ocm credential-handling.\nRepositories and Consumers In the examples below, some configuration is located under configurations[0].repositories, and some other under configurations[0].consumers. This chapter explains the difference between repositories and consumers, which is potentially not as obvious as one could think.\nIn this context, repository is a place where credentials can be stored, i.e., it is a credentials repository. For example, Docker\u0026rsquo;s config.json can store multiple credentials, and in that sense the file serves as a repository that can store and provide credentials. That is why its location is configured under repositories. Other examples of credentials repositories can be the NPM\u0026rsquo;s .npmrc file or a HashiCorp Vault instance.\nA consumer is something the credentials are required for. For example, if you need to configure credentials that are required to log in to an OCI registry, one could say that the registry will be consuming these credentials, i.e., the registry is a credentials consumer. That is why it is configured under consumers.\nReuse Credentials Configured for Docker This .ocmconfig file will tell the OCM CLI to use credentials configuration from Docker\u0026rsquo;s config.json file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34;\rReuse Credentials Configured for npm This .ocmconfig file will tell OCM CLI to use credentials configuration from npm\u0026rsquo;s .npmrc file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: NPMConfig/v1 npmrcFile: \u0026#39;~/.npmrc\u0026#39;\rAccessing OCI Registries HTTPS and Path To access artifacts in https://ghcr.io/open-component-model:\nThe different parts of the URL have to be specified in separate fields: scheme, hostname, and pathprefix The fields scheme and pathprefix are optional. If not specified, the OCM CLI will use the credentials for all schemes and paths on that host The password is the user\u0026rsquo;s basic authentication password. Some OCI registries allow to generate user access tokens, which can also be used for basic authentication type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rHTTP, Port Number, Empty Path To access artifacts in http://127.0.0.1:5001:\nThe fields scheme and port are optional. If not specified, the OCM CLI will use the credentials for all schemes and ports on that host As the URL has no path behind the port number, the pathprefix element can be removed type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: http hostname: 127.0.0.1 port: 5001 credentials: - type: Credentials properties: username: admin password: admin\rAccessing Helm Chart Repositories Similar to OCI registries, but uses HelmChartRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: HelmChartRepository hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rAccessing Maven Repositories Similar to OCI registries, but uses MavenRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: MavenRepository hostname: maven.repo.host pathprefix: path/to/repo credentials: - type: Credentials properties: username: some-user password: some-password\rAccessing npm Registries Similar to OCI registries, but uses NpmRegistry as identity type. In addition, it is required to specify the email address matching with the one in the user record in the npm registry.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: NpmRegistry hostname: npm.registry.host pathprefix: path/to/registry credentials: - type: Credentials properties: username: some-user password: some-password email: foo.bar@acme.org\rAccessing GitHub Repositories To access code in https://my.github.enterprise/my-org/my-repo:\nUse Github as identity type hostname is the domain name of the GitHub instance pathprefix is a combination of organization and repository names token is a personal access token generated in GitHub Developer Settings type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\rAccessing Several Systems It is, of course, possible to configure credentials for several systems in the same .ocmconfig file. To do that, you can combine as many repositories and consumers as you need.\nThe example below instructs OCM CLI to look for credentials in Docker\u0026rsquo;s config.json, and in addition specifies dedicated credentials for an OCI registry and a GitHub repository.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true consumers: - identity: type: OCIRegistry hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\r","date":"0001-01-01","id":21,"permalink":"/dev/docs/tutorials/credentials-in-an-.ocmconfig-file/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm.md\" target=\"_blank\" rel=\"noopener\"\u003eOCM command line client\u003c/a\u003e can be configured by supplying it with a \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_configfile.md\" target=\"_blank\" rel=\"noopener\"\u003econfiguration file\u003c/a\u003e. By default, the CLI looks for configuration in \u003ccode\u003e$HOME/.ocmconfig\u003c/code\u003e, if it exists.\u003c/p\u003e","tags":[],"title":"Credentials in an .ocmconfig File"},{"content":"Overview The Open Component Model provides cryptographic signing and verification capabilities to establish provenance and authenticity of component versions. This guide covers the complete signing and verification workflow, from key pair generation to trust model selection.\nThis guide is for users who want to:\nUnderstand how OCM handles component signing and verification Learn about supported signature types See step-by-step signing and verification examples Plan multi-environment workflows with dedicated signing profiles (dev/staging/prod) Understand how signer specifications and encoding policies complement .ocmconfig Signing and Verification Workflow High-Level Process A side-by-side comparison makes it clear how both flows mirror the same normalization and hashing steps while differing only in credential handling.\nWorkflow Comparison Step Signing Flow Verification Flow 1 Resolve signing credentials from .ocmconfig or signer spec Resolve signature by name and load public key/certificate (config, CLI flag, or embedded PEM) 2 Normalize component descriptor (selected algorithm) Normalize component descriptor with the same algorithm 3 Hash normalized descriptor (selected hash) Hash normalized descriptor and compare against signature digest 4 Produce signature, store it with descriptor metadata Verify signature (and certificate chain if PEM) What Gets Signed? OCM signs the component descriptor, which contains:\nComponent metadata (name, version, provider) Resources (artifacts like container images, Helm charts) Sources (references to source code) References to other components Resource digests (cryptographic hashes of artifacts) Important: OCM does not sign the artifacts themselves, but rather their digests in the component descriptor. This provides:\n‚úÖ Efficient verification (no external dependencies) ‚úÖ Tamper detection (any change to artifacts invalidates the signature) ‚úÖ Provenance (signature proves who created/released the component version) Key Pair Generation (Optional) Already have RSA key pairs? Skip to Configuring Keys in an .ocmconfig File.\nThis section covers general RSA key pair generation and management. If you already have suitable RSA keys (self-signed or CA-signed), you can use them directly with OCM and skip to the configuration section.\nChoose Your Approach Before generating keys, decide which approach fits your needs:\nYour Situation Recommended Approach Local development or testing Self-Signed Keys Production environment CA-Signed Keys Enterprise/Multi-organization CA-Signed Keys Compliance requirements CA-Signed Keys Self-Signed vs. CA-Signed Self-Signed Keys:\nSimple to create (no external CA required) Full control over key lifecycle Trust based on explicit key distribution Public key must be manually distributed to verifiers CA-Signed Certificates:\nRequires Certificate Authority (CA) Certificate chain validates against trusted root CAs Trust leverages existing PKI Automatic trust propagation via certificate validation Key Pair Generation OCM supports RSA signatures with two algorithms:\nRSASSA-PSS - Default and recommended RSASSA-PKCS1v15 - Legacy support Directory Structure Setup First, create a consistent directory structure for your keys. This guide uses the following convention:\n# Create a directory for your OCM keys mkdir -p ~/.ocm/keys # Recommended structure: # ~/.ocm/keys/ # ‚îú‚îÄ‚îÄ dev/ # Development keys # ‚îú‚îÄ‚îÄ staging/ # Staging keys # ‚îî‚îÄ‚îÄ prod/ # Production keys\rThroughout this guide, we\u0026rsquo;ll use this structure and reference files with their full paths.\nSelf-Signed Keys (Development) Self-signed keys are ideal for development, testing, and environments without PKI infrastructure.\nGenerate Development Keys # Create directory for development keys mkdir -p ~/.ocm/keys/dev # Generate private key (4096 bits recommended) openssl genrsa -out ~/.ocm/keys/dev/private.pem 4096 # Extract public key openssl rsa -in ~/.ocm/keys/dev/private.pem -pubout -out ~/.ocm/keys/dev/public.pem # Set secure permissions chmod 600 ~/.ocm/keys/dev/private.pem chmod 644 ~/.ocm/keys/dev/public.pem\rFiles created:\n~/.ocm/keys/dev/private.pem - Private key (4096 bits) ~/.ocm/keys/dev/public.pem - Public key CA-Signed Keys (Production) CA-signed certificates provide a trust chain that can be validated against a certificate authority. They are recommended for production environments, enterprise deployments, and scenarios requiring PKI integration or compliance.\nGenerate Production Keys with CSR # Create directory for production keys mkdir -p ~/.ocm/keys/prod # Generate private key openssl genrsa -out ~/.ocm/keys/prod/private.pem 4096 # Create certificate signing request (CSR) openssl req -new -key ~/.ocm/keys/prod/private.pem \\ -out ~/.ocm/keys/prod/request.csr \\ -subj \u0026#34;/C=US/O=MyOrg/OU=Engineering/CN=OCM Production Signer\u0026#34; # Set secure permissions chmod 600 ~/.ocm/keys/prod/private.pem chmod 644 ~/.ocm/keys/prod/request.csr # Send request.csr to your CA and save the response # After receiving from CA, save as: # ~/.ocm/keys/prod/certificate.pem # ~/.ocm/keys/prod/ca-chain.pem (if provided)\rFiles created:\n~/.ocm/keys/prod/private.pem - Private key (4096 bits) ~/.ocm/keys/prod/request.csr - Certificate signing request (send to CA) Files received from CA:\n~/.ocm/keys/prod/certificate.pem - Signed certificate ~/.ocm/keys/prod/ca-chain.pem - CA certificate chain (optional but recommended) Create Certificate with Chain If you receive individual certificates, combine them into a chain:\n# Combine leaf certificate with intermediate and root CA certificates cat ~/.ocm/keys/prod/certificate.pem \\ ~/.ocm/keys/prod/intermediate-ca.pem \\ ~/.ocm/keys/prod/root-ca.pem \\ \u0026gt; ~/.ocm/keys/prod/cert-chain.pem chmod 644 ~/.ocm/keys/prod/cert-chain.pem\rConfiguring Keys in an .ocmconfig File OCM uses its credential system to resolve signing and verification keys. The keys are configured as credentials for a special consumer type: RSA/v1alpha1.\nUsing your own keys? Simply reference your existing key file paths in the configuration examples below instead of the ~/.ocm/keys/ paths shown here.\nAll examples below use the exact file paths from the key generation section above.\nTip: Add the entries below to your .ocmconfig. If the file is present in your home directory (~/.ocmconfig), the OCM CLI will use it automatically. Only provide --config \u0026lt;path\u0026gt; when you want to reference a different configuration file.\nBasic Signing Configuration (Development) Using the development keys we created earlier:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: default credentials: - type: Credentials/v1 properties: private_key_pem_file: ~/.ocm/keys/dev/private.pem\rNote: This references ~/.ocm/keys/dev/private.pem which we created with the OpenSSL command in the previous section.\nAlternative: Keys can also be embedded inline using private_key_pem property. The inline format uses a multi-line YAML string with the PEM block.\nBasic Verification Configuration (Development) Using the public key we generated earlier:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: default credentials: - type: Credentials/v1 properties: public_key_pem_file: ~/.ocm/keys/dev/public.pem\rNote: This configuration references ~/.ocm/keys/dev/public.pem which was extracted from the private key using OpenSSL.\nIdentity Attributes Explained The consumer identity for RSA signing/verification supports these attributes:\nAttribute Required Description type Yes Must be RSA/v1alpha1 algorithm No RSASSA-PSS (default) or RSASSA-PKCS1V15 (legacy) signature No Name/label for this signature configuration (default: default) The signature attribute is particularly useful for multi-environment setups.\nMulti-Environment Configuration Optional (advanced): Skip this section if you operate a single environment. You can continue with Signer Specifications without missing any required setup.\nIn many organizations, you\u0026rsquo;ll want different signing keys for different environments or purposes.\nFor multiple environments, generate separate keys using the same process:\nDevelopment: Self-signed keys (see Self-Signed Keys section) Staging: Self-signed keys in ~/.ocm/keys/staging/ (same process) Production: CA-signed keys (see CA-Signed Keys section) Combined Configuration Example This example shows a complete .ocmconfig with signing and verification keys for all environments:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: # Development environment - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: dev credentials: - type: Credentials/v1 properties: private_key_pem_file: ~/.ocm/keys/dev/private.pem public_key_pem_file: ~/.ocm/keys/dev/public.pem # Staging environment - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: staging credentials: - type: Credentials/v1 properties: private_key_pem_file: ~/.ocm/keys/staging/private.pem public_key_pem_file: ~/.ocm/keys/staging/public.pem # Production environment (CA-signed with certificate chain) - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: prod credentials: - type: Credentials/v1 properties: private_key_pem_file: ~/.ocm/keys/prod/private.pem public_key_pem_file: ~/.ocm/keys/prod/cert-chain.pem\rNotes:\nEach environment has both private and public keys Production uses the certificate chain for verification The same configuration works for both signing and verification Usage Examples Signing:\n# Sign with development key ocm sign cv --signature dev ghcr.io/myorg/component:1.0.0 # Sign with staging key ocm sign cv --signature staging ghcr.io/myorg/component:1.0.0 # Sign with production key ocm sign cv --signature prod ghcr.io/myorg/component:1.0.0\rVerification:\n# Verify with development key ocm verify cv --signature dev ghcr.io/myorg/component:1.0.0 # Verify with staging key ocm verify cv --signature staging ghcr.io/myorg/component:1.0.0 # Verify with production key ocm verify cv --signature prod ghcr.io/myorg/component:1.0.0\rVerification-Only Configuration If you only need to verify signatures (e.g., on CI/CD runners or deployment systems), you can omit the private keys:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 signature: prod credentials: - type: Credentials/v1 properties: # Only public key needed for verification public_key_pem_file: ~/.ocm/keys/prod/cert-chain.pem\rNote: This configuration contains only the public key. Verification works, but signing operations will fail (as intended for read-only environments).\nSigner Specifications Optional (advanced): If you do not need per-command overrides or CI-friendly specs, skip ahead to Signature Encoding Policies. Core functionality continues there.\nThe --signer-spec flag provides fine-grained control over the signing process via a YAML configuration file.\nWhen to Use Signer Specs Use signer specifications when you need:\n‚úÖ Command-specific signing config ‚úÖ CI/CD pipeline integration ‚úÖ Explicit control over signing parameters ‚úÖ Different encoding policies ‚úÖ Temporary or one-off signing operations Signer specs vs. .ocmconfig:\nAspect Signer Spec File .ocmconfig Scope Command-specific Global configuration Portability Easy to version control User/machine-specific Use case CI/CD, explicit control Local development Key distribution Embedded or referenced Centralized config Signer Spec File Format A signer specification file contains only signing configuration, not the signature name (which is provided via --signature flag).\ntype: RSA/v1alpha1 signatureAlgorithm: RSASSA-PSS # or RSASSA-PKCS1V15 signatureEncodingPolicy: Plain # or PEM # Option 1: Reference external file (preferred) privateKeyPEMFile: ~/.ocm/keys/dev/private.pem # Option 2: Inline private key # privateKeyPEM: | # -----BEGIN PRIVATE KEY----- # ... # -----END PRIVATE KEY-----\rNote: The signature name is specified via the --signature flag when running the command, not in this file.\nDefault Signer Spec Behavior If --signer-spec is not provided, OCM uses defaults:\ntype: RSA/v1alpha1 signatureAlgorithm: RSASSA-PSS signatureEncodingPolicy: Plain # Private key resolved from .ocmconfig\rThis means:\nAlgorithm: RSASSA-PSS Encoding: Plain (raw signature bytes) Key: Retrieved from .ocmconfig config file Example: Using Signer Spec in CI/CD signer-config.yaml:\ntype: RSA/v1alpha1 signatureAlgorithm: RSASSA-PSS signatureEncodingPolicy: Plain privateKeyPEMFile: /secrets/signing-key.pem\rCI/CD pipeline:\n# Inject private key into CI/CD secrets echo \u0026#34;$SIGNING_PRIVATE_KEY\u0026#34; \u0026gt; /secrets/signing-key.pem chmod 600 /secrets/signing-key.pem # Sign component version ocm sign cv \\ --signer-spec ./signer-config.yaml \\ --signature release \\ ghcr.io/myorg/component:${VERSION}\rSignature Encoding Policies Optional (advanced): Readers who only work with the default signing setup can skip directly to Signing Component Versions. The sections below cover advanced storage and trust scenarios.\nOCM supports two encoding policies that affect how signatures are stored and verified.\nPlain Encoding (Default) Stores only the raw signature bytes. Compact but requires the public key to be provided separately (via .ocmconfig or --public-key flag).\nConfiguration:\ntype: RSA/v1alpha1 signatureEncodingPolicy: Plain\rSuitable for self-signed keys and scenarios where public keys are distributed through .ocmconfig.\nPEM Encoding Embeds the certificate chain directly in the signature, enabling verification against the system trust store without requiring public keys in .ocmconfig.\nConfiguration:\ntype: RSA/v1alpha1 signatureEncodingPolicy: PEM\rHow it works:\nCreates a PEM block containing the signature Appends the signer\u0026rsquo;s certificate chain During verification, validates the chain against the system trust store Extracts the public key from the validated certificate Requirements:\nSignature name must match the config Certificate chain must be included in the signature System trust store must contain the root CA, or root CA must be provided in .ocmconfig Suitable for enterprise PKI integration and scenarios requiring automated trust validation.\nSigning Component Versions Basic Signing # Sign with default signature name and configuration ocm sign cv ghcr.io/myorg/component:1.0.0 # Sign with custom signature name ocm sign cv --signature release ghcr.io/myorg/component:1.0.0\rAdvanced Signing Options # Use specific signer specification ocm sign cv \\ --signer-spec ./config/prod-signer.yaml \\ --signature prod-release \\ ghcr.io/myorg/component:1.0.0 # Dry run (compute signature without storing) ocm sign cv \\ --signature test \\ --dry-run \\ ghcr.io/myorg/component:1.0.0 # Force overwrite existing signature ocm sign cv \\ --signature release \\ --force \\ ghcr.io/myorg/component:1.0.0 # Custom normalization and hash algorithms ocm sign cv \\ --normalisation jsonNormalisation/v4alpha1 \\ --hash SHA512 \\ --signature release \\ ghcr.io/myorg/component:1.0.0\rCommon Signing Flags Flag Description Default --signature Name of the signature default --signer-spec Path to signer specification file (uses config) --force Overwrite existing signature false --dry-run Compute signature without storing false For complete flag reference, see ocm sign cv --help.\nVerifying Component Versions Basic Verification # Verify default signature ocm verify cv ghcr.io/myorg/component:1.0.0 # Verify specific signature ocm verify cv --signature release ghcr.io/myorg/component:1.0.0\rVerification with External Public Key # Provide public key via command line ocm verify cv \\ --public-key ./keys/public.pem \\ --signature release \\ ghcr.io/myorg/component:1.0.0\rVerification Process Fetch component version from repository Locate signature by name in component descriptor Resolve public key from: .ocmconfig credential system, OR --public-key flag, OR Certificate chain in signature (PEM encoding only) Normalize component descriptor using specified algorithm Hash normalized descriptor Verify signature using public key Validate certificate chain (PEM encoding only) Verification Success Criteria For verification to succeed:\n‚úÖ Signature exists with specified name ‚úÖ Public key can be resolved ‚úÖ Signature cryptographically valid ‚úÖ Component descriptor unchanged since signing ‚úÖ Certificate chain valid (PEM encoding only) ‚úÖ Certificate DN matches signature name (PEM encoding only) Trust Models OCM supports multiple trust models depending on your security requirements.\n1. Key Pinning (Self-Signed) Specific public keys configured in .ocmconfig. Trust is based on exact key match without certificate validation.\nTrust chain:\nComponent Signature ‚Üí Public Key in .ocmconfig ‚Üí Trust\rSimple setup with full control, suitable for small teams and development environments.\n2. System Trust Store (CA-Signed, PEM Encoding) Certificate chain embedded in signature and validated against system trust store or distributed root CA. No manual public key distribution needed.\nTrust chain:\nComponent Signature ‚Üí Embedded Cert Chain ‚Üí System Trust Store ‚Üí Root CA ‚Üí Trust\rSuitable for automatic trust propagation in enterprise PKI infrastructure.\nComplete Configuration Examples Example 1: Development Setup (Self-Signed) Prerequisites: Generate self-signed keys (see \u0026ldquo;Self-Signed Keys\u0026rdquo; section):\nmkdir -p ~/.ocm/keys/dev openssl genrsa -out ~/.ocm/keys/dev/private.pem 4096 openssl rsa -in ~/.ocm/keys/dev/private.pem -pubout -out ~/.ocm/keys/dev/public.pem chmod 600 ~/.ocm/keys/dev/private.pem chmod 644 ~/.ocm/keys/dev/public.pem\r.ocmconfig:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 signature: dev credentials: - type: Credentials/v1 properties: private_key_pem_file: ~/.ocm/keys/dev/private.pem public_key_pem_file: ~/.ocm/keys/dev/public.pem\rUsage:\n# Sign ocm sign cv --signature dev ghcr.io/myorg/component:1.0.0 # Verify ocm verify cv --signature dev ghcr.io/myorg/component:1.0.0\rExample 2: Enterprise Production Setup (CA-Signed, PEM Encoding) Prerequisites: Use CA-signed production keys (see \u0026ldquo;CA-Signed Keys\u0026rdquo; section).\nKey differences from Development:\nUses signatureEncodingPolicy: PEM Certificate chain embedded in signature Validates against system trust store Minimal .ocmconfig needed for verification Signer specification (~/prod-signer.yaml):\ntype: RSA/v1alpha1 signatureAlgorithm: RSASSA-PSS signatureEncodingPolicy: PEM privateKeyPEMFile: ~/.ocm/keys/prod/private.pem\rSign:\nocm sign cv --signer-spec ~/prod-signer.yaml --signature prod ghcr.io/myorg/component:1.0.0\rVerify:\n# Certificate chain validated automatically from signature ocm verify cv --signature prod ghcr.io/myorg/component:1.0.0\rTroubleshooting Signature Verification Fails Error: \u0026ldquo;signature verification failed\u0026rdquo;\nCommon causes:\nWrong public key configured Component version modified after signing Signature name mismatch Certificate chain invalid (PEM encoding) Solutions:\nVerify public key matches private key: openssl rsa -in private.pem -pubout Check signature name: ocm get cv -o yaml ghcr.io/myorg/component:1.0.0 Verify certificate chain: openssl verify -CAfile ca-chain.pem certificate.pem Private Key Not Found Error: \u0026ldquo;could not resolve credentials for identity\u0026rdquo;\nSolutions:\nCheck .ocmconfig path and syntax Verify file paths in private_key_pem_file Ensure signature attribute matches between config and command Certificate Chain Validation Fails (PEM) Error: \u0026ldquo;certificate validation failed\u0026rdquo;\nSolutions:\nEnsure system trust store includes required root CAs Provide root CA in .ocmconfig: public_key_pem_file: ./ca-root.pem Verify certificate DN matches signature name Check certificate expiry: openssl x509 -in cert.pem -noout -dates Signature Already Exists Error: \u0026ldquo;signature \u0026rsquo;name\u0026rsquo; already exists\u0026rdquo;\nSolutions:\nUse --force to overwrite: ocm sign cv ... --force Use a different signature name: --signature name-v2 Remove old signature first (manual descriptor editing) Summary OCM\u0026rsquo;s signing and verification system provides:\n‚úÖ Flexible trust models - From simple key pinning to enterprise PKI ‚úÖ Multiple algorithms - RSASSA-PSS (recommended) and PKCS1v15 ‚úÖ Encoding options - Plain (compact) and PEM (with cert chains) ‚úÖ Multi-environment support - Separate keys for dev, staging, prod ‚úÖ Signer specifications - Fine-grained control over signing process ‚úÖ Credential integration - Unified with OCM credential system Choosing the right approach:\nScenario Recommended Approach Local development Self-signed, Plain encoding Small team Self-signed, key pinning Medium organization CA-signed, Plain, certificate pinning Enterprise CA-signed, PEM, system trust store Compliance-driven CA-signed, PEM, HSM integration Related Documentation Credentials in .ocmconfig File - Practical credential configuration examples OCM CLI Reference - Complete command-line options ","date":"0001-01-01","id":22,"permalink":"/dev/docs/tutorials/signing-and-verification/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model provides cryptographic signing and verification capabilities\nto establish \u003cstrong\u003eprovenance\u003c/strong\u003e and \u003cstrong\u003eauthenticity\u003c/strong\u003e of component versions.\nThis guide covers the complete signing and verification workflow, from key pair generation to trust model selection.\u003c/p\u003e","tags":[],"title":"Signing and Verification"},{"content":"The OCM Components page and the Deploy a Helm Chart guide showed a basic example of how to deploy a Helm chart from an OCM component. By defining a ResourceGraphDefinition that contains all the required resources to deploy the Helm chart into a Kubernetes cluster.\nHowever, there are scenarios, where the developer already knows how the deployment instructions for the Helm chart should look like and what should be configured. Accordingly, the developer can create a ResourceGraphDefinition that contains all the required resources to deploy and configure the Helm chart, and deliver it with the OCM component version itself. This way, the deployment instructions can also be delivered securely through OCM and the operator does not need to know which resources are required.\nIn such a case, we need to bootstrap the ResourceGraphDefinition from the OCM component and apply it to the cluster.\nTo do so, we use the OCM controller resource Deployer. By referencing the Resource containing the ResourceGraphDefinition by name, the deployer will download the content from the OCM component and apply it to the cluster.\nThe following guide demonstrates how to deploy a Helm chart using a ResourceGraphDefinition that is also delivered with the same OCM component. Additionally, it shows how to localize a Helm chart.\nLocalization describes the process of inserting a new image reference into the deployment instructions, e.g. a Helm chart. It is a two-step process:\nWhen an OCM component and its resources are transferred to another registry, referential resources can potentially update their reference to the new location. For instance, a resource with an access type ociArtifact will update its image reference in the component descriptor to the new registry location, if the OCM transfer is done with the flag --copy-resources. However, the deployment using the image is not aware of this change. Accordingly, we need to insert the new image reference into the deployment instruction. This can be done using deployment tools like FluxCDs HelmRelease and Kustomization or ArgoCDs Helm and Kustomize. The following diagram shows an overview of the resources and their relationships of this guide:\nflowchart TB classDef cluster fill:white,color:black,stroke:black; classDef reconciledBy fill:#dedede,stroke:black,stroke-dasharray: 5,color:black; classDef k8sObject fill:#b3b3b3,color:black,stroke:black; classDef information fill:#b3b3b3,color:black,stroke:none; classDef templateOf fill:#b3b3b3,color:black,stroke:black,stroke-dasharray: 2; classDef ocm fill:white,stroke:black,color:black; classDef legendStyle fill:white,stroke:black,color:black,stroke-dasharray: 2; classDef legendStartEnd height:0px; classDef legendItems fill:#b3b3b3,stroke:none,color:black; subgraph legend[Legend] start1[ ] ---references[referenced by] --\u0026gt; end1[ ] start2[ ] -.-creates -.-\u0026gt; end2[ ] start3[ ] ---instanceOf[instance of] --\u0026gt; end3[ ] start4[ ] ~~~reconciledBy[reconciled by] ~~~ end4[ ] start5[ ] ~~~k8sObject[k8s object] ~~~ end5[ ] start6[ ] ~~~templateOf[template of] ~~~ end6[ ] end subgraph background[ ] direction TB subgraph ocmRepo[OCM Repository] subgraph ocmCV[OCM Component Version] direction RL subgraph ocmResourceHelm[OCM Resource: HelmChart] end subgraph ocmResourceImage[OCM Resource: Image] end subgraph ocmResourceRGD[OCM Resource: RGD] end end end subgraph k8sCluster[Kubernetes Cluster] subgraph bootstrap[OCM Controllers] k8sRepo[OCMRepository] k8sComponent[Component] k8sResourceRGD[Resource: RGD] k8sDeployer[Deployer] end subgraph kro[kro] subgraph rgd[RGD: Bootstrap] rgdResourceHelm[Resource: HelmChart] rgdResourceImage[Resource: Image] rgdSource[FluxCD: OCI Repository] rgdHelmRelease[FluxCD: HelmRelease] end crdBootstrap[CRD: Bootstrap] subgraph instanceBootstrap[Instance: Bootstrap] subgraph ocmControllers[OCM Controllers] k8sResourceHelm[Resource: HelmChart] k8sResourceImage[Resource: Image] end subgraph fluxCD[FluxCD] source[OCI Repository] helmRelease[HelmRelease] end k8sResourceImage ---info[localization reference] --\u0026gt; helmRelease end end helmRelease --\u0026gt; deployment[Deployment: Helm chart] end ocmRepo --\u0026gt; k8sRepo --\u0026gt; k8sComponent --\u0026gt; k8sResourceRGD --\u0026gt; k8sDeployer --\u0026gt; rgd --\u0026gt; crdBootstrap --\u0026gt; instanceBootstrap k8sComponent --\u0026gt; k8sResourceHelm \u0026amp; k8sResourceImage k8sResourceHelm --\u0026gt; source --\u0026gt; helmRelease end linkStyle default fill:none,stroke:black,color:black; linkStyle 2,3,20 stroke:black,fill:none,color:black,stroke-dasharray: 10; linkStyle 4,5,21 stroke:black,fill:none,color:black,stroke-dasharray: 4; class start1,end1,start2,end2,start3,end3,start4,end4,start5,end5,start6,end6 legendStartEnd; class references,creates,instanceOf legendItems; class templateOf,rgdResourceHelm,rgdResourceImage,rgdSource,rgdHelmRelease templateOf; class info information; class reconciledBy,ocmK8sToolkit,bootstrap,fluxCD,kro reconciledBy; class k8sObject,rgd,k8sRepo,k8sComponent,k8sResourceRGD,k8sDeployer,k8sResourceHelm,k8sResourceImage,source,helmRelease,deployment,crdBootstrap,instanceBootstrap k8sObject; class ocmRepo,ocmCV,ocmResourceHelm,ocmResourceRGD,ocmResourceImage ocm; class k8sCluster cluster; class legend legendStyle; As the diagram shows, we will start by creating an OCM component that contains three resources:\nAn OCM Resource containing the \u0026ldquo;HelmChart\u0026rdquo; we want to deploy. An OCM Resource containing an access specification to an \u0026ldquo;Image\u0026rdquo; we want to use for the deployment and localization. An OCM Resource containing the ResourceGraphDefinition (RGD) that will deploy the Helm chart and configure the localization. To enable the bootstrap of the ResourceGraphDefinition, we will create the respective OCM controller resources that point to the OCM repository (\u0026ldquo;Repository\u0026rdquo;), the OCM component version (\u0026ldquo;Component\u0026rdquo;), and the OCM Resource (\u0026ldquo;Resource: RGD\u0026rdquo;) that contains the ResourceGraphDefinition. The OCM controller resource \u0026ldquo;Deployer\u0026rdquo; will refer to the aforementioned \u0026ldquo;Resource: RGD\u0026rdquo;, download the ResourceGraphDefinition, and apply it to the cluster.\nAfter applying the ResourceGraphDefinition, kro will reconcile it and create a Custom Resource Definition (\u0026ldquo;CRD: Bootstrap\u0026rdquo;). By creating an instance of that CRD, we will deploy the resources as defined in the ResourceGraphDefinition:\nAn OCM controller resource \u0026ldquo;HelmChart\u0026rdquo; of type Resource that contains the location of the Helm chart in its status. An OCM controller resource \u0026ldquo;Image\u0026rdquo; of type Resource that contains the localized image reference in its status. A FluxCD resource of type OCIRepository that points to the location of the Helm chart retrieved from the status of the resource \u0026ldquo;HelmChart\u0026rdquo;. A FluxCD resource of type HelmRelease that points to FluxCDs OCIRepository, gets the Helm chart, and replaces the image location in the deployment using its spec.values-field and the status of the resource \u0026ldquo;Image\u0026rdquo; that contains the localized image reference. Finally, we will check if the deployment was successful and if the localization was applied correctly.\nBefore starting, make sure you have set up your environment as described in the setup guide.\nCreate the OCM Component Version First, we will create an OCM component version containing a Helm chart, the application image that is used in the Helm chart, and the ResourceGraphDefinition that contains all required resource to deploy the Helm chart and configure the localization. For this example, we will use the podinfo Helm chart and image, which is a simple web application that serves a pod information page. For more details on how to create an OCM component version, please refer to Create Component Versions\nTo create the OCM component version, we will use the following component-constructor.yaml file:\ncomponents: - name: ocm.software/ocm-k8s-toolkit/bootstrap version: \u0026#34;1.0.0\u0026#34; provider: name: ocm.software resources: - name: helm-resource type: helmChart version: \u0026#34;1.0.0\u0026#34; access: type: ociArtifact imageReference: \u0026#34;ghcr.io/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a\u0026#34; - name: image-resource type: ociArtifact version: \u0026#34;1.0.0\u0026#34; access: type: ociRegistry imageReference: \u0026#34;ghcr.io/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb\u0026#34; - name: resource-graph-definition type: blob version: \u0026#34;1.0.0\u0026#34; input: type: file path: ./resourceGraphDefinition.yaml\rAs you can see, the resource resource-graph-definition is of type blob and contains the path to a file resourceGraphDefinition.yaml. Before we can create the OCM component version, we need to create this file, with the following content:\napiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: bootstrap spec: schema: apiVersion: v1alpha1 kind: Bootstrap resources: # In this guide, we will not create a \u0026#34;Repository\u0026#34; and \u0026#34;Component\u0026#34; resource in this ResourceGraphDefinition. Those # resources will be created to bootstrap the ResourceGraphDefinition itself and will be present in the Kubernetes # cluster to be referenced by the following resources (see the bootstrap resource in one of the following sections). # This resource refers to the resource \u0026#34;helm-resource\u0026#34; defined in the OCM component version. It will be downloaded, # verified, and its location is made available in the status of the resource. - id: resourceChart template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-helm-resource spec: # This component will be part of the bootstrap resources that will be created later. componentRef: name: bootstrap-component resource: byReference: resource: name: helm-resource interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # This resource refers to the resource \u0026#34;image-resource\u0026#34; defined in the OCM component version. It will be downloaded, # verified, and its location is made available in the status of the resource. - id: resourceImage template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-image-resource spec: # This component will be part of the bootstrap resources that will be created later. componentRef: name: bootstrap-component resource: byReference: resource: name: image-resource interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # OCIRepository watches and downloads the resource from the location provided by the Resource status. # The Helm chart location (url) refers to the status of the resource helm-resource. - id: ocirepository template: apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: bootstrap-ocirepository spec: interval: 1m0s insecure: true layerSelector: mediaType: \u0026#34;application/vnd.cncf.helm.chart.content.v1.tar+gzip\u0026#34; operation: copy url: oci://${resourceChart.status.reference.registry}/${resourceChart.status.reference.repository} ref: tag: ${resourceChart.status.reference.tag} # secretRef is required, if the OCI repository requires credentials to access it. # secretRef: # HelmRelease refers to the OCIRepository, lets you configure the helm chart and deploys the Helm Chart into the # Kubernetes cluster. - id: helmrelease template: apiVersion: helm.toolkit.fluxcd.io/v2 kind: HelmRelease metadata: name: bootstrap-helmrelease spec: releaseName: bootstrap-release interval: 1m timeout: 5m chartRef: kind: OCIRepository name: ${ocirepository.metadata.name} namespace: default values: # This is the second step of the localization. We use the image reference from the resource \u0026#34;image-resource\u0026#34; # and insert it into the Helm chart values. image: repository: ${resourceImage.status.reference.registry}/${resourceImage.status.reference.repository} tag: ${resourceImage.status.reference.tag}\rIf you plan to push your OCM component version to a private registry, you need to provide credentials for the OCM controllers and FluxCDs OCIRepository (if the Helm chart is also stored in a private registry). Accordingly, you have to specify the ocmConfig field in the Resource resources and the secretRef field in the OCIRepository.\nIf you want to use the same credentials for FluxCD and for the OCM controller resources, create a Kubernetes secret of type dockerconfigjson and keep all the resources in the same namespace.\nAfter creating both files, we can create the OCM component version using the following command:\nocm add componentversion --create --file ./ctf component-constructor.yaml\rThis will create a local CTF (Component Transfer Format) directory ./ctf containing the OCM component version. Since the OCM component version must be accessible for the OCM controllers, we will transfer the CTF to a registry. For this example, we will use GitHub\u0026rsquo;s container registry, but you can use any OCI registry. Additionally, we will use the flag --copy-resources to make sure that all referential resources, for instance the Helm chart, will be localized in the first step - so, the image reference is updated to the new registry location:\nocm transfer ctf --copy-resources ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rIf you are using a registry that requires authentication, you need to provide credentials for ocm. Please refer to the OCM CLI credentials documentation for more information on how to set up and use credentials.\nIf everything went well, you should see the following output:\nocm get componentversion ghcr.io/\u0026lt;your-namespace\u0026gt;//ocm.software/ocm-k8s-toolkit/bootstrap:1.0.0 -o yaml | yq .component.resources\r# Output is truncated for brevity - access: imageReference: ghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a type: ociArtifact digest: ... name: helm-resource relation: external type: helmChart version: 1.0.0 - access: imageReference: ghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb type: ociArtifact digest: ... name: image-resource relation: external type: ociArtifact version: 1.0.0 - access: localReference: sha256:ed5252ff70bfe93e763ff6afeafe8dafd14c128981e4ae1472e35afc3ebe7a63 mediaType: application/octet-stream type: localBlob digest: ... name: resource-graph-definition relation: local type: blob version: 1.0.0\rDeploy the Helm Chart To deploy the Helm chart from the OCM component, we first need to create all resources that are required to bootstrap the ResourceGraphDefinition from the OCM component. Afterwards, we will create an instance of the resulting Custom Resource Definition (CRD) which will deploy the Helm chart and configure the localization.\nBootstrapping The bootstrap process consists of creating the OCM controller resources that will download and apply the ResourceGraphDefinition. First, we will create a Repository and Component resource that point to the OCM component in the registry (the Component resource is reused in the ResourceGraphDefinition (see above) as reference for the Resource resources). Then, we create the Resource resource that references by name to the OCM resource containing the ResourceGraphDefinition. Finally, we will create a Deployer resource that will download the ResourceGraphDefinition and apply it to the cluster.\nTo proceed, create the following file named bootstrap.yaml containing the above-mentioned resources:\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: bootstrap-repository spec: repositorySpec: # Adjust to your OCM repository baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: bootstrap-component spec: component: ocm.software/ocm-k8s-toolkit/bootstrap repositoryRef: name: bootstrap-repository semver: 1.0.0 interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-rgd namespace: default spec: componentRef: name: bootstrap-component resource: byReference: resource: name: resource-graph-definition interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Deployer metadata: name: bootstrap-deployer spec: resourceRef: # Reference to the Kubernetes resource OCM resource that contains the ResourceGraphDefinition. name: bootstrap-rgd # As kro processes resources in cluster-scope*, the deployer must also be cluster-scoped. Accordingly, we have to # set the namespace of the resource here (usually, when the namespace is not specified, it is derived from the # referencing Kubernetes resource). # Check out the kro documentation for more details: # https://github.com/kro-run/kro/blob/8f53372bfde232db7ddd6809eebb6a1d69b34f2e/website/docs/docs/concepts/20-access-control.md namespace: default # ocmConfig is required, if the OCM repository requires credentials to access it. # (You also need to specify the namespace of the reference as the \u0026#39;deployer\u0026#39; is cluster-scoped.) # ocmConfig:\rAgain, if your OCM component version is stored in a private registry, you need to provide credentials for the OCM controller resources to access the OCM repository. You can do so by specifying the ocmConfig field in the Repository, Component, Resource, and Deployer resources. For more information on how to set up credentials, please refer to the OCM controller credentials guide.\nAfterwards, apply the bootstrap.yaml to the cluster:\nkubectl apply -f bootstrap.yaml\rThis will create all the defined resources in the cluster and reconcile them. This can take a few seconds. As a result, you should see the ResourceGraphDefinition being created in the cluster:\nkubectl get rgd\rNAME APIVERSION KIND STATE AGE bootstrap v1alpha1 Bootstrap Active 2m56s By applying the ResourceGraphDefinition successfully, a Custom Resource Definition (CRD) named Bootstrap is created in the cluster. Check if the CRD is available by using the following command:\nkubectl get crd bootstraps.kro.run\rNAME CREATED AT bootstraps.kro.run 2025-05-28T11:40:38Z Troubleshooting You can check the status of the ResourceGraphDefinition by investigating the status of the resources or the logs of the ocm-k8s-toolkit-controller-manager.\nOne common issue, when using GitHub\u0026rsquo;s container registry, is that the transferred OCM component is by default a private package. If so, you might see an error like the following:\nfailed to list versions: failed to list tags: GET \u0026#34;https://ghcr.io/v2...\u0026#34;: response status code 401: unauthorized: authentication required You can resolve this issue by making the package public or by providing credentials to the respective resources.\nCreate an Instance After applying the ResourceGraphDefinition and making sure that the resulting CRD is available, we can create an instance of the CRD, which will deploy the Helm chart and configure the localization. To do so, create a file containing the following content and name it instance.yaml:\napiVersion: kro.run/v1alpha1 kind: Bootstrap metadata: name: bootstrap\rThen, apply the instance to the cluster:\nkubectl apply -f instance.yaml\rIf successful, you should see the following output:\nkubectl get bootstrap\rNAME STATE SYNCED AGE bootstrap ACTIVE True 3m23s If the instance is in the ACTIVE state, the resources defined in the ResourceGraphDefinition were created and reconciled. This includes the OCM controller resources for the Helm chart and the image, as well as FluxCDs resources for the OCI repository and the Helm release. Accordingly, you should see the following deployment in the cluster. To see, if the deployment was successful, you can use the following command:\nkubectl get deployments\rNAME READY UP-TO-DATE AVAILABLE AGE bootstrap-release-podinfo 1/1 1 1 4m25s Finally, you can check the pod itself to see if the localization was applied correctly by checking the image name in the container::\nkubectl get pods -l app.kubernetes.io/name=bootstrap-release-podinfo -o jsonpath=\u0026#39;{.items[0].spec.containers[0].image}\u0026#39;\rghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/podinfo:6.9.1 You now have successfully created an OCM component containing a Helm chart, the respective image for localization, and a ResourceGraphDefintion to deploy your Helm chart and localize the image. By creating the required bootstrap-resources you bootstrapped the ResourceGraphDefinition from the OCM component and created the resulting CRD. Finally, you created an instance of the CRD which deployed the Helm chart and configured the localization using the OCM controllers, kro, and FluxCD.\n","date":"0001-01-01","id":23,"permalink":"/dev/docs/tutorials/deploy-a-helm-chart-with-bootstrap/","summary":"\u003cp\u003eThe \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/concepts/ocm-controllers/#concept\"\u003eOCM Components\u003c/a\u003e page and the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/getting-started/deploy-helm-charts/\"\u003eDeploy a Helm Chart\u003c/a\u003e guide showed a basic example of how to deploy a Helm chart from an OCM component.\nBy defining a \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e that contains all the required resources to deploy the Helm chart into a\nKubernetes cluster.\u003c/p\u003e","tags":[],"title":"Deploy a Helm Chart (with Bootstrap)"},{"content":"","date":"0001-01-01","id":24,"permalink":"/dev/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":25,"permalink":"/dev/community/","summary":"","tags":[],"title":"Communities"},{"content":"","date":"0001-01-01","id":26,"permalink":"/dev/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":27,"permalink":"/dev/docs/","summary":"","tags":[],"title":"Documentation"},{"content":"ocm The official Open Component Model (OCM) CLI\nSynopsis The Open Component Model command line client supports the work with OCM artifacts, like Component Archives, Common Transport Archive, Component Repositories, and Component Versions.\nocm [sub-command] [flags]\rOptions --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. -h, --help help for ocm --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm add\t- Add anything to OCM ocm completion\t- Generate the autocompletion script for the specified shell ocm describe\t- Describe OCM entities or metadata ocm download\t- Download anything from OCM ocm generate\t- Generate documentation for the OCM CLI ocm get\t- Get anything from OCM ocm plugin\t- Manage OCM plugins ocm sign\t- create signatures for component versions in OCM ocm transfer\t- Transfer anything in OCM ocm verify\t- verify digests and signatures of component versions in OCM ocm version\t- Retrieve the build version of the OCM CLI ","date":"0001-01-01","id":28,"permalink":"/dev/docs/reference/ocm-cli/ocm/","summary":"\u003ch2 id=\"ocm\"\u003eocm\u003c/h2\u003e\n\u003cp\u003eThe official Open Component Model (OCM) CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eThe Open Component Model command line client supports the work with OCM\nartifacts, like Component Archives, Common Transport Archive,\nComponent Repositories, and Component Versions.\u003c/p\u003e","tags":[],"title":"ocm"},{"content":"ocm add Add anything to OCM\nocm add {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for add\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm add component-version\t- Add component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file ","date":"0001-01-01","id":29,"permalink":"/dev/docs/reference/ocm-cli/ocm-add/","summary":"\u003ch2 id=\"ocm-add\"\u003eocm add\u003c/h2\u003e\n\u003cp\u003eAdd anything to OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for add\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-add-component-version/\"\u003eocm add component-version\u003c/a\u003e\t - Add component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm add"},{"content":"ocm add component-version Add component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file\nSynopsis Add component version(s) to an OCM repository that can be reused for transfers.\nA \u0026ldquo;component-constructor\u0026rdquo; file is used to specify the component version(s) to be added. It can contain both a single component or many components.\nBy default, the command will look for a file named \u0026ldquo;component-constructor.yaml\u0026rdquo; or \u0026ldquo;component-constructor.yml\u0026rdquo; in the current directory. If given a path to a directory, the command will look for a file named \u0026ldquo;component-constructor.yaml\u0026rdquo; or \u0026ldquo;component-constructor.yml\u0026rdquo; in that directory. If given a path to a file, the command will attempt to use that file as the \u0026ldquo;component-constructor\u0026rdquo; file.\nIf you provide a working directory, all paths in the \u0026ldquo;component-constructor\u0026rdquo; file will be resolved relative to that directory. Otherwise the path to the \u0026ldquo;component-constructor\u0026rdquo; file will be used as the working directory. You are only allowed to reference files within the working directory or sub-directories of the working directory.\nEnvironment Variable Substitution:\nThe \u0026ldquo;component-constructor\u0026rdquo; file supports environment variable substitution using Go template syntax. Variables can be referenced using ${VAR_NAME} or $VAR_NAME format. All environment variables are expanded before the file is processed, allowing for dynamic configuration of component versions, resource paths, image references, and other values.\nExample: components: - name: ${COMPONENT_NAME} version: ${COMPONENT_VERSION} provider: name: ${PROVIDER_NAME} resources: - name: my-image type: ociImage version: ${COMPONENT_VERSION} access: type: ociArtifact imageReference: ${REGISTRY_URL}/my-app:${IMAGE_TAG}\nRepository Reference Format: [type::]{repository}\nFor known types, currently only {OCIRepository|CommonTransportFormat} are supported, which can be shortened to {OCI|oci|CTF|ctf} respectively for convenience.\nIf no type is given, the repository specification is interpreted based on introspection and heuristics:\nURL schemes or domain patterns -\u0026gt; OCI registry Local paths -\u0026gt; CTF archive In case the CTF archive does not exist, it will be created by default. If not specified, it will be created with the name \u0026ldquo;transport-archive\u0026rdquo;.\nocm add component-version [flags]\rExamples Adding component versions to a CTF archive: add component-version --repository ./path/to/transport-archive --constructor ./path/to/component-constructor.yaml add component-version --repository /tmp/my-archive --constructor constructor.yaml Adding component versions to an OCI registry: add component-version --repository ghcr.io/my-org/my-repo --constructor component-constructor.yaml add component-version --repository https://my-registry.com/my-repo --constructor component-constructor.yaml add component-version --repository localhost:5000/my-repo --constructor component-constructor.yaml Specifying repository types explicitly: add component-version --repository ctf::./local/archive --constructor component-constructor.yaml add component-version --repository oci::http://localhost:8080/my-repo --constructor component-constructor.yaml Using environment variables in \u0026#34;component-constructor\u0026#34; files: export COMPONENT_NAME=\u0026#34;github.com/my-org/my-app\u0026#34; export COMPONENT_VERSION=\u0026#34;1.2.3\u0026#34; export REGISTRY_URL=\u0026#34;ghcr.io/my-org\u0026#34; add component-version --repository ./archive --constructor component-constructor.yaml\rOptions --blob-cache-directory string path to the blob cache directory (default \u0026#34;.ocm/cache\u0026#34;) --component-version-conflict-policy enum policy to apply when a component version already exists in the repository (must be one of [abort-and-fail replace skip]) (default abort-and-fail) --concurrency-limit int maximum number of component versions that can be constructed concurrently. (default 4) -c, --constructor path path to the component constructor file (default component-constructor.yaml) --display-mode enum display mode can be used in combination with --recursive static: print the output once the complete component graph is discovered live (experimental): continuously updates the output to represent the current construction state of the component graph (must be one of [live static]) (default static) --external-component-version-copy-policy enum policy to apply when a component reference to a component version outside of the constructor or target repository is encountered (must be one of [copy-or-fail skip]) (default skip) -h, --help help for component-version -o, --output enum output format of the component descriptors (must be one of [json ndjson table tree yaml]) (default table) -r, --repository string repository ref (default \u0026#34;transport-archive\u0026#34;) --skip-reference-digest-processing skip digest processing for resources and sources. Any resource referenced via access type will not have their digest updated.\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm add\t- Add anything to OCM ","date":"0001-01-01","id":30,"permalink":"/dev/docs/reference/ocm-cli/ocm-add-component-version/","summary":"\u003ch2 id=\"ocm-add-component-version\"\u003eocm add component-version\u003c/h2\u003e\n\u003cp\u003eAdd component version(s) to an OCM Repository based on a \u0026ldquo;component-constructor\u0026rdquo; file\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eAdd component version(s) to an OCM repository that can be reused for transfers.\u003c/p\u003e","tags":[],"title":"ocm add component-version"},{"content":"","date":"0001-01-01","id":31,"permalink":"/dev/docs/reference/ocm-cli/","summary":"","tags":[],"title":"OCM CLI"},{"content":"ocm completion Generate the autocompletion script for the specified shell\nSynopsis Generate the autocompletion script for ocm for the specified shell. See each sub-command\u0026rsquo;s help for details on how to use the generated script.\nOptions -h, --help help for completion\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm completion bash\t- Generate the autocompletion script for bash ocm completion fish\t- Generate the autocompletion script for fish ocm completion powershell\t- Generate the autocompletion script for powershell ocm completion zsh\t- Generate the autocompletion script for zsh ","date":"0001-01-01","id":32,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion/","summary":"\u003ch2 id=\"ocm-completion\"\u003eocm completion\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for the specified shell\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for ocm for the specified shell.\nSee each sub-command\u0026rsquo;s help for details on how to use the generated script.\u003c/p\u003e","tags":[],"title":"ocm completion"},{"content":"ocm completion bash Generate the autocompletion script for bash\nSynopsis Generate the autocompletion script for the bash shell.\nThis script depends on the \u0026lsquo;bash-completion\u0026rsquo; package. If it is not installed already, you can install it via your OS\u0026rsquo;s package manager.\nTo load completions in your current shell session:\nsource \u0026lt;(ocm completion bash) To load completions for every new session, execute once:\nLinux: ocm completion bash \u0026gt; /etc/bash_completion.d/ocm macOS: ocm completion bash \u0026gt; $(brew --prefix)/etc/bash_completion.d/ocm You will need to start a new shell for this setup to take effect.\nocm completion bash\rOptions -h, --help help for bash --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":33,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-bash/","summary":"\u003ch2 id=\"ocm-completion-bash\"\u003eocm completion bash\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for bash\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the bash shell.\u003c/p\u003e\n\u003cp\u003eThis script depends on the \u0026lsquo;bash-completion\u0026rsquo; package.\nIf it is not installed already, you can install it via your OS\u0026rsquo;s package manager.\u003c/p\u003e","tags":[],"title":"ocm completion bash"},{"content":"ocm completion fish Generate the autocompletion script for fish\nSynopsis Generate the autocompletion script for the fish shell.\nTo load completions in your current shell session:\nocm completion fish | source To load completions for every new session, execute once:\nocm completion fish \u0026gt; ~/.config/fish/completions/ocm.fish You will need to start a new shell for this setup to take effect.\nocm completion fish [flags]\rOptions -h, --help help for fish --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":34,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-fish/","summary":"\u003ch2 id=\"ocm-completion-fish\"\u003eocm completion fish\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for fish\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the fish shell.\u003c/p\u003e\n\u003cp\u003eTo load completions in your current shell session:\u003c/p\u003e","tags":[],"title":"ocm completion fish"},{"content":"ocm completion powershell Generate the autocompletion script for powershell\nSynopsis Generate the autocompletion script for powershell.\nTo load completions in your current shell session:\nocm completion powershell | Out-String | Invoke-Expression To load completions for every new session, add the output of the above command to your powershell profile.\nocm completion powershell [flags]\rOptions -h, --help help for powershell --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":35,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-powershell/","summary":"\u003ch2 id=\"ocm-completion-powershell\"\u003eocm completion powershell\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for powershell\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for powershell.\u003c/p\u003e\n\u003cp\u003eTo load completions in your current shell session:\u003c/p\u003e","tags":[],"title":"ocm completion powershell"},{"content":"ocm completion zsh Generate the autocompletion script for zsh\nSynopsis Generate the autocompletion script for the zsh shell.\nIf shell completion is not already enabled in your environment you will need to enable it. You can execute the following once:\necho \u0026quot;autoload -U compinit; compinit\u0026quot; \u0026gt;\u0026gt; ~/.zshrc To load completions in your current shell session:\nsource \u0026lt;(ocm completion zsh) To load completions for every new session, execute once:\nLinux: ocm completion zsh \u0026gt; \u0026quot;${fpath[1]}/_ocm\u0026quot; macOS: ocm completion zsh \u0026gt; $(brew --prefix)/share/zsh/site-functions/_ocm You will need to start a new shell for this setup to take effect.\nocm completion zsh [flags]\rOptions -h, --help help for zsh --no-descriptions disable completion descriptions\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm completion\t- Generate the autocompletion script for the specified shell ","date":"0001-01-01","id":36,"permalink":"/dev/docs/reference/ocm-cli/ocm-completion-zsh/","summary":"\u003ch2 id=\"ocm-completion-zsh\"\u003eocm completion zsh\u003c/h2\u003e\n\u003cp\u003eGenerate the autocompletion script for zsh\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate the autocompletion script for the zsh shell.\u003c/p\u003e\n\u003cp\u003eIf shell completion is not already enabled in your environment you will need\nto enable it.  You can execute the following once:\u003c/p\u003e","tags":[],"title":"ocm completion zsh"},{"content":"ocm describe Describe OCM entities or metadata\nocm describe [flags]\rOptions -h, --help help for describe\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm describe types\t- Describe OCM types and their configuration schema ","date":"0001-01-01","id":37,"permalink":"/dev/docs/reference/ocm-cli/ocm-describe/","summary":"\u003ch2 id=\"ocm-describe\"\u003eocm describe\u003c/h2\u003e\n\u003cp\u003eDescribe OCM entities or metadata\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm describe [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for describe\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-describe-types/\"\u003eocm describe types\u003c/a\u003e\t - Describe OCM types and their configuration schema\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm describe"},{"content":"ocm describe types Describe OCM types and their configuration schema\nSynopsis Describe OCM types registered in various subsystems.\nWHAT ARE SUBSYSTEMS? OCM uses a plugin-based architecture where different types of functionality are organized into subsystems. Each subsystem is a collection of related type implementations. When you use OCM commands or configure OCM resources, you specify types from these subsystems.\nCommon subsystems: - ocm-repository: Where component versions are stored (OCI registries, CTF archives) - ocm-resource-repository: Where resources within components are stored - input: How content is sourced (from files, directories, etc.) in component constructors - credential-repository: Where credentials are stored and retrieved - signing: How component versions are signed and verified\nHOW TO USE SUBSYSTEMS: When creating OCM configurations (YAML files) or using CLI commands, you\u0026rsquo;ll specify a \u0026rsquo;type' field. This type comes from one of the subsystems. For example:\nIn a repository configuration: type: OCIRepository/v1 # Type from ocm-repository subsystem spec: baseUrl: ghcr.io\nIn an input specification: type: dir/v1 # Type from input subsystem spec: path: ./my-content\nUse this command to: 1. Discover what subsystems exist 2. See what types are available in each subsystem 3. Learn what fields each type requires\nEXPLORATION WORKFLOW:\nList all subsystems (no arguments) Pick a subsystem and list its types (one argument: subsystem name) View field details for a specific type (two arguments: subsystem and type name) FIELD PATH NAVIGATION: You can drill into nested object fields using dot notation as an optional third argument. This shows only the fields within the specified nested structure, making it easier to explore complex schemas.\nExamples: ocm describe types ocm-repository oci baseUrl ocm describe types input file spec.file\nOUTPUT FORMATS: Use -o/\u0026ndash;output to control the format: - text: Human-readable table format (default, best for terminal) - markdown: Markdown tables (good for documentation) - html: HTML tables (good for web publishing) - jsonschema: Raw JSON Schema (only for type descriptions, not lists) - examples: Generate example YAML configuration (only for type descriptions)\nocm describe types [subsystem [type [field-path]]] [flags]\rExamples # Workflow: Setting up an OCI repository # Step 1: Discover available repository types ocm describe types ocm-repository # Step 2: Learn about the OCI repository type ocm describe types ocm-repository oci/v1 # Workflow: Configuring input methods for component creation # Step 1: See what input methods are available ocm describe types input # Step 2: Learn about the directory input type ocm describe types input dir/v1 # Other useful commands: # List all subsystems to see what\u0026#39;s available ocm describe types # Navigate into nested configuration fields ocm describe types ocm-repository oci/v1 baseUrl # List all available field paths for navigation ocm describe types input file/v1 --show-paths # Export documentation as markdown for your team ocm describe types input file -o markdown \u0026gt; signing-docs.md\rOptions -h, --help help for types -o, --output enum Output format (text, markdown, html are supported for all command combinations, jsonschema is only supported for type descriptions). (must be one of [examples html jsonschema markdown text]) (default text) --show-paths List all available field paths for the type (useful for navigation) --table-style enum table output style (must be one of [StyleColoredBright StyleColoredDark StyleDefault]) (default StyleDefault)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm describe\t- Describe OCM entities or metadata ","date":"0001-01-01","id":38,"permalink":"/dev/docs/reference/ocm-cli/ocm-describe-types/","summary":"\u003ch2 id=\"ocm-describe-types\"\u003eocm describe types\u003c/h2\u003e\n\u003cp\u003eDescribe OCM types and their configuration schema\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDescribe OCM types registered in various subsystems.\u003c/p\u003e\n\u003cp\u003eWHAT ARE SUBSYSTEMS?\nOCM uses a plugin-based architecture where different types of functionality are organized\ninto subsystems. Each subsystem is a collection of related type implementations. When you\nuse OCM commands or configure OCM resources, you specify types from these subsystems.\u003c/p\u003e","tags":[],"title":"ocm describe types"},{"content":"ocm download Download anything from OCM\nocm download {resource|resources|plugin|plugins} [flags]\rOptions -h, --help help for download\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm download plugin\t- Download plugin binaries from a component version. ocm download resource\t- Download resources described in a component version in an OCM Repository ","date":"0001-01-01","id":39,"permalink":"/dev/docs/reference/ocm-cli/ocm-download/","summary":"\u003ch2 id=\"ocm-download\"\u003eocm download\u003c/h2\u003e\n\u003cp\u003eDownload anything from OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download {resource|resources|plugin|plugins} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for download\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-plugin/\"\u003eocm download plugin\u003c/a\u003e\t - Download plugin binaries from a component version.\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-download-resource/\"\u003eocm download resource\u003c/a\u003e\t - Download resources described in a component version in an OCM Repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm download"},{"content":"ocm download plugin Download plugin binaries from a component version.\nSynopsis Download a plugin binary from a component version located in a component version.\nThis command fetches a specific plugin resource from the given OCM component version and stores it at the specified output location. The plugin binary can be identified by resource name and version, with optional extra identity parameters for platform-specific binaries.\nResources can be accessed either locally or via a plugin that supports remote fetching, with optional credential resolution.\nocm download plugin [flags]\rExamples # Download a plugin binary with resource name \u0026#39;helminput\u0026#39; and version \u0026#39;v0.0.0-main\u0026#39; ocm download plugin ghcr.io/open-component-model/plugins//ocm.software/plugins/helminput:0.0.0-main # Download a platform-specific plugin binary with extra identity parameters with specified output location. ocm download plugin ghcr.io/open-component-model/plugins//ocm.software/plugins/helminput:0.0.0-main --extra-identity os=linux,arch=amd64 --output ./plugins/ocm-plugin-linux-amd64\rOptions --extra-identity strings extra identity parameters for resource matching (e.g., os=linux,arch=amd64) -h, --help help for plugin --output string output folder to download the plugin binary to (default $HOME/.config/ocm/plugins) -f, --output-format enum output format of the plugin information, defaults to table (must be one of [json table yaml]) (default table) --plugin-type string type of the plugin resource in the component version containing the plugin binary (default \u0026#34;ocmPlugin\u0026#34;) --resource-version string version of the plugin resource to download (optional, defaults to component version) --skip-validation skip validation of the downloaded plugin binary\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm download\t- Download anything from OCM ","date":"0001-01-01","id":40,"permalink":"/dev/docs/reference/ocm-cli/ocm-download-plugin/","summary":"\u003ch2 id=\"ocm-download-plugin\"\u003eocm download plugin\u003c/h2\u003e\n\u003cp\u003eDownload plugin binaries from a component version.\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDownload a plugin binary from a component version located in a component version.\u003c/p\u003e","tags":[],"title":"ocm download plugin"},{"content":"ocm download resource Download resources described in a component version in an OCM Repository\nSynopsis Download a resource from a component version located in an Open Component Model (OCM) repository.\nThis command fetches a specific resource from the given OCM component version reference and stores it at the specified output location. It supports optional transformation of the resource using a registered transformer plugin.\nIf no transformer is specified, the resource is written directly in its original format. If the media type is known, the appropriate file extension will be added to the output file name if no output location is given.\nResources can be accessed either locally or via a plugin that supports remote fetching, with optional credential resolution.\nocm download resource [flags]\rExamples # Download a resource with identity \u0026#39;name=example\u0026#39; and write to default output ocm download resource ghcr.io/org/component:v1 --identity name=example # Download a resource and specify an output file ocm download resource ghcr.io/org/component:v1 --identity name=example --output ./my-resource.tar.gz # Download a resource and apply a transformer ocm download resource ghcr.io/org/component:v1 --identity name=example --transformer my-transformer\rOptions --extraction-policy enum policy to apply when extracting a resource. If set to \u0026#39;disable\u0026#39;, the resource will not be extracted, even if they could be. If set to \u0026#39;auto\u0026#39;, the resource will be automatically extracted if the returned resource is a recognized archive format. (must be one of [auto disable]) (default auto) -h, --help help for resource --identity string resource identity to download --output string output location to download to. If no transformer is specified, and no format was discovered that can be written to a directory, the resource will be written to a file. --transformer string transformer to use for the output. If not specified, the resource will be written as is. Options inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm download\t- Download anything from OCM ","date":"0001-01-01","id":41,"permalink":"/dev/docs/reference/ocm-cli/ocm-download-resource/","summary":"\u003ch2 id=\"ocm-download-resource\"\u003eocm download resource\u003c/h2\u003e\n\u003cp\u003eDownload resources described in a component version in an OCM Repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDownload a resource from a component version located in an Open Component Model (OCM) repository.\u003c/p\u003e","tags":[],"title":"ocm download resource"},{"content":"ocm generate Generate documentation for the OCM CLI\nSynopsis A longer description that spans multiple lines and likely contains examples and usage of using your command. For example:\nCobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.\nOptions -h, --help help for generate\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm generate docs\t- Generate Documentation for the CLI ","date":"0001-01-01","id":42,"permalink":"/dev/docs/reference/ocm-cli/ocm-generate/","summary":"\u003ch2 id=\"ocm-generate\"\u003eocm generate\u003c/h2\u003e\n\u003cp\u003eGenerate documentation for the OCM CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eA longer description that spans multiple lines and likely contains examples\nand usage of using your command. For example:\u003c/p\u003e","tags":[],"title":"ocm generate"},{"content":"ocm generate docs Generate Documentation for the CLI\nSynopsis Generate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.\nocm generate docs [-d \u0026lt;directory\u0026gt;] [--mode \u0026lt;format\u0026gt;] [flags]\rOptions -d, --directory string directory to generate docs to. If not set, current working directory is used. -h, --help help for docs --mode enum generation mode to use (must be one of [hugo man markdown restructured yaml]) (default markdown)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm generate\t- Generate documentation for the OCM CLI ","date":"0001-01-01","id":43,"permalink":"/dev/docs/reference/ocm-cli/ocm-generate-docs/","summary":"\u003ch2 id=\"ocm-generate-docs\"\u003eocm generate docs\u003c/h2\u003e\n\u003cp\u003eGenerate Documentation for the CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGenerate documentation for the OCM CLI in various formats, including Hugo-compatible markdown.\u003c/p\u003e","tags":[],"title":"ocm generate docs"},{"content":"ocm get Get anything from OCM\nocm get {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for get\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm get component-version\t- Get component version(s) from an OCM repository ocm get types\t- Describe OCM types and their configuration schema ","date":"0001-01-01","id":44,"permalink":"/dev/docs/reference/ocm-cli/ocm-get/","summary":"\u003ch2 id=\"ocm-get\"\u003eocm get\u003c/h2\u003e\n\u003cp\u003eGet anything from OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for get\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-get-component-version/\"\u003eocm get component-version\u003c/a\u003e\t - Get component version(s) from an OCM repository\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-get-types/\"\u003eocm get types\u003c/a\u003e\t - Describe OCM types and their configuration schema\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm get"},{"content":"ocm get component-version Get component version(s) from an OCM repository\nSynopsis Get component version(s) from an OCM repository.\nThe format of a component reference is: [type::]{repository}/[valid-prefix]/{component}[:version]\nFor valid prefixes {component-descriptors|none} are available. If is used, it defaults to \u0026ldquo;component-descriptors\u0026rdquo;. This is because by default, OCM components are stored within a specific sub-repository.\nFor known types, currently only {OCIRepository|CommonTransportFormat} are supported, which can be shortened to {OCI|oci|CTF|ctf} respectively for convenience.\nIf no type is given, the repository path is interpreted based on introspection and heuristics.\nocm get component-version {reference} [flags]\rExamples Getting a single component version: get component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 get cv ./path/to/ctf//ocm.software/ocmcli:0.23.0 get cv ./path/to/ctf/component-descriptors/ocm.software/ocmcli:0.23.0 Listing many component versions: get component-versions ghcr.io/open-component-model/ocm//ocm.software/ocmcli get cvs ghcr.io/open-component-model/ocm//ocm.software/ocmcli --output json get cvs ghcr.io/open-component-model/ocm//ocm.software/ocmcli -oyaml Specifying types and schemes: get cv ctf::github.com/locally-checked-out-repo//ocm.software/ocmcli:0.23.0 get cvs oci::http://localhost:8080//ocm.software/ocmcli\rOptions --display-mode enum display mode can be used in combination with --recursive static: print the output once the complete component graph is discovered live (experimental): continuously updates the output to represent the current discovery state of the component graph (must be one of [live static]) (default static) -h, --help help for component-version --latest if set, only the latest version of the component is returned -o, --output enum output format of the component descriptors (must be one of [json ndjson table tree yaml]) (default table) --recursive int[=-1] depth of recursion for resolving referenced component versions (0=none, -1=unlimited, \u0026gt;0=levels (not implemented yet)) --semver-constraint string semantic version constraint restricting which versions to output (default \u0026#34;\u0026gt; 0.0.0-0\u0026#34;)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm get\t- Get anything from OCM ","date":"0001-01-01","id":45,"permalink":"/dev/docs/reference/ocm-cli/ocm-get-component-version/","summary":"\u003ch2 id=\"ocm-get-component-version\"\u003eocm get component-version\u003c/h2\u003e\n\u003cp\u003eGet component version(s) from an OCM repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eGet component version(s) from an OCM repository.\u003c/p\u003e\n\u003cp\u003eThe format of a component reference is:\n[type::]{repository}/[valid-prefix]/{component}[:version]\u003c/p\u003e","tags":[],"title":"ocm get component-version"},{"content":"ocm get types Describe OCM types and their configuration schema\nSynopsis Describe OCM types registered in various subsystems.\nWHAT ARE SUBSYSTEMS? OCM uses a plugin-based architecture where different types of functionality are organized into subsystems. Each subsystem is a collection of related type implementations. When you use OCM commands or configure OCM resources, you specify types from these subsystems.\nCommon subsystems: - ocm-repository: Where component versions are stored (OCI registries, CTF archives) - ocm-resource-repository: Where resources within components are stored - input: How content is sourced (from files, directories, etc.) in component constructors - credential-repository: Where credentials are stored and retrieved - signing: How component versions are signed and verified\nHOW TO USE SUBSYSTEMS: When creating OCM configurations (YAML files) or using CLI commands, you\u0026rsquo;ll specify a \u0026rsquo;type' field. This type comes from one of the subsystems. For example:\nIn a repository configuration: type: OCIRepository/v1 # Type from ocm-repository subsystem spec: baseUrl: ghcr.io\nIn an input specification: type: dir/v1 # Type from input subsystem spec: path: ./my-content\nUse this command to: 1. Discover what subsystems exist 2. See what types are available in each subsystem 3. Learn what fields each type requires\nEXPLORATION WORKFLOW:\nList all subsystems (no arguments) Pick a subsystem and list its types (one argument: subsystem name) View field details for a specific type (two arguments: subsystem and type name) FIELD PATH NAVIGATION: You can drill into nested object fields using dot notation as an optional third argument. This shows only the fields within the specified nested structure, making it easier to explore complex schemas.\nExamples: ocm describe types ocm-repository oci baseUrl ocm describe types input file spec.file\nOUTPUT FORMATS: Use -o/\u0026ndash;output to control the format: - text: Human-readable table format (default, best for terminal) - markdown: Markdown tables (good for documentation) - html: HTML tables (good for web publishing) - jsonschema: Raw JSON Schema (only for type descriptions, not lists) - examples: Generate example YAML configuration (only for type descriptions)\nocm get types [subsystem [type [field-path]]] [flags]\rExamples # Workflow: Setting up an OCI repository # Step 1: Discover available repository types ocm describe types ocm-repository # Step 2: Learn about the OCI repository type ocm describe types ocm-repository oci/v1 # Workflow: Configuring input methods for component creation # Step 1: See what input methods are available ocm describe types input # Step 2: Learn about the directory input type ocm describe types input dir/v1 # Other useful commands: # List all subsystems to see what\u0026#39;s available ocm describe types # Navigate into nested configuration fields ocm describe types ocm-repository oci/v1 baseUrl # List all available field paths for navigation ocm describe types input file/v1 --show-paths # Export documentation as markdown for your team ocm describe types input file -o markdown \u0026gt; signing-docs.md\rOptions -h, --help help for types -o, --output enum Output format (text, markdown, html are supported for all command combinations, jsonschema is only supported for type descriptions). (must be one of [examples html jsonschema markdown text]) (default text) --show-paths List all available field paths for the type (useful for navigation) --table-style enum table output style (must be one of [StyleColoredBright StyleColoredDark StyleDefault]) (default StyleDefault)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm get\t- Get anything from OCM ","date":"0001-01-01","id":46,"permalink":"/dev/docs/reference/ocm-cli/ocm-get-types/","summary":"\u003ch2 id=\"ocm-get-types\"\u003eocm get types\u003c/h2\u003e\n\u003cp\u003eDescribe OCM types and their configuration schema\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eDescribe OCM types registered in various subsystems.\u003c/p\u003e\n\u003cp\u003eWHAT ARE SUBSYSTEMS?\nOCM uses a plugin-based architecture where different types of functionality are organized\ninto subsystems. Each subsystem is a collection of related type implementations. When you\nuse OCM commands or configure OCM resources, you specify types from these subsystems.\u003c/p\u003e","tags":[],"title":"ocm get types"},{"content":"ocm plugin Manage OCM plugins\nocm plugin [flags]\rOptions -h, --help help for plugin\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm plugin registry\t- Manage plugin registries ","date":"0001-01-01","id":47,"permalink":"/dev/docs/reference/ocm-cli/ocm-plugin/","summary":"\u003ch2 id=\"ocm-plugin\"\u003eocm plugin\u003c/h2\u003e\n\u003cp\u003eManage OCM plugins\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm plugin [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for plugin\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-plugin-registry/\"\u003eocm plugin registry\u003c/a\u003e\t - Manage plugin registries\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm plugin"},{"content":"ocm plugin registry Manage plugin registries\nocm plugin registry {get|list} [flags]\rOptions -h, --help help for registry\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm plugin\t- Manage OCM plugins ocm plugin registry get\t- Get information about specified plugin from a plugin registry. ocm plugin registry list\t- List available plugin binaries from a plugin registry. ","date":"0001-01-01","id":48,"permalink":"/dev/docs/reference/ocm-cli/ocm-plugin-registry/","summary":"\u003ch2 id=\"ocm-plugin-registry\"\u003eocm plugin registry\u003c/h2\u003e\n\u003cp\u003eManage plugin registries\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm plugin registry {get|list} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for registry\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-plugin/\"\u003eocm plugin\u003c/a\u003e\t - Manage OCM plugins\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-plugin-registry-get/\"\u003eocm plugin registry get\u003c/a\u003e\t - Get information about specified plugin from a plugin registry.\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-plugin-registry-list/\"\u003eocm plugin registry list\u003c/a\u003e\t - List available plugin binaries from a plugin registry.\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm plugin registry"},{"content":"ocm plugin registry get Get information about specified plugin from a plugin registry.\nocm plugin registry get \u0026lt;plugin-name[:version]\u0026gt; [flags]\rExamples # Get information about specified plugin from a plugin registry. ocm plugin registry get helminput\rOptions --component-descriptor return component descriptors of the plugins -h, --help help for get -o, --output enum output format of the plugin list (must be one of [json ndjson table yaml]) (default table) --registry string registry URL to list plugins from --version string specific version of the plugin to display (default: latest version)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm plugin registry\t- Manage plugin registries ","date":"0001-01-01","id":49,"permalink":"/dev/docs/reference/ocm-cli/ocm-plugin-registry-get/","summary":"\u003ch2 id=\"ocm-plugin-registry-get\"\u003eocm plugin registry get\u003c/h2\u003e\n\u003cp\u003eGet information about specified plugin from a plugin registry.\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm plugin registry get \u0026lt;plugin-name[:version]\u0026gt; [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"examples\"\u003eExamples\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  # Get information about specified plugin from a plugin registry.\n  ocm plugin registry get helminput\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --component-descriptor   return component descriptors of the plugins\n  -h, --help                   help for get\n  -o, --output enum            output format of the plugin list\n                               (must be one of [json ndjson table yaml]) (default table)\n      --registry string        registry URL to list plugins from\n      --version string         specific version of the plugin to display (default: latest version)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-plugin-registry/\"\u003eocm plugin registry\u003c/a\u003e\t - Manage plugin registries\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm plugin registry get"},{"content":"ocm plugin registry list List available plugin binaries from a plugin registry.\nocm plugin registry list [flags]\rExamples # List available plugin binaries from a registry using the flag. ocm plugin registry list --registry ocm.software/plugin-registry:v1.0.0\rOptions -h, --help help for list -o, --output enum output format of the plugin list (must be one of [json ndjson table wide yaml]) (default table) --registry string registry URL to list plugins from\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm plugin registry\t- Manage plugin registries ","date":"0001-01-01","id":50,"permalink":"/dev/docs/reference/ocm-cli/ocm-plugin-registry-list/","summary":"\u003ch2 id=\"ocm-plugin-registry-list\"\u003eocm plugin registry list\u003c/h2\u003e\n\u003cp\u003eList available plugin binaries from a plugin registry.\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm plugin registry list [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"examples\"\u003eExamples\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  # List available plugin binaries from a registry using the flag.\n  ocm plugin registry list --registry ocm.software/plugin-registry:v1.0.0\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help              help for list\n  -o, --output enum       output format of the plugin list\n                          (must be one of [json ndjson table wide yaml]) (default table)\n      --registry string   registry URL to list plugins from\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-plugin-registry/\"\u003eocm plugin registry\u003c/a\u003e\t - Manage plugin registries\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm plugin registry list"},{"content":"ocm sign create signatures for component versions in OCM\nocm sign {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for sign\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm sign component-version\t- Sign component version(s) inside an OCM repository ","date":"0001-01-01","id":51,"permalink":"/dev/docs/reference/ocm-cli/ocm-sign/","summary":"\u003ch2 id=\"ocm-sign\"\u003eocm sign\u003c/h2\u003e\n\u003cp\u003ecreate signatures for component versions in OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm sign {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for sign\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-sign-component-version/\"\u003eocm sign component-version\u003c/a\u003e\t - Sign component version(s) inside an OCM repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm sign"},{"content":"ocm sign component-version Sign component version(s) inside an OCM repository\nSynopsis Creates or update cryptographic signatures on component descriptors.\nReference Format [type::]{repository}/[valid-prefix]/{component}[:version] Prefixes: {component-descriptors|none} (default: \u0026ldquo;component-descriptors\u0026rdquo;) Repo types: {OCIRepository|CommonTransportFormat} (short: {OCI|oci|CTF|ctf}) OCM Signing explained in simple steps Resolve OCM repository Fetch component version Verify digests (\u0026ndash;verify-digest-consistency) Normalise descriptor (\u0026ndash;normalisation) Hash normalised descriptor (\u0026ndash;hash) Sign hash (\u0026ndash;signer-spec) Behavior Conflicting signatures cause failure unless \u0026ndash;force is set (then overwrite) \u0026ndash;dry-run: compute only, do not persist signature Default signature name: default Default signer: RSASSA-PSS plugin (needs private key) Use this command to establish provenance of component versions.\nocm sign component-version {reference} [flags]\rExamples # Sign a component version with default algorithms sign component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 ## Example Credential Config type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: default credentials: - type: Credentials/v1 properties: private_key_pem: \u0026lt;PEM\u0026gt; # Sign with custom signature name sign component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 --signature my-signature # Use a signer specification file sign component-version ./repo/ocm//ocm.software/ocmcli:0.23.0 --signer-spec ./rsassa-pss.yaml # Dry-run signing sign component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 --signature test --dry-run # Force overwrite an existing signature sign component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 --signature my-signature --force\rOptions --concurrency-limit int maximum amount of parallel requests to the repository for resolving component versions (default 4) --dry-run compute signature but do not persist it to the repository --force overwrite existing signatures under the same name --hash string hash algorithm to use (SHA256, SHA512) (default \u0026#34;SHA-256\u0026#34;) -h, --help help for component-version --normalisation string normalisation algorithm to use (default jsonNormalisation/v4alpha1) (default \u0026#34;jsonNormalisation/v4alpha1\u0026#34;) -o, --output enum output format of the resulting signature (must be one of [json yaml]) (default yaml) --signature string name of the signature to create or update. defaults to \u0026#34;default\u0026#34; (default \u0026#34;default\u0026#34;) --signer-spec string path to a signer specification file. If empty, defaults to an empty RSASSA-PSS configuration.\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm sign\t- create signatures for component versions in OCM ","date":"0001-01-01","id":52,"permalink":"/dev/docs/reference/ocm-cli/ocm-sign-component-version/","summary":"\u003ch2 id=\"ocm-sign-component-version\"\u003eocm sign component-version\u003c/h2\u003e\n\u003cp\u003eSign component version(s) inside an OCM repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eCreates or update cryptographic signatures on component descriptors.\u003c/p\u003e\n\u003ch2 id=\"reference-format\"\u003eReference Format\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e[type::]{repository}/[valid-prefix]/{component}[:version]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ePrefixes: {component-descriptors|none} (default: \u0026ldquo;component-descriptors\u0026rdquo;)\u003c/li\u003e\n\u003cli\u003eRepo types: {OCIRepository|CommonTransportFormat} (short: {OCI|oci|CTF|ctf})\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ocm-signing-explained-in-simple-steps\"\u003eOCM Signing explained in simple steps\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eResolve OCM repository\u003c/li\u003e\n\u003cli\u003eFetch component version\u003c/li\u003e\n\u003cli\u003eVerify digests (\u0026ndash;verify-digest-consistency)\u003c/li\u003e\n\u003cli\u003eNormalise descriptor (\u0026ndash;normalisation)\u003c/li\u003e\n\u003cli\u003eHash normalised descriptor (\u0026ndash;hash)\u003c/li\u003e\n\u003cli\u003eSign hash (\u0026ndash;signer-spec)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"behavior\"\u003eBehavior\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eConflicting signatures cause failure unless \u0026ndash;force is set (then overwrite)\u003c/li\u003e\n\u003cli\u003e\u0026ndash;dry-run: compute only, do not persist signature\u003c/li\u003e\n\u003cli\u003eDefault signature name: default\u003c/li\u003e\n\u003cli\u003eDefault signer: RSASSA-PSS plugin (needs private key)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUse this command to establish provenance of component versions.\u003c/p\u003e","tags":[],"title":"ocm sign component-version"},{"content":"ocm transfer Transfer anything in OCM\nocm transfer {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for transfer\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm transfer component-version\t- Transfer a component version between OCM repositories ","date":"0001-01-01","id":53,"permalink":"/dev/docs/reference/ocm-cli/ocm-transfer/","summary":"\u003ch2 id=\"ocm-transfer\"\u003eocm transfer\u003c/h2\u003e\n\u003cp\u003eTransfer anything in OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm transfer {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for transfer\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-transfer-component-version/\"\u003eocm transfer component-version\u003c/a\u003e\t - Transfer a component version between OCM repositories\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm transfer"},{"content":"ocm transfer component-version Transfer a component version between OCM repositories\nSynopsis Transfer a single component version from a source repository to a target repository using an internally generated transformation graph.\nThis command constructs a TransformationGraphDefinition consisting of:\nCTFGetComponentVersion / OCIGetComponentVersion CTFAddComponentVersion / OCIAddComponentVersion GetOCIArtifact / OCIAddLocalResource We support OCI and CTF repositories as source and target, and the graph is built accordingly based on the provided references. By default, only the component version itself is transferred, but with \u0026ndash;copy-resources, all resources are also copied and transformed if necessary.\nThe graph is validated, and then executed unless \u0026ndash;dry-run is set.\nocm transfer component-version {reference} {target} [flags]\rExamples # Transfer a component version from a CTF archive to an OCI registry transfer component-version ctf::./my-archive//ocm.software/mycomponent:1.0.0 ghcr.io/my-org/ocm # Transfer from one OCI registry to another transfer component-version ghcr.io/source-org/ocm//ocm.software/mycomponent:1.0.0 ghcr.io/target-org/ocm # Transfer from one OCI to another using localBlobs transfer component-version ghcr.io/source-org/ocm//ocm.software/mycomponent:1.0.0 ghcr.io/target-org/ocm --copy-resources --upload-as localBlob # Transfer from one OCI to another using OCI artifacts (default) transfer component-version ghcr.io/source-org/ocm//ocm.software/mycomponent:1.0.0 ghcr.io/target-org/ocm --copy-resources --upload-as ociArtifact # Transfer including all resources (e.g. OCI artifacts) transfer component-version ctf::./my-archive//ocm.software/mycomponent:1.0.0 ghcr.io/my-org/ocm --copy-resources # Recursively transfer a component version and all its references transfer component-version ghcr.io/source-org/ocm//ocm.software/mycomponent:1.0.0 ghcr.io/target-org/ocm -r --copy-resources\rOptions --copy-resources copy all resources in the component version --dry-run build and validate the graph but do not execute -h, --help help for component-version -o, --output enum output format of the component descriptors (must be one of [json ndjson yaml]) (default yaml) -r, --recursive recursively discover and transfer component versions -u, --upload-as enum Define whether copied resources should be uploaded as OCI artifacts (instead of local blob resources). This option is only relevant if --copy-resources is set. (must be one of [default localBlob ociArtifact]) (default default)\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm transfer\t- Transfer anything in OCM ","date":"0001-01-01","id":54,"permalink":"/dev/docs/reference/ocm-cli/ocm-transfer-component-version/","summary":"\u003ch2 id=\"ocm-transfer-component-version\"\u003eocm transfer component-version\u003c/h2\u003e\n\u003cp\u003eTransfer a component version between OCM repositories\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eTransfer a single component version from a source repository to\na target repository using an internally generated transformation graph.\u003c/p\u003e","tags":[],"title":"ocm transfer component-version"},{"content":"ocm verify verify digests and signatures of component versions in OCM\nocm verify {component-version|component-versions|cv|cvs} [flags]\rOptions -h, --help help for verify\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ocm verify component-version\t- Verify component version(s) inside an OCM repository ","date":"0001-01-01","id":55,"permalink":"/dev/docs/reference/ocm-cli/ocm-verify/","summary":"\u003ch2 id=\"ocm-verify\"\u003eocm verify\u003c/h2\u003e\n\u003cp\u003everify digests and signatures of component versions in OCM\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm verify {component-version|component-versions|cv|cvs} [flags]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for verify\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options-inherited-from-parent-commands\"\u003eOptions inherited from parent commands\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --config string                      supply configuration by a given configuration file.\n                                           By default (without specifying custom locations with this flag), the file will be read from one of the well known locations:\n                                           1. The path specified in the OCM_CONFIG environment variable\n                                           2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory\n                                           - $XDG_CONFIG_HOME/ocm/config\n                                           - $XDG_CONFIG_HOME/.ocmconfig\n                                           - $HOME/.config/ocm/config\n                                           - $HOME/.config/.ocmconfig\n                                           - $HOME/.ocm/config\n                                           - $HOME/.ocmconfig\n                                           3. The current working directory:\n                                           - $PWD/ocm/config\n                                           - $PWD/.ocmconfig\n                                           4. The directory of the current executable:\n                                           - $EXE_DIR/ocm/config\n                                           - $EXE_DIR/.ocmconfig\n                                           Using the option, this configuration file be used instead of the lookup above.\n      --logformat enum                     set the log output format that is used to print individual logs\n                                              json: Output logs in JSON format, suitable for machine processing\n                                              text: Output logs in human-readable text format, suitable for console output\n                                           (must be one of [json text]) (default text)\n      --loglevel enum                      sets the logging level\n                                              debug: Show all logs including detailed debugging information\n                                              info:  Show informational messages and above\n                                              warn:  Show warnings and errors only (default)\n                                              error: Show errors only\n                                           (must be one of [debug error info warn]) (default info)\n      --logoutput enum                     set the log output destination\n                                              stdout: Write logs to standard output\n                                              stderr: Write logs to standard error, useful for separating logs from normal output\n                                           (must be one of [stderr stdout]) (default stderr)\n      --plugin-directory string            default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;)\n      --plugin-shutdown-timeout duration   Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s)\n      --temp-folder string                 Specify a custom temporary folder path for filesystem operations.\n      --working-directory string           Specify a custom working directory path to load resources from.\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSEE ALSO\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm/\"\u003eocm\u003c/a\u003e\t - The official Open Component Model (OCM) CLI\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/dev/docs/reference/ocm-cli/ocm-verify-component-version/\"\u003eocm verify component-version\u003c/a\u003e\t - Verify component version(s) inside an OCM repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"ocm verify"},{"content":"ocm verify component-version Verify component version(s) inside an OCM repository\nSynopsis Verify component version(s) inside an OCM repository based on signatures.\nReference Format [type::]{repository}/[valid-prefix]/{component}[:version] Prefixes: {component-descriptors|none} (default: \u0026ldquo;component-descriptors\u0026rdquo;) Repo types: {OCIRepository|CommonTransportFormat} (short: {OCI|oci|CTF|ctf}) OCM Verification explained in simple steps Resolve OCM repository Fetch component version Normalise descriptor (algorithm from signature) Recompute hash and compare with signature digest Verify signature (\u0026ndash;verifier-spec, default RSASSA-PSS verifier) Behavior \u0026ndash;signature: verify only the named signature Without \u0026ndash;signature: verify all signatures Fail fast on first invalid signature Default verifier: RSASSA-PSS plugin Supports config-less verification Uses discovered credentials or PEM certificates when possible Use to validate component versions before promotion, deployment, or further usage to ensure integrity and provenance.\nocm verify component-version {reference} [flags]\rExamples # Verify all component version signatures found in a component version verify component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 ## Example Credential Config type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: RSA/v1alpha1 algorithm: RSASSA-PSS signature: default credentials: - type: Credentials/v1 properties: public_key_pem: \u0026lt;PEM\u0026gt; # Verify a specific signature sign component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 --signature my-signature # Use a verifier specification file sign component-version ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.23.0 --verifier-spec ./rsassa-pss.yaml\rOptions --concurrency-limit int maximum amount of parallel requests to the repository for resolving component versions (default 4) -h, --help help for component-version --signature string name of the signature to verify. If not set, all signatures are verified. --verifier-spec string path to an optional verifier specification file. If empty, defaults to an empty RSASSA-PSS configuration.\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm verify\t- verify digests and signatures of component versions in OCM ","date":"0001-01-01","id":56,"permalink":"/dev/docs/reference/ocm-cli/ocm-verify-component-version/","summary":"\u003ch2 id=\"ocm-verify-component-version\"\u003eocm verify component-version\u003c/h2\u003e\n\u003cp\u003eVerify component version(s) inside an OCM repository\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eVerify component version(s) inside an OCM repository based on signatures.\u003c/p\u003e","tags":[],"title":"ocm verify component-version"},{"content":"ocm version Retrieve the build version of the OCM CLI\nSynopsis The version command retrieves the build version of the OCM CLI.\nThe build version can be formatted in different ways depending on the specified format flag. The default format is \u0026ldquo;legacyjson\u0026rdquo;, which outputs the version in a format compatible with OCM v1 specifications, with slight modifications:\n\u0026ldquo;gitTreeState\u0026rdquo; is removed in favor of \u0026ldquo;meta\u0026rdquo; field, which contains the git tree state. \u0026ldquo;buildDate\u0026rdquo; and \u0026ldquo;gitCommit\u0026rdquo; are derived from the input version string, and are parsed according to the go module version specification. When the format is set to \u0026ldquo;gobuildinfo\u0026rdquo;, it outputs the Go build information as a string. The format is standardized and unified across all golang applications.\nWhen the format is set to \u0026ldquo;gobuildinfojson\u0026rdquo;, it outputs the Go build information in JSON format. This is equivalent to \u0026ldquo;gobuildinfo\u0026rdquo;, but in a structured JSON format.\nThe build info by default is drawn from the go module build information, which is set at build time of the CLI. When officially built, it is possibly overwritten with the released version of the OCM CLI.\nocm version [flags]\rExamples ocm version --format legacyjson\rOptions -f, --format string format of the generated documentation (default \u0026#34;legacyjson\u0026#34;) -h, --help help for version\rOptions inherited from parent commands --config string supply configuration by a given configuration file. By default (without specifying custom locations with this flag), the file will be read from one of the well known locations: 1. The path specified in the OCM_CONFIG environment variable 2. The XDG_CONFIG_HOME directory (if set), or the default XDG home ($HOME/.config), or the user\u0026#39;s home directory - $XDG_CONFIG_HOME/ocm/config - $XDG_CONFIG_HOME/.ocmconfig - $HOME/.config/ocm/config - $HOME/.config/.ocmconfig - $HOME/.ocm/config - $HOME/.ocmconfig 3. The current working directory: - $PWD/ocm/config - $PWD/.ocmconfig 4. The directory of the current executable: - $EXE_DIR/ocm/config - $EXE_DIR/.ocmconfig Using the option, this configuration file be used instead of the lookup above. --logformat enum set the log output format that is used to print individual logs json: Output logs in JSON format, suitable for machine processing text: Output logs in human-readable text format, suitable for console output (must be one of [json text]) (default text) --loglevel enum sets the logging level debug: Show all logs including detailed debugging information info: Show informational messages and above warn: Show warnings and errors only (default) error: Show errors only (must be one of [debug error info warn]) (default info) --logoutput enum set the log output destination stdout: Write logs to standard output stderr: Write logs to standard error, useful for separating logs from normal output (must be one of [stderr stdout]) (default stderr) --plugin-directory string default directory path for ocm plugins. (default \u0026#34;$HOME/.config/ocm/plugins\u0026#34;) --plugin-shutdown-timeout duration Timeout for plugin shutdown. If a plugin does not shut down within this time, it is forcefully killed (default 10s) --temp-folder string Specify a custom temporary folder path for filesystem operations. --working-directory string Specify a custom working directory path to load resources from.\rSEE ALSO ocm\t- The official Open Component Model (OCM) CLI ","date":"0001-01-01","id":57,"permalink":"/dev/docs/reference/ocm-cli/ocm-version/","summary":"\u003ch2 id=\"ocm-version\"\u003eocm version\u003c/h2\u003e\n\u003cp\u003eRetrieve the build version of the OCM CLI\u003c/p\u003e\n\u003ch3 id=\"synopsis\"\u003eSynopsis\u003c/h3\u003e\n\u003cp\u003eThe version command retrieves the build version of the OCM CLI.\u003c/p\u003e","tags":[],"title":"ocm version"},{"content":"","date":"0001-01-01","id":58,"permalink":"/dev/","summary":"","tags":[],"title":"Open Component Model"},{"content":"","date":"0001-01-01","id":59,"permalink":"/dev/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"","date":"0001-01-01","id":60,"permalink":"/dev/tags/","summary":"","tags":[],"title":"Tags"},{"content":"How to engage with us The Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\nGitHub Our GitHub repositories are the central hub for all project development. Connect with our codebase, report issues, submit pull requests, and follow our project\u0026rsquo;s progress. New contributors can find issues labeled good first issue to get started, and our detailed contribution guidelines will help you make your first successful submission.\nSlack Join our #open-component-model channel in the Kubernetes Slack workspace and connect with us and other community members.\nKubernetes Slack Membership\nIf you aren\u0026rsquo;t already a member in the Kubernetes Slack workspace, please request an invitation\nOur team is passionate about delving into diverse deployment processes, exploring patterns, aiding in design, and troubleshooting issues. Who knows? Your inquiry might inspire the development of the next useful OCM feature!\nCommunity Calls We\u0026rsquo;re excited to announce our regular community calls:\nSchedule Frequency: Every first Wednesday of the months Time: 16:00-17:00 UTC (17:00-18:00 CET, 11:00-12:00 EST, 08:00-09:00 PST) Duration: 1 hour Location: Use this Zoom Link to join the call. Call History This page contains the history of the Open Component Model community calls and links to slides and recordings.\nWhat to Expect Join us to see and discuss project updates, share your feedback, ask questions, and connect with other community members. The community calls should be an open discussion space and give a voice to any interested stakeholder. At the same time we want our community to be diverse, helpful, collaborative and fun.\nThese calls are open to everyone and will be moderated by at least one OCM Core Maintainer. We will answer anything you might bring up!\nWhat to Bring We want to hear from you! This is your chance to share your thoughts and ideas with the community. You can bring anything, including:\nIdeas how to make OCM better Issues you would like to talk about and that should be addressed Concepts you would like to work on together Questions you have about the community or upcoming work Contributing We welcome community contributions! Please see the Contributing Guideline for instructions on how to submit changes. If you are planning on making more elaborate or potentially controversial changes, please discuss them with the maintainers in the Slack channel before sending a pull request.\nCode of Conduct To make OCM a welcoming and harassment-free experience for everyone, we follow the CNCF Code of Conduct.\nSpecial Interest Groups (SIGs) OCM grows when people build together ‚Äî and our Special Interest Groups (SIGs) are where ideas turn into impact.\nSIGs are focused working groups that take ownership of a specific area of the project and move it forward.\nFollowing the example of other CNCF projects, we defined a framework for SIGs to help contributors collaborate effectively.\nThe SIG Handbook covers:\ngoals and motivation behind SIGs roles and responsibilities how to propose, establish, and run a SIG Status: We‚Äôre in the kick-off phase ‚Äî there are no active SIGs yet. That‚Äôs your chance to shape the very first ones! As SIGs form, we‚Äôll list them here.\nHow to get involved Curious? Start with the SIG Handbook. Have a topic in mind? Follow the handbook‚Äôs steps to propose a SIG and gather interested contributors. Prefer to join later? Keep an eye on this page ‚Äî we‚Äôll announce and list new SIGs here. Security Guideline In case you want to report any security vulnerabilities inside the Open Component Model project, please do not report them through public GitHub issues.\nPlease visit the Open Source Security Policy for more information.\n","date":"0001-01-01","id":61,"permalink":"/dev/community/engagement/","summary":"\u003ch2 id=\"how-to-engage-with-us\"\u003eHow to engage with us\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\u003c/p\u003e","tags":[],"title":"The OCM Community"}]