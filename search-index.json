[{"content":"","date":"0001-01-01","id":0,"permalink":"/docs/overview/","summary":"","tags":[],"title":"Overview"},{"content":"The Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent, technology-agnostic way. It’s built to support secure, reliable delivery and deployment of software—across cloud, on-prem, hybrid, and even air-gapped environments. By decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively and build trust into every step of the software supply chain.\nBelow are the main projects of our Github org. This version of the website references the released version of the OCM library and CLI (aka v1). The link to the OCM controllers already points to our new Kubernetes controller implementation based on the new OCM library v2 in our new monorepo open-component-model.\nOCM Specification - The ocm-spec repository contains the OCM specification, which provides a formal description of OCM and its format to describe software artifacts and a storage layer to persist those and make them accessible from remote. OCM Core Library - The ocm core library contains an API for interacting with OCM elements. A guided tour on how to work with the library can be found here. OCM CLI - With the ocm command line interface end users can interact with OCM elements, helping them create component versions and embed them in CI and CD processes. OCM Controllers - The controllers are designed to enable the automated deployment of software using OCM, kro and a deployer like Flux. OCM Website - The ocm-website you are currently visiting. It is built using Hugo and hosted on Github Pages. ","date":"0001-01-01","id":1,"permalink":"/docs/overview/about-the-ocm-project/","summary":"\u003cp\u003eThe Open Component Model (OCM) is an open standard that enables teams to describe software artifacts and their lifecycle metadata in a consistent,\ntechnology-agnostic way. It’s built to support secure, reliable delivery and deployment of software—across cloud, on-prem, hybrid, and even air-gapped environments.\nBy decoupling and streamlining lifecycle processes like compliance checks, security scans, and deployments, OCM helps teams collaborate more effectively\nand build trust into every step of the software supply chain.\u003c/p\u003e","tags":[],"title":"About the OCM Project"},{"content":"The Open Component Model (OCM) is an open-source toolset for secure software delivery.\nOCM gives you full visibility and control across the supply chain, streamlining compliance checks, security scans, and deployments. OCM works everywhere — cloud, on-premises, hybrid, and air-gapped environments. OCM integrates seamlessly with your existing tools and is easy to extend. With OCM, you gain control, reduce risk, and keep your delivery approach adaptable.\nWhy choose OCM Create a Software Bill of Delivery With OCM, you can describe everything you deliver in a unified, machine-readable format. This enables you to create a Software Bill of Delivery (SBoD). Unlike a Software Bill of Materials (SBOM), which lists all components inside an application, a Software Bill of Delivery focuses on everything you need for a successful deployment — including container images, Helm charts, configuration files, and binaries. It is a complete, verifiable record of all deliverables and how to access them.\nProtect Your Supply Chain Security is built into OCM. You can cryptographically sign and verify every component in your supply chain to ensure its integrity or confirm its provenance.\nBeyond signatures, OCM uses immutable, globally unique component identities. These act like tracking IDs, linking all lifecycle phases. They make compliance checks, audits, and vulnerability scans easier and more reliable. With OCM, your software is fully traceable from build to deployment.\nDeploy Anywhere, Even Air-Gapped You can deliver across boundaries and deploy anywhere — public cloud, on-premises, or air-gapped environments. OCM separates the identity of software artifacts from their location. Identities remain stable while locations can change as needed. You can store software artifacts in local registries, move them between systems, and work in environments with limited or no internet access — all without losing integrity or traceability.\nWorks with Your Existing Tools OCM seamlessly integrates with your current ecosystem. It is compatible with any implementation technology, whether container images, NPM packages, or binaries. You can manage both cloud-native and legacy software without rewriting existing tools or processes.\nAdapts to Your Needs OCM is built for flexibility. Its plugin system lets you extend functionality without changing the core. You can integrate new technologies, customize workflows, and scale from small teams to enterprise environments. OCM ensures that your supply chain remains agile and future-proof.\nCommitted to Open Source OCM has open development and transparent governance. We welcome contributions of any kind. The design of OCM makes it easy to add new features, so anyone can suggest, review, and merge improvements in a transparent way.\nOur commitment to open source goes beyond OCM. We are active members of the open-source community and have maintainers in projects such as kro, Flux, and External Secrets Operator. We believe in open source and work to shape its future.\nTry OCM Out Does OCM sound like the right fit for your project? Check out our Getting Started guides to see how easy a secure delivery can be.\n","date":"0001-01-01","id":2,"permalink":"/docs/overview/benefits-of-ocm/","summary":"\u003cp\u003eThe Open Component Model (OCM) is an open-source toolset for secure software delivery.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOCM gives you full visibility and control across the supply chain, streamlining compliance checks, security scans, and deployments.\u003c/li\u003e\n\u003cli\u003eOCM works everywhere — cloud, on-premises, hybrid, and air-gapped environments.\u003c/li\u003e\n\u003cli\u003eOCM integrates seamlessly with your existing tools and is easy to extend.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith OCM, you gain control, reduce risk, and keep your delivery approach adaptable.\u003c/p\u003e","tags":[],"title":"Benefits of OCM"},{"content":"","date":"0001-01-01","id":3,"permalink":"/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"This and the following chapters walk you through some basic steps to get started with OCM concepts and the OCM CLI. You will learn how to create a component version, display and examine the component, and how to transport and sign it.\nTo follow the steps described in this section, you will need to:\nInstall the OCM Command Line Interface (CLI) The CLI is used to interact with component versions and registries. Install it like described in Installing the OCM CLI.\nObtain Access to an OCM Repository This can be any OCI registry for which you have write permission (e.g., GitHub Packages). An OCM repository based on an OCI registry is identified by a leading OCI repository prefix. For example: ghcr.io/\u0026lt;YOUR-ORG\u0026gt;/ocm.\nObtain Credentials for the CLI to Access the OCM Repository Using the Docker Configuration File The easiest way to do this is to reuse your Docker configuration json file.\nTo do this, create a file named .ocmconfig in your home directory with the following content:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 # The path to the Docker configuration file dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true - type: attributes.config.ocm.software attributes: cache: ~/.ocm/cache\rUsing Basic Authentication Alternatively, you can use basic authentication. Create a file named .ocmconfig in your home directory with the following content:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: ociRegistry hostname: \u0026lt;YOUR-REGISTRY\u0026gt;/\u0026lt;YOUR-REPO\u0026gt; # e.g. ghcr.io/acme/acme credentials: - type: Credentials properties: username: \u0026lt;YOUR-USERNAME\u0026gt; password: \u0026lt;YOUR-PASSWORD\u0026gt;\rMore information on the credentials topic can be seen by running the OCM CLI help topic command ocm credential-handling and in this guide with many examples for different repository types.\n","date":"0001-01-01","id":4,"permalink":"/docs/getting-started/prerequisites/","summary":"\u003cp\u003eThis and the following chapters walk you through some basic steps to get started with OCM concepts and the OCM CLI.\nYou will learn how to create a component version, display and examine the component, and how to transport and sign it.\u003c/p\u003e","tags":[],"title":"Prerequisites"},{"content":"Overview You can install the latest release of the OCM CLI from any of the following sources (more details below):\nHomebrew Nix AUR Docker Podman GitHub Releases Bash To install with bash for macOS or Linux, execute the following command:\ncurl -s https://ocm.software/install.sh | sudo bash\rInstall using Homebrew # Homebrew (macOS and Linux) brew install open-component-model/tap/ocm\rInstall using Nix (with Flakes) # Nix (macOS, Linux, and Windows) # ad hoc cmd execution nix run github:open-component-model/ocm -- --help nix run github:open-component-model/ocm#helminstaller -- --help # install development version nix profile install github:open-component-model/ocm # or release \u0026lt;version\u0026gt; nix profile install github:open-component-model/ocm/\u0026lt;version\u0026gt; #check installation nix profile list | grep ocm # optionally, open a new shell and verify that cmd completion works ocm --help\rsee: Flakes\nInstall from AUR (Arch Linux User Repository) package-url\n# if not using a helper util git clone https://aur.archlinux.org/ocm-cli.git cd ocm-cli makepkg -i\rAUR Documentation\nInstall using Docker / Podman podman run -t ghcr.io/open-component-model/ocm:latest --help\rBuild and Run It Yourself podman build -t ocm . podman run --rm -t ocm --loglevel debug --help\ror interactively:\npodman run --rm -it ocm /bin/sh\rYou can pass in the following arguments to override the predefined defaults:\nGO_VERSION: The golang version to be used for compiling. ALPINE_VERSION: The alpine version to be used as the base image. GO_PROXY: Your go proxy to be used for fetching dependencies. Please check hub.docker.com for possible version combinations.\npodman build -t ocm --build-arg GO_VERSION=1.22 --build-arg ALPINE_VERSION=3.19 --build-arg GO_PROXY=https://proxy.golang.org .\ron MS Windows using Chocolatey choco install ocm-cli\rsee: chocolatey community package: ocm-cli\nusing winget Deprecated: Please note, winget packages are no longer provided. Any existing packages are still working, but no new packages are built and published to winget repository.\nBuilding from Source Prerequisites git golang make Installation Process Clone the open-component-model/ocm repo:\ngit clone https://github.com/open-component-model/ocm\rEnter the repository directory (cd ocm/) and install the cli using make:\nmake install\rPlease note that the OCM CLI is installed in your go/bin directory, so you might need to add this directory to your PATH.\nVerify the installation:\nocm version\r","date":"0001-01-01","id":5,"permalink":"/docs/getting-started/install-the-ocm-cli/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eYou can install the latest release of the OCM CLI from any of the following sources (more details below):\u003c/p\u003e","tags":[],"title":"Install the OCM CLI"},{"content":"Creating and Storing Component Versions Component Versions are created using a component-constructor.yaml file, which is a description file that contains one or multiple components. The file describes the components and their artifacts - resources and sources, metadata in form of labels and references to other components.\nComponent Versions are locally stored in archives using the Common Transfer Format (CTF). A CTF archive may contain any number of component versions and is used to transfer components to and between component repositories.\nNote that a CTF archive itself is also an OCM repository, so it can be used as source or target for component transfer operations using the OCM CLI.\nThe command ocm add componentversions directly creates a component version from a component-constructor.yaml file and stores it in a local CTF archive.\nCreate a Component Version In this example we will use the The ocm CLI tool to create a very basic component version that contains a local resource and a resource that is accessed from a remote location. The local resource is the podinfo Helm Chart and the referenced resource is a Docker image stored in an OCI registry.\nWe start by creating a test folder where we execute all required steps for this example and navigating into it:\nmkdir /tmp/helloworld cd /tmp/helloworld\rNow we download the podinfo Helm Chart that we want to use as local resource and extract it:\nhelm repo add podinfo https://stefanprodan.github.io/podinfo helm pull --untar podinfo/podinfo\rCreate a file component-constructor.yaml, which describes all elements of the component. You can use our public configuration schema to validate the configuration. The schema is available at https://ocm.software/schemas/configuration-schema.yaml and can be used in your editor to validate the configuration (e.g., in Visual Studio Code).\nComponent versions need to have at least a name, version and provider attribute. All other attributes are optional. Check out an example component descriptor or the OCM Specification to see all available attributes.\nAs mentioned before our example component will just contain a Helm Chart and a Docker image as resources:\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: - name: github.com/acme.org/helloworld # version needs to follow \u0026#34;relaxed\u0026#34; SemVer version: 1.0.0 provider: name: acme.org resources: # local Helm chart resource - name: mychart type: helmChart input: type: helm path: ./podinfo # remote image resource - name: image type: ociImage version: 1.0.0 access: type: ociArtifact imageReference: gcr.io/google_containers/echoserver:1.10\rA resource is described either by its access information to a remote repository or by locally provided resources.\nFor remote access, the field access is used to describe the access method. The type field is used to specify the kind of access.\nIf the resource content is taken from local resources, the field input is used to specify the access to the local resources. Similarly to the access attribute, the kind of the input source is described by the field type.\nAvailable access and input types are described here.\nFor more complex scenarios, the description files might use variable substitution (templating), see Best Practices.\nAdd Component Version to CTF archive To store our component version locally and to make it transportable, we now add it to a CTF archive using the following command. The option --create is used to create a new CTF archive if it does not exist:\nocm add componentversions --create --file ctf-hello-world component-constructor.yaml\rprocessing component-constructor.yaml... processing document 1... processing index 1 found 1 component adding component github.com/acme.org/helloworld:1.0.0... adding resource helmChart: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociArtifact: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;...\rWhat happened? The command creates the CTF archive (option --create) and adds the listed components with the described resources.\nctf-hello-world/ ├── artifact-index.json └── blobs ├── sha256.125cf912d0f67b2b49e4170e684638a05a12f2fcfbdf3571e38a016273620b54 ├── sha256.1cb2098e31e319df7243490464b48a8af138389abe9522c481ebc27dede4277b ├── sha256.974e652250ffaba57b820c462ce603fc1028a608b0fa09caef227f9e0167ce09 └── sha256.d442bdf33825bace6bf08529b6f00cf0aacc943f3be6130325e1eb4a5dfae3a5\rThe transport archive\u0026rsquo;s contents can be found in artifact-index.json. This file contains the list of component version artifacts to be transported.\njq . ${CTF_ARCHIVE}/artifact-index.json\r{ \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;artifacts\u0026#34;: [ { \u0026#34;repository\u0026#34;: \u0026#34;component-descriptors/github.com/acme/helloworld\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:d3cf4858f5387eaea194b7e40b7f6eb23460a658ad4005c5745361978897e043\u0026#34; } ] }\rThe content of the transport archive is stored as OCI artifacts. Notice that the repository names of Component Version artifacts (found at artifacts.respository) are prefixed by component-descriptors/.\nThe component version is described as an OCI manifest:\njq . ${CTF_ARCHIVE}/blobs/sha256.d3cf4858f5387eaea194b7e40b7f6eb23460a658ad4005c5745361978897e043\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:0dd94de11c17f995648c8e817971581bce4b016f53d4d2bf2fff9fcda37d7b95\u0026#34;, \u0026#34;size\u0026#34;: 201 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:4ab29c8acb0c8b002a5037e6d9edf2d657222da76fee2a10f38d65ecd981d0c6\u0026#34;, \u0026#34;size\u0026#34;: 3072 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:b2dc5088f005d27ea39b427c2e67e91e2b6b80d3e85eca2476a019003c402904\u0026#34;, \u0026#34;size\u0026#34;: 16122 } ] }\rNotice that the output of the component version above contains the component descriptor as one of the layers. It can be identified by its content type, which is application/vnd.ocm.software.component-descriptor.v2+yaml+tar. In this case, the component descriptor can be displayed with the following command:\ntar xvf ${CTF_ARCHIVE}/blobs/sha256.4ab29c8acb0c8b002a5037e6d9edf2d657222da76fee2a10f38d65ecd981d0c6 -O - component-descriptor.yaml\rmeta: schemaVersion: v2 component: name: github.com/acme/helloworld version: 1.0.0 provider: acme.org componentReferences: [] repositoryContexts: [] resources: - access: localReference: sha256:b2dc5088f005d27ea39b427c2e67e91e2b6b80d3e85eca2476a019003c402904 mediaType: application/vnd.oci.image.manifest.v1+tar+gzip referenceName: github.com/acme/helloworld/podinfo:6.7.0 type: localBlob digest: ... name: mychart relation: local type: helmChart version: 1.0.0 - access: imageReference: gcr.io/google_containers/echoserver:1.10 type: ociArtifact digest: ... name: image relation: external type: ociArtifact version: 1.0.0 sources: []\rThe other elements listed as layers describe the blobs for the local resources stored along with the component version. The digests can be seen in the localReference attributes of the component descriptor.\n","date":"0001-01-01","id":6,"permalink":"/docs/getting-started/create-component-versions/","summary":"\u003ch2 id=\"creating-and-storing-component-versions\"\u003eCreating and Storing Component Versions\u003c/h2\u003e\n\u003cp\u003eComponent Versions are created using a \u003ccode\u003ecomponent-constructor.yaml\u003c/code\u003e file, which is a description file that contains one or multiple components. The file describes the components and their artifacts - resources and sources, metadata in form of labels and references to other components.\u003c/p\u003e","tags":[],"title":"Create Component Versions"},{"content":"List Component Versions To show a component stored in an OCM repository or CTF archive (which itself is an OCM repository), the ocm get componentversion command can be used:\nocm get componentversion ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0\rCOMPONENT VERSION PROVIDER ocm.software/toi/demo/helmdemo 0.12.0 ocm.software\rTo see the component descriptor of the displayed component version, use the output format option -o yaml:\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -o yaml\rcomponent: componentReferences: - componentName: ocm.software/toi/installers/helminstaller name: installer version: 0.12.0 creationTime: \u0026#34;2024-07-19T14:32:13Z\u0026#34; name: ocm.software/toi/demo/helmdemo provider: ocm.software repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: open-component-model/ocm type: OCIRegistry resources: - access: localReference: sha256:8a2fe6af4ce56249094622c9d618e24b4cfb461a7dfa6a42cce31749189bc499 mediaType: application/vnd.toi.ocm.software.package.v1+yaml type: localBlob digest: ... labels: - name: commit value: e5ca3001323b75ee5793a786089f1f410e9e8db3 name: package relation: local type: toiPackage version: 0.12.0 - access: imageReference: ghcr.io/open-component-model/ocm/ocm.software/toi/demo/helmdemo/echoserver:0.1.0 type: ociArtifact digest: ... name: chart relation: local type: helmChart version: 0.12.0 ...\rTo refer to the content of a component repository, the component name can be appended to the repository specification separated by // (you can also use the --repo option to specify the repository).\nIn the example above, ghcr.io/open-component-model/ocm is the OCM repository, whereas ocm.software/toi/demo/helmdemo is the component stored in this component repository.\nOptionally, a specific version can be appended, separated by a colon (:). If no version is specified, all component versions will be displayed.\nWith the option --recursive, it is possible to show the complete component version, including the component versions it references.\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive\rREFERENCEPATH COMPONENT VERSION PROVIDER IDENTITY ocm.software/toi/demo/helmdemo 0.12.0 ocm.software ocm.software/toi/demo/helmdemo:0.12.0 ocm.software/toi/installers/helminstaller 0.12.0 ocm.software \u0026#34;name\u0026#34;=\u0026#34;installer\u0026#34;\rTo get a tree view, add the option -o tree:\nocm get cv ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive -o tree\rNESTING COMPONENT VERSION PROVIDER IDENTITY └─ ⊗ ocm.software/toi/demo/helmdemo 0.12.0 ocm.software └─ ocm.software/toi/installers/helminstaller 0.12.0 ocm.software \u0026#34;name\u0026#34;=\u0026#34;installer\u0026#34;\rAs mentioned before a CTF archive itself is an OCM repository, so we can execute the same commands on a CTF archive. So, let\u0026rsquo;s get the information about the component github.com/acme.org/helloworld we created in the previous step and that we stored in the CTF archive /tmp/helloworld/ctf-hello-world:\nocm get cv /tmp/helloworld/ctf-hello-world//github.com/acme.org/helloworld:1.0.0\rCOMPONENT VERSION PROVIDER github.com/acme.org/helloworld 0.1.0 ocm.software\rList the Resources of a Component Version To list the resources found in a component version tree, the command ocm get resources can be used:\nocm get resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 --recursive -o tree\rCOMPONENT NAME VERSION IDENTITY TYPE RELATION └─ ocm.software/toi/demo/helmdemo 0.12.0 ├─ chart 0.12.0 helmChart local ├─ config-example 0.12.0 yaml local ├─ creds-example 0.12.0 yaml local ├─ image 1.0 ociImage external ├─ package 0.12.0 toiPackage local └─ ocm.software/toi/installers/helminstaller installer 0.12.0 ├─ toiexecutor 0.12.0 toiExecutor local └─ toiimage 0.12.0 ociImage local\rDownload the Resources of a Component Version Use the ocm download command to download resources such as component versions, individual resources or artifacts:\nocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 chart -O helmchart.tgz\rhelmchart.tgz: 4707 byte(s) written\rBecause it is stored as OCI artifact in an OCI registry, the filesystem format used for OCI artifacts is the blob format.\nWhat happened? The file helmchart.tgz was downloaded.\ntar xvf helmchart.tgz\rx index.json x oci-layout x blobs x blobs/sha256.a9dd654eed17e786b5c5445e8bc48f3a47371c2efe392a53a3fbecd9e942b696 x blobs/sha256.c8017985866ceb44c2426a4ad9a429d6aec1f6818cb6dccbf964623139c1d1d5 x blobs/sha256.ea8e5b44cd1aff1f3d9377d169ad795be20fbfcd58475a62341ed8fb74d4788c\rjq . index.json\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.index.v1+json\u0026#34;, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:c8017985866ceb44c2426a4ad9a429d6aec1f6818cb6dccbf964623139c1d1d5\u0026#34;, \u0026#34;size\u0026#34;: 410, \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.ref.name\u0026#34;: \u0026#34;0.1.0\u0026#34;, \u0026#34;software.ocm/tags\u0026#34;: \u0026#34;0.1.0\u0026#34; } } ], \u0026#34;annotations\u0026#34;: { \u0026#34;software.ocm/main\u0026#34;: \u0026#34;sha256:c8017985866ceb44c2426a4ad9a429d6aec1f6818cb6dccbf964623139c1d1d5\u0026#34; } }\rDownload with Download Handlers To use a format more suitable for the content technology, enable the usage of download handlers.\nIf a download handler is available for the artifact type and the blob media type used to store the blob in the OCM repository, it will convert the blob format into a more suitable format:\nocm download resource -d ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 chart -O helmchart.tgz\rhelmchart.tgz: 3763 byte(s) written\rWhat happened? The downloaded archive is now a regular Helm Chart archive:\ntar tvf helmchart.tgz\r-rw-r--r-- 0 0 0 136 Jul 19 16:32 echoserver/Chart.yaml -rw-r--r-- 0 0 0 1842 Jul 19 16:32 echoserver/values.yaml -rw-r--r-- 0 0 0 1755 Jul 19 16:32 echoserver/templates/NOTES.txt -rw-r--r-- 0 0 0 1802 Jul 19 16:32 echoserver/templates/_helpers.tpl -rw-r--r-- 0 0 0 1848 Jul 19 16:32 echoserver/templates/deployment.yaml -rw-r--r-- 0 0 0 922 Jul 19 16:32 echoserver/templates/hpa.yaml -rw-r--r-- 0 0 0 2083 Jul 19 16:32 echoserver/templates/ingress.yaml -rw-r--r-- 0 0 0 367 Jul 19 16:32 echoserver/templates/service.yaml -rw-r--r-- 0 0 0 324 Jul 19 16:32 echoserver/templates/serviceaccount.yaml -rw-r--r-- 0 0 0 385 Jul 19 16:32 echoserver/templates/tests/test-connection.yaml -rw-r--r-- 0 0 0 349 Jul 19 16:32 echoserver/.helmignore\rDownload an Image For example, for OCI images, the OCI format is more suitable:\nocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 image -O image.tgz\rimage.tgz: 46181313 byte(s) written\rWhat happened? The file image.tgz was downloaded.\ntar xvf image.tgz\rx index.json x oci-layout x blobs x blobs/sha256.06679f57dba70a6875e4ae5843ba2483ecab6ec48182ca8720ddc5b1863bad52 x blobs/sha256.28c6282d04f63710146ace6c7be14a40c7ee6a71a2f91316928469e4aafe0d92 x blobs/sha256.2d3e25b9e93ad26878862abee5ed02683206f6f6d57e311cdd1dedf3662b61c8 x blobs/sha256.365ec60129c5426b4cf160257c06f6ad062c709e0576c8b3d9a5dcc488f5252d x blobs/sha256.4b12f3ef8e65aaf1fd77201670deb98728a8925236d8f1f0473afa5abe9de119 x blobs/sha256.76d46396145f805d716dcd1607832e6a1257aa17c0c2646a2a4916e47059dd54 x blobs/sha256.7fd34bf149707ca78b3bb90e4ba68fe9a013465e5d03179fb8d3a3b1cac8be27 x blobs/sha256.b0e3c31807a2330c86f07d45a6d80923d947a8a66745a2fd68eb3994be879db6 x blobs/sha256.bc391bffe5907b0eaa04e96fd638784f77d39f1feb7fbe438a1dae0af2675205 x blobs/sha256.cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229 x blobs/sha256.d5157969118932d522396fe278eb722551751c7aa7473e6d3f03e821a74ee8ec x blobs/sha256.e0962580d8254d0b1ef35006d7e2319eb4870e63dc1f9573d2406c7c47d442d2\rjq . index.json\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.index.v1+json\u0026#34;, \u0026#34;manifests\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.docker.distribution.manifest.v2+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u0026#34;, \u0026#34;size\u0026#34;: 2400, \u0026#34;annotations\u0026#34;: { \u0026#34;org.opencontainers.image.ref.name\u0026#34;: \u0026#34;1.10\u0026#34;, \u0026#34;software.ocm/tags\u0026#34;: \u0026#34;1.10\u0026#34; } } ], \u0026#34;annotations\u0026#34;: { \u0026#34;software.ocm/main\u0026#34;: \u0026#34;sha256:cb5c1bddd1b5665e1867a7fa1b5fa843a47ee433bbb75d4293888b71def53229\u0026#34; } }\rDownload an Executable The Open Component Model allows to publish platform-specific executables. In this case, the platform specification is used by convention as extra identity for the artifacts that are contained in the component version.\nExample:\nocm get componentversion ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.1.0-dev -o yaml\r... resources: - name: ocmcli extraIdentity: architecture: amd64 os: linux relation: local type: executable version: 0.1.0-dev access: localReference: sha256:1a8827761f0aaa897d1d4330c845121c157e905d1ff300ba5488f8c423bc7cd9 mediaType: application/octet-stream type: localBlob - name: ocmcli extraIdentity: architecture: arm64 os: darwin relation: local type: executable version: 0.1.0-dev access: localReference: sha256:9976b18dc16ae2b2b3fc56686f18f4896d44859f1ea6221f70e83517f697e289 mediaType: application/octet-stream type: localBlob ...\rNote that the resources shown above have the same name and type executable but a different extra-identity. If a component version complies to this convention, executables can directly be downloaded for the specified platform with the use of the -x option. If only one executable is contained in the component version, the resource name can be omitted. Example:\nocm download resource -x --latest ghcr.io/open-component-model/ocm//ocm.software/ocmcli\rocm: 83369938 byte(s) written\rWhat happened? file ocm\rWith the option --latest, the latest matching component version is used for download. With the option --constraints, version constraints can be configured. For example: --constraints 0.1.x will select all patch versions of 0.1. Together with --latest, the latest patch version is selected.\nThe option -x enables the executable download handler, which provides the x-bit of the downloaded files. Additionally, it filters all matching resources for executables and the correct platform.\nDownload a Full Component Version Download entire component versions using the ocm download componentversion command:\nocm download componentversions ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -O helloworld\rhelloworld: downloaded\rThe result is a CTF archive. This can then be modified using the ocm add ... commands shown earlier.\nWhat happened? The component version was downloaded.\ntree helloworld\rhelloworld/ ├── blobs │ ├── sha256.87cef1e2233bf5591030ac854e2556fbe6a00a28bb5640e25a9cb69ece519c5a │ ├── sha256.8a2fe6af4ce56249094622c9d618e24b4cfb461a7dfa6a42cce31749189bc499 │ └── sha256.e790920a11de2016de64225280efcf062e14b767955f7508de64fd5192e3fb3a └── component-descriptor.yaml\rDownload OCI Artifacts Download OCI artifacts from an OCI registry, such as OCI images, with the ocm download artifacts command:\nocm download artifact ghcr.io/open-component-model/ocm-controller:v0.24.0 -O ocm-controller\rocm-controller: downloaded\rWhat happened? The OCI image echoserver was downloaded.\ntree echoserver\rocm-controller/ ├── blobs │ ├── sha256.05d57e68048827c243cd477025f96064df9f4d83b8639ed04306f0647c9cfe78 │ ├── sha256.0f8b424aa0b96c1c388a5fd4d90735604459256336853082afb61733438872b5 │ ├── sha256.1069fc2daed1aceff7232f4b8ab21200dd3d8b04f61be9da86977a34a105dfdc │ ├── sha256.286c61c9a31ace5fa0b8832c8e8e30d66bf32138f2f787463235aa0071f714ea │ ├── sha256.2bdf44d7aa71bf3a0da2de0563ad0e3882948d699b4991edf8c0ab44e7f26ae3 │ ├── sha256.35fddc32f468fc8d276fa1b6a72cac27f35a0080233c2ddc6a03fab224024dbc │ ├── sha256.3f4e2c5863480125882d92060440a5250766bce764fee10acdbac18c872e4dc7 │ ├── sha256.452e9eed7ecfd0c2b44ac6fda20cee66ab98aec38ba30aa868e02445be7c8bb0 │ ├── sha256.80a8c047508ae5cd6a591060fc43422cb8e3aea1bd908d913e8f0146e2297fea │ ├── sha256.9375d0c4fac611287075434624a464af5b6bb026947698a06577ad348f607d56 │ ├── sha256.b40161cd83fc5d470d6abe50e87aa288481b6b89137012881d74187cfbf9f502 │ ├── sha256.c8022d07192eddbb2a548ba83be5e412f7ba863bbba158d133c9653bb8a47768 │ ├── sha256.d557676654e572af3e3173c90e7874644207fda32cd87e9d3d66b5d7b98a7b21 │ └── sha256.d858cbc252ade14879807ff8dbc3043a26bbdb92087da98cda831ee040b172b3 ├── index.json └── oci-layout\r","date":"0001-01-01","id":7,"permalink":"/docs/getting-started/display-and-examine-component-versions/","summary":"\u003ch2 id=\"list-component-versions\"\u003eList Component Versions\u003c/h2\u003e\n\u003cp\u003eTo show a component stored in an OCM repository or CTF archive (which itself is an OCM repository), the \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_get_componentversions.md\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eocm get componentversion\u003c/code\u003e\u003c/a\u003e command can be used:\u003c/p\u003e","tags":[],"title":"Display and Examine Component Versions"},{"content":"Component versions can be signed to ensure integrity along a transport chain.\nSigning requires a key pair, a signature, and, optionally, an issuer, as well as an algorithm and a name for the signature.\nA component version can have multiple signatures with different names. A normalization of the component version is used for signing. See Signing Process and Normalization for more details. Currently, only signing according to the RSA PKCS #1 v1.5 signature algorithm is supported.\nTo follow the examples, one must follow the instructions from the section Create a Component Version.\nCreate a key pair using the OCM CLI:\nocm create rsakeypair acme.priv\rcreated rsa key pair acme.priv[acme.pub]\rThis creates two files. One named acme.priv for the private key and for convenience one named acme.pub for the public key.\nUse the sign componentversion command to sign a component version:\nocm sign componentversion --signature acme-sig --private-key=acme.priv ${OCM_REPO}//${COMPONENT}:${VERSION}\rapplying to version \u0026#34;github.com/acme/helloworld:1.0.0\u0026#34;[github.com/acme/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully signed github.com/acme/helloworld:1.0.0 (digest SHA-256:...)\rYou can also sign a common transport archive before uploading to a component repository:\nocm sign componentversion --signature acme-sig --private-key=acme.priv ${CTF_ARCHIVE}\rapplying to version \u0026#34;github.com/acme.org/helloworld:1.0.0\u0026#34;[github.com/acme.org/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully signed github.com/acme.org/helloworld:1.0.0 (digest SHA-256:...)\rWhat happened? Digests will be created for all described artifacts and referenced component versions. Then for the top-level component versions, the component-version digests are signed. The signature and digests are stored in the component descriptor(s):\njq . ${CTF_ARCHIVE}/artifact-index.json\r{ \u0026#34;schemaVersion\u0026#34;: 1, \u0026#34;artifacts\u0026#34;: [ { \u0026#34;repository\u0026#34;: \u0026#34;component-descriptors/github.com/acme.org/helloworld\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:02b12782d66fc6504f0003bb11a8e2610ac8f3d616bc1a4545df17a6e9aca5c6\u0026#34; } ] }\rBeside the digests of the component descriptor layer, nothing has changed:\njq . ${CTF_ARCHIVE}/blobs/sha256.02b12782d66fc6504f0003bb11a8e2610ac8f3d616bc1a4545df17a6e9aca5c6\r{ \u0026#34;schemaVersion\u0026#34;: 2, \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+json\u0026#34;, \u0026#34;config\u0026#34;: { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component.config.v1+json\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:38ba9898cb8d2c5ad34274549632836b391f5acc96268f0276d6857e87b97141\u0026#34;, \u0026#34;size\u0026#34;: 201 }, \u0026#34;layers\u0026#34;: [ { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:c9705f0045f91c2cba49ce922dd65da27e66796e3a1fdc7a6fc01058357f2cd4\u0026#34;, \u0026#34;size\u0026#34;: 3584 }, { \u0026#34;mediaType\u0026#34;: \u0026#34;application/vnd.oci.image.manifest.v1+tar+gzip\u0026#34;, \u0026#34;digest\u0026#34;: \u0026#34;sha256:125cf912d0f67b2b49e4170e684638a05a12f2fcfbdf3571e38a016273620b54\u0026#34;, \u0026#34;size\u0026#34;: 16119 } ] }\rtar xvf ${CTF_ARCHIVE}/blobs/sha256.c9705f0045f91c2cba49ce922dd65da27e66796e3a1fdc7a6fc01058357f2cd4 -O - component-descriptor.yaml\rmeta: schemaVersion: v2 component: name: github.com/acme.org/helloworld version: 1.0.0 provider: acme.org componentReferences: [] repositoryContexts: [] resources: - access: localReference: sha256:125cf912d0f67b2b49e4170e684638a05a12f2fcfbdf3571e38a016273620b54 mediaType: application/vnd.oci.image.manifest.v1+tar+gzip referenceName: github.com/acme.org/helloworld/podinfo:6.7.0 type: localBlob digest: ... name: mychart relation: local type: helmChart version: 1.0.0 - access: imageReference: gcr.io/google_containers/echoserver:1.10 type: ociArtifact digest: ... name: image relation: external type: ociArtifact version: 1.0.0 sources: [] signatures: - digest: ... name: acme-sig signature: algorithm: RSASSA-PKCS1-V1_5 mediaType: application/vnd.ocm.signature.rsa value: ...\rSigning with Certificates The public key from the last example cannot be validated. This can be changed by using a certificate instead of a pure public key. The certificate is signed by a CA. This ensures the authenticity of the described public key. Additionally, the common name of the certificate is validated against the issuer attribute of the signature stored in the component descriptor.\nThe following example creates a CA and signing certificates that are used to sign a component version.\nCreate the root CA:\nocm create rsakeypair --ca CN=certificate-authority root.priv\rcreated rsa key pair root.priv[root.cert]\rCreate the CA that is used to create signing certificates:\nocm create rsakeypair --ca CN=acme.org --ca-key root.priv --ca-cert root.cert ca.priv\rcreated rsa key pair ca.priv[ca.cert]\rCreate signing certificates from the CA:\nocm create rsakeypair CN=acme.org C=DE --ca-key ca.priv --ca-cert ca.cert --root-certs root.cert key.priv\rcreated rsa key pair key.priv[key.cert]\rYou can use additional attributes of the certificate like O, OU or C. See usage for details. The certificate can be requested by any official certificate authority instead. It requires the usage types x509.KeyUsageDigitalSignature and x509.ExtKeyUsageCodeSigning.\nFor signing the component version you need to provide the issuer, then run:\nocm sign componentversion ${CTF_ARCHIVE} --private-key key.priv --public-key key.cert --ca-cert root.cert --signature acme.org --issuer CN=acme.org\rapplying to version \u0026#34;github.com/acme.org/helloworld:1.0.0\u0026#34;[github.com/acme.org/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully signed github.com/acme.org/helloworld:1.0.0 (digest SHA-256:...)\rNow the issuer will be stored along the signature and will be checked when verifying with the certificate instead of the public key.\nSignature Verification You can verify a signed component version. Therefore, a public key or a certificate provided by the signer is required. If a certificate is provided, it is validated according to its certificate chain. If an official CA is used instead, you need the certificate of the used root CA.\nIf you followed the previous examples, you can verify the signature of a component version as follows:\nocm verify componentversions --signature acme-sig --public-key=acme.pub ${OCM_REPO}//${COMPONENT}:${VERSION}\rapplying to version \u0026#34;github.com/acme/helloworld:1.0.0\u0026#34;[github.com/acme/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] successfully verified github.com/acme/helloworld:1.0.0 (digest SHA-256:...)\rocm verify component ${CTF_ARCHIVE} --ca-cert root.cert --issuer CN=acme.org\rapplying to version \u0026#34;github.com/acme.org/helloworld:1.0.0\u0026#34;[github.com/acme.org/helloworld:1.0.0]... resource 0: \u0026#34;name\u0026#34;=\u0026#34;mychart\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] resource 1: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;: digest SHA-256:...[ociArtifactDigest/v1] no public key found for signature \u0026#34;acme.org\u0026#34; -\u0026gt; extract key from signature successfully verified github.com/acme.org/helloworld:1.0.0 (digest SHA-256:...)\r","date":"0001-01-01","id":8,"permalink":"/docs/getting-started/sign-component-versions/","summary":"\u003cp\u003eComponent versions can be signed to ensure integrity along a transport chain.\u003c/p\u003e\n\u003cp\u003eSigning requires a key pair, a signature, and, optionally, an issuer, as well as an algorithm and a\nname for the signature.\u003c/p\u003e","tags":[],"title":"Sign Component Versions"},{"content":"The section Add Component Version to CTF archive explained how to store component versions in a CTF archive.\nDuring the transfer, it is possible to include component references as local blobs. It is also possible to include references in a recursive way.\nHere is an example of a recursive transfer from one OCI registry to another, which includes resources and references:\nocm transfer componentversion --recursive --copy-resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 another-registry/\rtransferring version \u0026#34;ocm.software/toi/demo/helmdemo:0.12.0\u0026#34;... transferring version \u0026#34;ocm.software/toi/installers/helminstaller:0.12.0\u0026#34;... ...resource 0 toiimage[ociImage](ocm.software/toi/installers/helminstaller/helminstaller:0.12.0)... ...resource 1 toiexecutor[toiExecutor]... ...adding component version... ...resource 0 package[toiPackage]... ...resource 1 chart[helmChart](ocm.software/toi/demo/helmdemo/echoserver:0.1.0)... ...resource 2 image[ociImage](google-containers/echoserver:1.10)... ...resource 3 config-example[yaml]... ...resource 4 creds-example[yaml]... ...adding component version... 2 versions transferred\rThe OCM CLI\u0026rsquo;s transfer command can be used to transfer component versions, CTF archives, and artifacts. See ocm transfer -h for more information.\nMore examples on the transport archive and the common transfer format (CTF) can be found in the ocm-spec.\n","date":"0001-01-01","id":9,"permalink":"/docs/getting-started/transport-component-versions/","summary":"\u003cp\u003eThe section \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/getting-started/create-component-versions/#add-component-version-to-ctf-archive/\"\u003eAdd Component Version to CTF archive\u003c/a\u003e explained how to store component versions in a CTF archive.\u003c/p\u003e\n\u003cp\u003eDuring the transfer, it is possible to include component references as local blobs. It is also possible to include references in a recursive way.\u003c/p\u003e","tags":[],"title":"Transport Component Versions"},{"content":"This document describes how to set up a local environment to Deploy a Helm Chart using the OCM controllers.\nPrerequisites kubectl Start a Local Kubernetes Cluster with kind You don\u0026rsquo;t need to run kind if you are using a remote Kubernetes cluster you have access to. If so, you can skip this.\nFor download and installation instructions, see the kind documentation.\nTo create a local kind cluster run the following command:\nkind create cluster\rInstall kro Please follow the official installation guides for kro. You might need helm to install kro.\nIf kro is installed correctly, you should see some similar output when running the following command:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h28m ... Install a Deployer Currently, we created our examples and getting-started guides using FluxCD as deployer. But, in theory, you could use any other deployer that is able to apply a deployable resource to a Kubernetes cluster, for instance ArgoCD.\nTo install FluxCD, please follow the official installation guide. After you installed the CLI tool, you can run the following command to install the FluxCD controllers:\nflux install\rIf the FluxCD controllers are installed correctly, you should see some similar output when running the following command:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... flux-system helm-controller-b6767d66-zbwws 1/1 Running 0 3h29m flux-system kustomize-controller-57c7ff5596-v6fvr 1/1 Running 0 3h29m flux-system notification-controller-58ffd586f7-pr65t 1/1 Running 0 3h29m flux-system source-controller-6ff87cb475-2h2lv 1/1 Running 0 3h29m ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h28m ... Install the OCM Controllers To install the OCM controllers, execute the following command:\nhelm install ocm-k8s-toolkit oci://ghcr.io/open-component-model/charts/ocm-k8s-toolkit \\ --namespace ocm-k8s-toolkit-system \\ --create-namespace\rFor local development, you can install directly from the source:\n# In the ocm mono-repo root directory cd kubernetes/controller task helm/install\rIf the OCM controllers are installed correctly, you should see some similar output when running the following command:\nkubectl get pods --all-namespaces\rNAMESPACE NAME READY STATUS RESTARTS AGE ... flux-system helm-controller-b6767d66-zbwws 1/1 Running 0 3h39m flux-system kustomize-controller-57c7ff5596-v6fvr 1/1 Running 0 3h39m flux-system notification-controller-58ffd586f7-pr65t 1/1 Running 0 3h39m flux-system source-controller-6ff87cb475-2h2lv 1/1 Running 0 3h39m ... kro kro-86d5b5b5bd-6gmvr 1/1 Running 0 3h38m ... ocm-k8s-toolkit-system ocm-k8s-toolkit-controller-manager-788f58d4bd-ntbx8 1/1 Running 0 57s ... Access to a Registry As all examples and guides will create an OCM component version that will be consumed by the OCM controllers, you will need access to a registry. You can either choose a public registry like ghcr.io or deploy a registry (like registry, zot, \u0026hellip;) into your Kubernetes cluster.\nIf you choose to deploy a registry into your Kubernetes cluster, you have to make sure it is accessible from outside the cluster (for ocm transfer to work) and inside the cluster (for the OCM controllers to work).\nWe strongly recommend using a registry that is publicly accessible, like [ghcr.io][ghcr.io]. Deploying your own registry requires a lot of additional configuration. Especially, if you want to try out the localization example, you will need to configure a registry that is accessible with the same address from your CLI, kubelet, and inside the cluster.\nIf you completed all of the above steps, you are ready to go. You can now start with the Deploy Helm Chart example or play around in the examples/ directory.\n","date":"0001-01-01","id":10,"permalink":"/docs/getting-started/set-up-ocm-controller-environment/","summary":"\u003cp\u003eThis document describes how to set up a local environment to \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/getting-started/deploy-helm-charts/\"\u003eDeploy a Helm Chart\u003c/a\u003e using the OCM controllers.\u003c/p\u003e\n\u003ch2 id=\"prerequisites\"\u003ePrerequisites\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n\n\u003ca href=\"https://kubernetes.io/docs/tasks/tools/#kubectl\" target=\"_blank\" rel=\"noopener\"\u003ekubectl\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"start-a-local-kubernetes-cluster-with-kind\"\u003eStart a Local Kubernetes Cluster with kind\u003c/h2\u003e\n\u003cdiv class=\"callout callout-note d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \r\n    \u003cdiv class=\"callout-body\"\u003e\r\n      \u003cp\u003eYou don\u0026rsquo;t need to run kind if you are using a remote Kubernetes cluster you have access to. If so, you can skip this.\u003c/p\u003e","tags":[],"title":"Set Up OCM Controller Environment"},{"content":"This guide demonstrates how to deploy a Helm Chart from an OCM component version using OCM controllers, kro, and FluxCD. It is a rather basic example, in which it is assumed that a developer created an application, packaged it as a Helm chart, and publishes it as OCM component version in an OCI registry. Then, an operator who wants to deploy the application via Helm chart in a Kubernetes cluster, creates a ResourceGraphDefinition with resources that point to this OCM component version. Using CEL expressions inside the ResourceGraphDefinition, the information about the resource location will be passed to FluxCD, which will then configure the Helm chart and deploy it into the Kubernetes cluster.\nBefore starting, make sure you have set up your environment as described in the setup guide.\nCreate the OCM Component Version First, we will create an OCM component version containing a Helm chart. For this example, we will use the podinfo Helm chart, which is a simple web application that serves a pod information page. For more details on how to create an OCM component version, please refer to the OCM documentation.\nTo create the OCM component version, we will use the following component-constructor.yaml file:\ncomponents: - name: ocm.software/ocm-k8s-toolkit/simple provider: name: ocm.software version: \u0026#34;1.0.0\u0026#34; resources: - name: helm-resource type: helmChart version: 1.0.0 access: type: ociArtifact imageReference: \u0026#34;ghcr.io/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a\u0026#34;\rAfter creating the file, we can create the OCM component version:\nocm add componentversion --create --file ./ctf component-constructor.yaml\rThis will create a local CTF (Component Transfer Format) directory ./ctf containing the OCM component version. Since the OCM component version must be accessible to the OCM controllers, we will transfer the CTF to a registry. For this example, we will use GitHub\u0026rsquo;s container registry, but you can use any OCI registry:\nocm transfer ctf ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rIf you are using a registry that requires authentication, you need to provide credentials for ocm. Please refer to the OCM CLI credentials documentation for more information on how to set up and use credentials.\nIf everything went well, you should see the following output:\nocm get componentversion ghcr.io/\u0026lt;your-namespace\u0026gt;//ocm.software/ocm-k8s-toolkit/simple:1.0.0\rCOMPONENT VERSION PROVIDER ocm.software/ocm-k8s-toolkit/simple 1.0.0 ocm.software Deploy the Helm Chart To deploy the Helm chart from the OCM component version, we will first create a ResourceGraphDefinition that contains all required resources. Additionally, we will add a configuration to the HelmRelease resource that can be passed through the instance of that ResourceGraphDefinition. After the ResourceGraphDefinition is created and applied, we create the instance of the ResourceGraphDefinition that will deploy the Helm chart.\nCreate and Apply the ResourceGraphDefinition The ResourceGraphDefinition is a custom resource that defines all the resources that should be applied. To proceed with the example, create a file named rgd.yaml and add the following content:\napiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: simple spec: schema: apiVersion: v1alpha1 # The name of the CRD that is created by this ResourceGraphDefinition when applied kind: Simple spec: # This spec defines values that can be referenced in the ResourceGraphDefinition and that can be set in the # instances of this ResourceGraphDefinition. # We will use it to pass a value to the Helm chart and configure the message the application shows # (see resource HelmRelease). message: string | default=\u0026#34;foo\u0026#34; resources: # Repository points to the OCM repository in which the OCM component version is stored and checks if it is # reachable by pinging it. - id: repository template: apiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: simple-repository spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # Component refers to the Repository, downloads and verifies the OCM component version descriptor. - id: component template: apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: simple-component spec: repositoryRef: name: ${repository.metadata.name} component: ocm.software/ocm-k8s-toolkit/simple semver: 1.0.0 interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # Resource points to the Component, downloads the resource passed by reference-name and verifies it. It then # publishes the location of the resource in its status. - id: resourceChart template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: simple-resource spec: componentRef: name: ${component.metadata.name} resource: byReference: resource: name: helm-resource # This must match the resource name set in the OCM component version (see above) interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # OCIRepository watches and downloads the resource from the location provided by the Resource status. # The Helm chart location (url) refers to the status of the above resource. - id: ocirepository template: apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: simple-ocirepository spec: interval: 1m0s layerSelector: mediaType: \u0026#34;application/vnd.cncf.helm.chart.content.v1.tar+gzip\u0026#34; operation: copy url: oci://${resourceChart.status.reference.registry}/${resourceChart.status.reference.repository} ref: tag: ${resourceChart.status.reference.tag} # secretRef is required, if the OCI repository requires credentials to access it. # secretRef: # HelmRelease refers to the OCIRepository, lets you configure the helm chart and deploys the Helm Chart into the # Kubernetes cluster. - id: helmrelease template: apiVersion: helm.toolkit.fluxcd.io/v2 kind: HelmRelease metadata: name: simple-helmrelease spec: releaseName: simple interval: 1m timeout: 5m chartRef: kind: OCIRepository name: ${ocirepository.metadata.name} namespace: default values: # We configure the Helm chart using FluxCDs HelmRelease \u0026#39;values\u0026#39; field. We pass the value that we set in # the instance of the CRD created by the ResourceGraphDefinition (see below). ui: message: ${schema.spec.message}\rIf you pushed the OCM component version to a private registry, you need to set up the credentials for the OCM controller resources. You can do this by uncommenting the ocmConfig fields in the Repository, Component, and Resource resources and providing the necessary credentials. For more information on how to set up and pass the credentials, please check out the guide configure credentials for OCM controller resources.\nBe aware that FluxCD\u0026rsquo;s OCIRepository also needs access to the OCI registry that contains the Helm chart. However, OCIRepository only accepts imagePullSecrets in the same namespace. If you want to use the same credentials for FluxCD and for the OCM controller resources, create a Kubernetes secret of type dockerconfigjson and keep all the resources in the same namespace.\nAfter creating the file rgd.yaml with the above content and adjusting Repository\u0026rsquo;s baseUrl to point to your OCM repository, you can apply the ResourceGraphDefinition to your Kubernetes cluster:\nkubectl apply -f rgd.yaml\rIf everything went well, you should see the following output:\nkubectl get rgd\rNAME APIVERSION KIND STATE AGE simple v1alpha1 Simple Active 19s This creates a Kubernetes Custom Resource Definition (CRD) Simple that can be used to create instances. An applied instance of the CRD will create all resources defined in the ResourceGraphDefinition.\nCreate an Instance of \u0026ldquo;Simple\u0026rdquo; To create an instance of the Simple CRD, create a file named instance.yaml and add the following content:\napiVersion: kro.run/v1alpha1 # Kind is the CRD name that was created by the ResourceGraphDefinition kind: Simple metadata: name: simple spec: # This field is passed to the Helm chart and configures the message that podinfo will show message: \u0026#34;bar\u0026#34;\rProceed by applying the instance which will create all the resources defined in the ResourceGraphDefinition:\nkubectl apply -f instance.yaml\rThis will take some time, but if everything went well, you should see the following output:\nkubectl get simple\rNAME STATE SYNCED AGE simple ACTIVE True 5m28s and the deployment should be in the state Available:\nkubectl get deployments\rNAME READY UP-TO-DATE AVAILABLE AGE simple-podinfo 1/1 1 1 40m To make sure that the deployment was configured successfully, take a look at the pod itself or execute the following command:\nkubectl get pods -l app.kubernetes.io/name=simple-podinfo -o jsonpath=\u0026#39;{.items[0].spec.containers[0].env[?(@.name==\u0026#34;PODINFO_UI_MESSAGE\u0026#34;)].value}\u0026#39;\rwhich should return the value you passed in the instance:\nbar You now have successfully created an OCM component version containing a Helm chart and deployed as well as configured it using the OCM controllers, kro, and FluxCD.\nTroubleshooting One common issue, when using GitHub\u0026rsquo;s container registry, is that the transferred OCM component is by default a private package. If so, you might see an error like the following:\nfailed to list versions: failed to list tags: GET \u0026#34;https://ghcr.io/v2...\u0026#34;: response status code 401: unauthorized: authentication required You can resolve this issue by making the package public or by providing credentials to the respective resources.\n","date":"0001-01-01","id":11,"permalink":"/docs/getting-started/deploy-helm-charts/","summary":"\u003cp\u003eThis guide demonstrates how to deploy a Helm Chart from an OCM component version using OCM controllers, kro, and FluxCD.\nIt is a rather basic example, in which it is assumed that a developer created an application, packaged it as a Helm\nchart, and publishes it as OCM component version in an OCI registry. Then, an operator who wants to deploy the\napplication via Helm chart in a Kubernetes cluster, creates a \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e with resources that point to\nthis OCM component version. Using CEL expressions inside the \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e, the information about the\nresource location will be passed to FluxCD, which will then configure the Helm chart and deploy it into the Kubernetes\ncluster.\u003c/p\u003e","tags":[],"title":"Deploy Helm Charts"},{"content":"","date":"0001-01-01","id":12,"permalink":"/docs/concepts/","summary":"","tags":[],"title":"Concepts"},{"content":"In OCM, components group a set of semantically related component versions. Each component version is uniquely and globally identified by a component identity and can reference other components. A component version can also contain artifacts and a formal description of how to access them. These artifacts come in two categories: resources, which describe the payload (e.g., OCI images), and sources, which describe the input for creating resources (e.g., source code).\nFor a detailed exploration of OCM components and other key elements of the Open Component Model, please refer to the OCM Specification and its Glossary.\n","date":"0001-01-01","id":13,"permalink":"/docs/concepts/ocm-components/","summary":"\u003cp\u003eIn OCM, \u003cem\u003ecomponents\u003c/em\u003e group a set of semantically related \u003cem\u003ecomponent versions\u003c/em\u003e. Each component version is uniquely and globally identified by a \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/concepts/ocm-coordinates/\"\u003e\u003cem\u003ecomponent identity\u003c/em\u003e\u003c/a\u003e and can reference other components. A component version can also contain \u003cem\u003eartifacts\u003c/em\u003e and a formal description of how to access them. These artifacts come in two categories: \u003cem\u003eresources\u003c/em\u003e, which describe the payload (e.g., OCI images), and \u003cem\u003esources\u003c/em\u003e, which describe the input for creating resources (e.g., source code).\u003c/p\u003e","tags":[],"title":"OCM Components"},{"content":"OCM coordinates are used to reference OCM component versions and the artifacts within OCM component versions. Coordinates referring to an OCM component version are also called component identity, whereas relative coordinates referring to an artifact are called artifact identity.\nComponent Identity Component identities are globally unique and may be used to refer to full component versions. They are defined through the following attributes:\nname: Identifies a component. Must start with a URL prefix that should be controlled by the owner of the component to avoid collisions. version: If used with a component name, identifies a specific component version. Must adhere to \u0026ldquo;relaxed SemVer\u0026rdquo; (major, minor (+ optional patch level) - optional v-prefix). Artifact Identity Artifact identities are always relative to a component version and may only be used in conjunction with a component identity. Within a component version, all artifacts must have a unique identity.\nArtifact identities are defined through the following attributes:\nname: Identifies an artifact. Typically expresses the intended purpose. extraIdentity (optional): Contributes to the identity of the artifact. String-to-string map. Examples Let\u0026rsquo;s assume there is a component named example.org/my-component with two versions, 1.2.3 and 1.3.0, declaring a resource with the name my-resource. The following OCM coordinates can be used to reference different elements:\nexample.org/my-component: all versions of the component (1.2.3 + 1.3.0) example.org/my-component:1.2.3: version 1.2.3 of the component example.org/my-component:1.2.3:resource/my-resource: my-resource as declared by the component version ","date":"0001-01-01","id":14,"permalink":"/docs/concepts/ocm-coordinates/","summary":"\u003cp\u003e\u003cem\u003eOCM coordinates\u003c/em\u003e are used to reference OCM component versions and the artifacts within OCM component versions. Coordinates referring to an OCM component version are also called \u003cem\u003ecomponent identity\u003c/em\u003e, whereas relative coordinates referring to an artifact are called \u003cem\u003eartifact identity\u003c/em\u003e.\u003c/p\u003e","tags":[],"title":"OCM Coordinates"},{"content":"\rThis project is in early development and not yet ready for production use.\nThe OCM controllers\nsupport the deployment of an OCM component and its resources, like Helm charts or other manifests, into a Kubernetes cluster with the help of kro and a deployer, e.g. FluxCD. provide a controller to transfer OCM components. What Should I Know Before I Start? You should be familiar with the following concepts:\nOpen Component Model Kubernetes ecosystem kro Kubernetes resource deployer such as FluxCD Concept The following section provides a high-level overview of the OCM controllers and their components regarding the deployment of an OCM resource in a very basic scenario.\nThe primary purpose of the OCM controllers is simple: Deploy an OCM resource from an OCM component version into a Kubernetes cluster.\nThe implementation, however, is a bit more complex as deployments must be secure and configurable. Additionally, an OCM resource can, in theory, contain any form of deployable resource, for instance a Helm chart, a Kustomization, or plain Kubernetes manifests. Each of these resources has its own way of being deployed or configured. So, instead of creating a generic deployer that offers all these functionalities, we decided to use existing tools that are already available in the Kubernetes ecosystem.\nThe following diagram describes a basic scenario in which an OCM resource containing a Helm chart is deployed into a Kubernetes cluster using the OCM controllers as well as kro and FluxCD. kro is used to orchestrate the deployment and to transport information about the location of the OCM resource to FluxCD. FluxCD takes the location of the OCM resource, downloads the chart, configures it if necessary, and deploys it into the Kubernetes cluster.\nflowchart TB classDef cluster fill:white,color:black,stroke:black; classDef reconciledBy fill:#dedede,stroke:black,stroke-dasharray: 5,color:black; classDef k8sObject fill:#b3b3b3,color:black,stroke:black; classDef information fill:#b3b3b3,color:black,stroke:black,stroke-dasharray: 2; classDef ocm fill:white,stroke:black,color:black; classDef legendStyle fill:white,stroke:black,color:black,stroke-dasharray: 2; classDef legendStartEnd height:0px; classDef legendItems fill:#b3b3b3,stroke:none,color:black; subgraph legend[Legend] start1[ ] ---references[referenced by] --\u0026gt; end1[ ] start2[ ] -.-creates -.-\u0026gt; end2[ ] start3[ ] ---instanceOf[instance of] --\u0026gt; end3[ ] start4[ ] ~~~reconciledBy[reconciled by] ~~~ end4[ ] start5[ ] ~~~k8sObject[k8s object] ~~~ end5[ ] start6[ ] ~~~templateOf[template of] ~~~ end6[ ] end subgraph background[ ] direction TB subgraph ocmRepo[OCM Repository] subgraph ocmCV[OCM Component Version] subgraph ocmResource[OCM Resource: HelmChart] end end end subgraph k8sCluster[Kubernetes Cluster] subgraph kroRGD[kro] subgraph rgd[RGD: Simple] direction LR rgdRepository[Repository] rgdComponent[Component] rgdResourceHelm[Resource: HelmChart] rgdSource[FluxCD: OCI Repository] rgdHelmRelease[FluxCD: HelmRelease] end end subgraph kroInstance[kro] subgraph instanceSimple[Instance: Simple] subgraph ocmK8sToolkit[OCM Controller] k8sRepo[Repository] --\u0026gt; k8sComponent[Component] --\u0026gt; k8sResource[Resource: HelmChart] end subgraph fluxCD[FluxCD] source[OCI Repository] --\u0026gt; helmRelease[HelmRelease] end k8sResource --\u0026gt; source end end kroRGD \u0026amp; instanceSimple --\u0026gt; crdSimple[CRD: Simple] helmRelease --\u0026gt; deployment[Deployment: Helm chart] end ocmRepo --\u0026gt; k8sRepo end linkStyle default fill:none,stroke:black; linkStyle 2,3,16,18 stroke:black,stroke-dasharray: 10; linkStyle 4,5,17 stroke:black,stroke-dasharray: 4; class start1,end1,start2,end2,start3,end3,start4,end4,start5,end5,start6,end6 legendStartEnd; class references,creates,instanceOf legendItems; class templateOf,rgdRepository,rgdComponent,rgdResourceHelm,rgdSource,rgdHelmRelease information; class reconciledBy,ocmK8sToolkit,fluxCD,kroRGD,kroInstance reconciledBy; class k8sObject,rgd,k8sRepo,k8sComponent,k8sResource,source,helmRelease,deployment,crdSimple,instanceSimple k8sObject; class ocmRepo,ocmCV,ocmResource ocm; class k8sCluster cluster; class legend legendStyle; The above diagram shows an OCM resource of type helmChart. This resource is part of an OCM component version, which is located in an OCM repository.\nIn the Kubernetes Cluster we can see several Kubernetes (custom) resources. The ResourceGraphDefinition (RGD: Simple) contains the template of all the resources for deploying the Helm chart into the Kubernetes cluster. kro creates a Custom Resource Definition (CRD) Simple based on that ResourceGraphDefinition. By creating an instance of this CRD (Instance: Simple), the resources are created and reconciled by the respective controllers:\nRepository: Points to the OCM repository and checks if it is reachable by pinging it. Component: Refers to the Repository and downloads and verifies the OCM component version descriptor. Resource: Points to the Component, downloads the OCM component version descriptor from which it gets the location of the OCM resource. It then downloads the resource to verify its signature (optional) and publishes the location of the resource in its status. With FluxCD, this only works if the OCM resource has an access for which FluxCD has a corresponding Source type (e.g. an OCI or a GitHub repository)\nAs a result, FluxCD can now consume the information of the Resource and deploy the Helm chart:\nOCIRepository: Watches and downloads the resource from the location provided by the Resource status. HelmRelease: Refers to the OCIRepository, lets you configure the Helm chart, and creates the deployment into the Kubernetes cluster. While the OCM controllers technically can be used standalone, they require kro and a deployer, e.g. FluxCD, to deploy an OCM resource into a Kubernetes cluster. The OCM controller deployment, however, does not contain kro or any deployer. Please refer to the respective installation guides for these tools:\nkro FluxCD Getting Started Setup your (test) environment with kind, kro, and FluxCD Deploying a Helm chart using a ResourceGraphDefinition with FluxCD Deploying a Helm chart using a ResourceGraphDefinition inside the OCM component version (bootstrap) with FluxCD Configuring credentials for OCM controller resources to access private OCM repositories ","date":"0001-01-01","id":15,"permalink":"/docs/concepts/ocm-controllers/","summary":"\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \r\n    \u003cdiv class=\"callout-body\"\u003e\r\n      \u003cp\u003eThis project is in early development and not yet ready for production use.\u003c/p\u003e","tags":[],"title":"OCM Controllers"},{"content":"","date":"0001-01-01","id":16,"permalink":"/docs/tutorials/","summary":"","tags":[],"title":"Tutorials"},{"content":"This chapter contains guidelines for common scenarios how to work with the Open Component Model, focusing on using CI/CD, build and publishing processes.\nUse Public Schema for Validation and Auto-Completion of Component Descriptors Separate Build and Publish Processes Using Makefiles Prerequisites Example Makefile Templating the Resources Pipeline Integration Static and Dynamic Variable Substitution Example Substitution File Debugging: Explain the Blobs Directory Self-Contained Transport Archives CICD Integration Use Public Schema for Validation and Auto-Completion of Component Descriptors The Open Component Model (OCM) provides a public schema to validate and offer auto-completion of component constructor files used to create component descriptors. This schema is available at https://ocm.software/schemas/configuration-schema.yaml.\nTo use this schema in your IDE, you can add the following line to your component constructor file:\n# yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml\rThis line tells the YAML language server to use the OCM schema for validation and auto-completion.\nSeparate Build and Publish Processes Traditional automated builds often have unrestricted internet access, which can lead to several challenges in enterprise environments:\nLimited control over downloaded artifacts Potential unavailability of required resources Security risks associated with write permissions to external repositories Best practice: Implement a two-step process: a) Build: Create artifacts in a controlled environment, using local mirrors when possible. b) Publish: Use a separate, secured process to distribute build results.\nOCM supports this approach through filesystem-based OCM repositories, allowing you to generate Common Transport Format (CTF) archives for component versions. These archives can then be securely processed and distributed.\nUsing Makefiles Developing applications and services using the Open Component Model usually is an iterative process of building artifacts, generating OCM component versions and finally publishing them. To simplify this process it should be automated and integrated into your build process. One option is to use a Makefile.\nThe following example can be used as a starting point and can be modified according to your needs. In this example we will use the same example as in the sections before:\nCreating a multi-arch image from Go sources from a Git repository using the Docker CLI Packaging the Docker image and a Helm chart into a CTF archive Signing and publishing the build result Prerequisites The OCM CLI must be installed and be available in your PATH The Makefile is located in the top-level folder of a Git project Operating system is Unix/Linux A sub-directory local can be used for local settings e.g. environment variables, RSA keys, \u0026hellip; A sub-directory gen will be used for generated artifacts from the make build command It is recommended to add local/ and gen/ to the .gitignore file We use the following file system layout for the example:\n$ tree . . ├── Dockerfile ├── LICENSE ├── Makefile ├── README.md ├── go.mod ├── helmchart │ ├── Chart.yaml │ ├── templates │ │ ├── NOTES.txt │ │ ├── _helpers.tpl │ │ ├── deployment.yaml │ │ ├── hpa.yaml │ │ ├── ingress.yaml │ │ ├── service.yaml │ │ ├── serviceaccount.yaml │ │ └── tests │ │ └── test-connection.yaml │ └── values.yaml ├── local │ └── env.sh ├── main.go ├── resources.yaml └── VERSION\rExample Makefile NAME ?= simpleserver PROVIDER ?= acme.org GITHUBORG ?= acme IMAGE = ghcr.io/$(GITHUBORG)/demo/$(NAME) COMPONENT = $(PROVIDER)/demo/$(NAME) OCMREPO ?= ghcr.io/$(GITHUBORG)/ocm MULTI ?= true PLATFORMS ?= linux/amd64 linux/arm64 REPO_ROOT = . VERSION = $(shell git describe --tags --exact-match 2\u0026gt;/dev/null|| echo \u0026#34;$$(cat $(REPO_ROOT)/VERSION)\u0026#34;) COMMIT = $(shell git rev-parse HEAD) EFFECTIVE_VERSION = $(VERSION)-$(COMMIT) GIT_TREE_STATE := $(shell [ -z \u0026#34;$(git status --porcelain 2\u0026gt;/dev/null)\u0026#34; ] \u0026amp;\u0026amp; echo clean || echo dirty) GEN = ./gen OCM = ocm CHART_SRCS=$(shell find helmchart -type f) GO_SRCS=$(shell find . -name \\*.go -type f) ifeq ($(MULTI),true) FLAGSUF = .multi endif .PHONY: build build: $(GEN)/build .PHONY: version version: @echo $(VERSION) .PHONY: ca ca: $(GEN)/ca $(GEN)/ca: $(GEN)/.exists $(GEN)/image.$(NAME)$(FLAGSUF) resources.yaml $(CHART_SRCS) $(OCM) create ca -f $(COMPONENT) \u0026#34;$(VERSION)\u0026#34; --provider $(PROVIDER) --file $(GEN)/ca $(OCM) add resources --templater spiff $(GEN)/ca COMMIT=\u0026#34;$(COMMIT)\u0026#34; VERSION=\u0026#34;$(VERSION)\u0026#34; \\ IMAGE=\u0026#34;$(IMAGE):$(VERSION)\u0026#34; PLATFORMS=\u0026#34;$(PLATFORMS)\u0026#34; MULTI=$(MULTI) resources.yaml @touch $(GEN)/ca $(GEN)/build: $(GO_SRCS) go build . @touch $(GEN)/build .PHONY: image image: $(GEN)/image.$(NAME) $(GEN)/image.$(NAME): $(GEN)/.exists Dockerfile $(OCMSRCS) docker build -t $(IMAGE):$(VERSION) --file Dockerfile $(COMPONENT_ROOT) .; @touch $(GEN)/image.$(NAME) .PHONY: multi multi: $(GEN)/image.$(NAME).multi $(GEN)/image.$(NAME).multi: $(GEN)/.exists Dockerfile $(GO_SRCS) echo \u0026#34;Building Multi $(PLATFORMS)\u0026#34; for i in $(PLATFORMS); do \\ tag=$$(echo $$i | sed -e s:/:-:g); \\ echo \u0026#34;Building platform $$i with tag: $$tag\u0026#34;; \\ docker buildx build --load -t $(IMAGE):$(VERSION)-$$tag --platform $$i .; \\ done @touch $(GEN)/image.$(NAME).multi .PHONY: ctf ctf: $(GEN)/ctf $(GEN)/ctf: $(GEN)/ca @rm -rf $(GEN)/ctf $(OCM) transfer ca $(GEN)/ca $(GEN)/ctf touch $(GEN)/ctf .PHONY: push push: $(GEN)/ctf $(GEN)/push.$(NAME) $(GEN)/push.$(NAME): $(GEN)/ctf $(OCM) transfer ctf -f $(GEN)/ctf $(OCMREPO) @touch $(GEN)/push.$(NAME) .PHONY: transport transport: ifneq ($(TARGETREPO),) $(OCM) transfer component -Vc $(OCMREPO)//$(COMPONENT):$(VERSION) $(TARGETREPO) else @echo \u0026#34;Cannot transport no TARGETREPO defined as destination\u0026#34; \u0026amp;\u0026amp; exit 1 endif $(GEN)/.exists: @mkdir -p $(GEN) @touch $@ .PHONY: info info: @echo \u0026#34;VERSION: $(VERSION)\u0026#34; @echo \u0026#34;COMMIT: $(COMMIT)\u0026#34; @echo \u0026#34;TREESTATE: $(GIT_TREE_STATE)\u0026#34; .PHONY: describe describe: $(GEN)/ctf ocm get resources --lookup $(OCMREPO) -r -o treewide $(GEN)/ctf .PHONY: descriptor descriptor: $(GEN)/ctf ocm get component -S v3alpha1 -o yaml $(GEN)/ctf .PHONY: clean clean: rm -rf $(GEN) The Makefile supports the following targets:\nbuild (default) simple Go build version show current VERSION of Github repository image build a local Docker image multi build multi-arch images with Docker\u0026rsquo;s buildx command ca execute build and create a component archive ctf create a common transport format archive push push the common transport archive to an OCI registry info show variables used in Makefile (version, commit, etc.) describe display the component version in a tree-form descriptor show the component descriptor of the component version transport transport the component from the upload repository into another OCM repository clean delete all generated files (but does not delete Docker images) The variables assigned with ?= at the beginning can be set from outside and override the default declared in the Makefile. Use either an environment variable or an argument when calling make.\nExample:\nPROVIDER=foo make ca\rTemplating the Resources The Makefile uses a dynamic list of generated platforms for the images. You can just set the PLATFORMS variable:\nMULTI ?= true PLATFORMS ?= linux/amd64 linux/arm64 If MULTI is set to true, the variable PLATFORMS will be evaluated to decide which image variants will be built. This has to be reflected in the resources.yaml. It has to use the input type dockermulti and list all the variants which should be packaged into a multi-arch image. This list depends on the content of the Make variable.\nThe OCM CLI supports this by enabling templating mechanisms for the content by selecting a templater using the option --templater .... The example uses the Spiff templater.\n$(GEN)/ca: $(GEN)/.exists $(GEN)/image.$(NAME)$(FLAGSUF) resources.yaml $(CHART_SRCS) $(OCM) create ca -f $(COMPONENT) \u0026#34;$(VERSION)\u0026#34; --provider $(PROVIDER) --file $(GEN)/ca $(OCM) add resources --templater spiff $(GEN)/ca COMMIT=\u0026#34;$(COMMIT)\u0026#34; VERSION=\u0026#34;$(VERSION)\u0026#34; \\ IMAGE=\u0026#34;$(IMAGE):$(VERSION)\u0026#34; PLATFORMS=\u0026#34;$(PLATFORMS)\u0026#34; MULTI=$(MULTI) resources.yaml @touch $(GEN)/ca The variables given to the add resources command are passed to the templater. The template looks like:\nname: image type: ociImage version: (( values.VERSION )) input: type: (( bool(values.MULTI) ? \u0026#34;dockermulti\u0026#34; :\u0026#34;docker\u0026#34; )) repository: (( index(values.IMAGE, \u0026#34;:\u0026#34;) \u0026gt;= 0 ? substr(values.IMAGE,0,index(values.IMAGE,\u0026#34;:\u0026#34;)) :values.IMAGE )) variants: (( bool(values.MULTI) ? map[split(\u0026#34; \u0026#34;, values.PLATFORMS)|v|-\u0026gt; values.IMAGE \u0026#34;-\u0026#34; replace(v,\u0026#34;/\u0026#34;,\u0026#34;-\u0026#34;)] :~~ )) path: (( bool(values.MULTI) ? ~~ :values.IMAGE ))\rBy using a variable values.MULTI, the command distinguishes between a single Docker image and a multi-arch image. With map[], the platform list from the Makefile is mapped to a list of tags created by the docker buildx command used in the Makefile. The value ~~ is used to undefine the yaml fields not required for the selected case (the template can be used for multi- and single-arch builds).\n$(GEN)/image.$(NAME).multi: $(GEN)/.exists Dockerfile $(GO_SRCS) echo \u0026#34;Building Multi $(PLATFORMS)\u0026#34; for i in $(PLATFORMS); do \\ tag=$$(echo $$i | sed -e s:/:-:g); \\ echo \u0026#34;Building platform $$i with tag: $$tag\u0026#34;; \\ docker buildx build --load -t $(IMAGE):$(VERSION)-$$tag --platform $$i .; \\ done @touch $(GEN)/image.$(NAME).multi Pipeline Integration Pipeline infrastructures are heterogeneous, so there is no universal answer how to integrate a build pipeline with OCM. Usually, the simplest way is using the OCM command line interface. Following you will find an example using GitHub actions.\nThere are two repositories dealing with GitHub actions: The first one provides various actions that can be called from a workflow. The second one provides the required installation of the OCM CLI into the container.\nAn typical workflow for a build step will create a component version and a transport archive:\njobs: create-ocm: runs-on: ubuntu-latest steps: ... - name: setup OCM uses: open-component-model/ocm-setup-action@main ... - name: create OCM component version uses: open-component-model/ocm-action@main with: action: create_component component: acme.org/demo/simpleserver provider: ${{ env.PROVIDER }} version: github.com/jensh007 ...\rThis creates a component version for the current build. Additionally, a CTF archive can be created or the component version along with the built container images can be uploaded to an OCI registry, etc.\nMore documentation is available here. A full example can be found in the sample Github repository.\nStatic and Dynamic Variable Substitution Some variables like the version or the commit change with every build or release. In many cases, these variables will be auto-generated during the build.\nOther variables like the version of 3rd-party components will just change from time to time and are often set manually by an engineer or release manager. It is useful to separate between static and dynamic variables. Static files can be checked-in into the source control system and are maintained manually. Dynamic variables can be generated during the build.\nExample Substitution File The following example shows how to separate static and dynamic variables.\nStatic settings, manually maintained:\nNAME: microblog COMPONENT_NAME_PREFIX: github.com/acme.org/microblog PROVIDER: ocm.software ELASTIC_VERSION: 8.5.1 MARIADB_VERSION: 10.6.11 MARIADB_CHART_VERSION: 11.4.2 NGINX_VERSION: 1.5.1 NGINX_CHART_VERSION: 4.4.2\rauto-generated from a build script:\nVERSION: 0.23.1 COMMIT: 5f03021059c7dbe760ac820a014a8a84166ef8b4\rocm add componentversions --create --file ../gen/ctf --settings ../gen/dynamic_settings.yaml --settings static_settings.yaml component-constructor.yaml\rDebugging: Explain the Blobs Directory For analyzing and debugging the content of a CTF archive, there are some supportive commands to analyze what is contained in the archive and what is stored in which blob:\ntree ../gen/ctf ../gen/ctf ├── artifact-index.json └── blobs ├── ... ├── sha256.59ff88331c53a2a94cdd98df58bc6952f056e4b2efc8120095fbc0a870eb0b67 ├── ...\rocm get resources -r -o wide ../gen/ctf ... --- REFERENCEPATH: github.com/acme.org/microblog/nginx-controller:1.5.1 NAME : nginx-controller-chart VERSION : 1.5.1 IDENTITY : TYPE : helmChart RELATION : local ACCESSTYPE : localBlob ACCESSSPEC : {\u0026#34;localReference\u0026#34;:\u0026#34;sha256:59ff88331c53a2a94cdd98df58bc6952f056e4b2efc8120095fbc0a870eb0b67\u0026#34;,\u0026#34;mediaType\u0026#34;:\u0026#34;application/vnd.oci.image.manifest.v1+tar+gzip\u0026#34;,\u0026#34;referenceName\u0026#34;:\u0026#34;github.com/acme.org/microblog/nginx-controller/ingress-nginx:4.4.2\u0026#34;} ...\rSelf-Contained Transport Archives The transport archive created from a component constructor file, using the command ocm add componentversions --create ..., does not automatically resolve image references to external OCI registries and stores them in the archive. If you want to create a self-contained transport archive with all images stored as local artifacts, you need to use the --copy-resources option in the ocm transfer ctf command. This will copy all external images to the blobs directory of the archive.\nocm transfer ctf --copy-resources \u0026lt;ctf-dir\u0026gt; \u0026lt;new-ctf-dir-or-oci-repo-url\u0026gt;\rNote that this archive can become huge, depending on the size of the external images !\nCICD Integration Configure rarely changing variables in a static file and generate dynamic variables during the build from the environment. See the Static and Dynamic Variable Substitution section above.\n","date":"0001-01-01","id":17,"permalink":"/docs/tutorials/best-practices/","summary":"\u003cp\u003eThis chapter contains guidelines for common scenarios how to work with the Open Component Model, focusing on using CI/CD, build and publishing processes.\u003c/p\u003e","tags":[],"title":"Best Practices"},{"content":"Introduction In this tutorial software products are comprised of logical units called components. A component version consists of a set of technical artifacts (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called resources in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named sources in this specification.\nOCM introduces a Component Version for every component version that describes the resources, sources, and other component versions belonging to a particular component version and how to access them.\nUsually, however, real-life applications are composed of multiple components. For example, an application might consist of a frontend, a backend, a database, and a web server. During the software development process new component versions are created and third-party components might be consumed from a public registry and updated from time to time.\nNot all component version combinations of frontend, backend, database, etc. are compatible and form a valid product version. In order to define reasonable version combinations for the software product, we could use another feature of OCM\u0026rsquo;s Component Version, called a Component Reference (or reference in short), which allows the aggregation of component versions.\nFor each sub-component and each version in use, there is a Component Version. For the entire application, we introduce a new component that describes the overall software product referencing all components. This describes the entire application or product.\nA particular version of this application is again described by a Component Version, which contains references to the Component Versions of its sub-components in their version in use. You are not restricted to this approach. It is, e.g., possible to create multi-level hierarchies or you could just maintain a list of component version combinations which build a valid product release.\nIn a nutshell, OCM provides a simple approach to specify what belongs to a product version. Starting with the Component Version for a product version and following the component references, you could collect all artifacts belonging to this product version.\nPrerequisites We assume that you have already read the guides in the Getting Started section, as this guide discusses a more complex scenario.\nConstructing the Component We are going to use podinfo in microservices mode. This describes a setup with multiple microservices forming a larger application.\npodinfo has three services which we are going to model using individual component versions:\nbackend frontend cache (redis) We will use the following example application to demonstrate a multi-component structure using podinfo: Podinfo Component.\nThis repository contains the following items:\nComponent File The following component-constructor file describes four components: three components, each representing a podinfo microservice and one aggregated component that brings together the podinfo components using references. We refer to the aggregated component as the product component. A component-constructor file can contain one or multiple components and references to other components. The file is a YAML file and can be validated using the OCM schema.\n# specify a schema to validate the configuration and get auto-completion in your editor # yaml-language-server: $schema=https://ocm.software/schemas/configuration-schema.yaml components: # -- product component - name: ocm.software/podinfo version: 1.0.2 labels: - name: ocm.software/labels/podinfo/purpose value: - kind: test type: manual provider: name: open-component-model componentReferences: - name: backend componentName: ocm.software/podinfo/backend version: 1.0.0 - name: frontend componentName: ocm.software/podinfo/frontend version: 1.0.0 - name: redis componentName: ocm.software/redis version: 1.0.0 sources: - access: commit: ac0afafcf4aa333546634cba631f0090a0a4cbe3 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- backend component - name: ocm.software/podinfo/backend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: backend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: backend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: backend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- frontend component - name: ocm.software/podinfo/frontend version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: frontend resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: frontend/config.yaml compress: true - name: image relation: external type: ociImage version: 6.2.0 access: type: ociArtifact imageReference: ghcr.io/stefanprodan/podinfo:6.2.0 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: frontend/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0 # -- redis component - name: ocm.software/redis version: 1.0.0 provider: name: open-component-model labels: - name: ocm.software/labels/podinfo/service value: redis resources: - name: config type: configdata.ocm.software input: type: file mediaType: application/yaml path: redis/config.yaml compress: true - name: image relation: external type: ociImage version: 6.0.1 access: type: ociArtifact imageReference: redis:6.0.1 - name: manifests type: kustomize.ocm.fluxcd.io input: type: dir path: redis/manifests compress: true sources: - access: commit: 9d294e85d8d3fe7803d1eccbf009619078d30cb9 ref: refs/heads/main repoUrl: https://github.com/open-component-model/podinfo type: github name: github_com_open_component_model_podinfo type: git version: 1.0.0\rWith the components modeled we can start to build a component archive using the ocm cli:\nocm add componentversions --create --file component-archive component-constructor.yaml processing component-constructor.yaml... processing document 1... processing index 1 processing index 2 processing index 3 processing index 4 found 4 components adding component ocm.software/podinfo:1.0.2... adding reference ocm.software/podinfo/backend: \u0026#34;name\u0026#34;=\u0026#34;backend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/podinfo/frontend: \u0026#34;name\u0026#34;=\u0026#34;frontend\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding reference ocm.software/redis: \u0026#34;name\u0026#34;=\u0026#34;redis\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;1.0.0\u0026#34;... adding component ocm.software/podinfo/backend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/podinfo/frontend:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.2.0\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding component ocm.software/redis:1.0.0... adding resource configdata.ocm.software: \u0026#34;name\u0026#34;=\u0026#34;config\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;... adding resource ociImage: \u0026#34;name\u0026#34;=\u0026#34;image\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;6.0.1\u0026#34;... adding resource kustomize.ocm.fluxcd.io: \u0026#34;name\u0026#34;=\u0026#34;manifests\u0026#34;,\u0026#34;version\u0026#34;=\u0026#34;\u0026lt;componentversion\u0026gt;\u0026#34;...\rThis will create a folder called component-archive. The structure of that should look something like this:\ntree . . ├── artifact-index.json └── blobs ├── sha256.03ac3a7611e118d08fcf70e9b7be263c4a7082066f9763f71d8901d7fa2afc9d ├── sha256.118b6e8282ee1d335b1638a76a20022b6acc319177dbbce3089700da835afb6a ├── sha256.12073781e4fba95f19f046c51c90f0c4e1338d47afe4795bf6fcca163ae46eb8 ├── sha256.1f239399104ec0cc7680956eb60960d212b3368609feb83dac2c95040d24b480 ├── sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e ├── sha256.3dc6209959eb782fa6f5f44892f66e9657276735bfb40407bd00ddca30d0a9d1 ├── sha256.654debd65dbadbcee73e55b675980865ddf22acffcec166c59a5e48a213e4dd5 ├── sha256.699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0 ├── sha256.70a47378c043721e3099801dec02c44b1dd9cdef0ebf79c55784eb4666bdbc29 ├── sha256.773b28fb63f1195ff73e328744639ddc1c574d58c1e723d6e386fcd66b45bd9c ├── sha256.893be914eebd8230ef848ea82b3433c6201152f5d9925e7b5b8d68e0cec7133e ├── sha256.92991cf391167c928f3afe6891001f3dd325b64ce800cf34fad4c038141fc57f ├── sha256.98ca4d46130f5c09a704b3d8ee9af94de3c0ac73d7e990df53e64606c418fea8 ├── sha256.a779270c2fea310835d3125de90e089e423c9730a98f1acdda328470d21fced0 ├── sha256.a7dd532f80e8417ed33cf0c97328582847017895fc5146e499bdf4c94a9d17b5 ├── sha256.cae4365f264251c616210707aa4765bd95f23fd22f98abc68bae9f58d6e4506d ├── sha256.ee79c92bbcce9e7a98f07c6577fd56dd45cf6f7c2d3115216ee249f42119030e └── sha256.f6a82a23220752c232e5f66ce46f0be28b27a5af19474072c77dac6d1feb0c16 2 directories, 19 files\rThese blobs contain the resources we described when modelling our podinfo application. If we cat a random blob we get something like this:\ncat sha256.3c9c902ce013ca070a29634e4603c90063c96df632ef2c8e6b4447aaeb70b67e {\u0026#34;componentDescriptorLayer\u0026#34;:{\u0026#34;mediaType\u0026#34;:\u0026#34;application/vnd.ocm.software.component-descriptor.v2+yaml+tar\u0026#34;,\u0026#34;digest\u0026#34;:\u0026#34;sha256:699ea8628e39256048cd1687c496fe64999a41f16f200ef5ce938ee9f19c37f0\u0026#34;,\u0026#34;size\u0026#34;:2560}}%\rNext, we transfer this component to an OCI registry of your choice. Here \u0026lt;your-location\u0026gt; for me was ghcr.io/skarlso/demo-component.\nocm transfer component ./component-archive \u0026lt;your-location\u0026gt; transferring version \u0026#34;ocm.software/podinfo:1.0.2\u0026#34;... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/backend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/podinfo/frontend:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... transferring version \u0026#34;ocm.software/redis:1.0.0\u0026#34;... ...resource 0... ...resource 2... ...adding component version... 4 versions transferred\rWith the transfer completed, we now have a product *Component Version* that describes a set of sub-components using *Component References*. It bundles all required artifacts for a successful deployment of the complete product.\nConclusion We saw how to create a complex, multi-service architecture product component and store it in an OCI registry.\n","date":"0001-01-01","id":18,"permalink":"/docs/tutorials/structure-software-products-with-ocm/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this tutorial software products are comprised of logical units called \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/concepts/ocm-components/\"\u003e\u003cem\u003ecomponents\u003c/em\u003e\u003c/a\u003e. A component version consists of a set of technical \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm-spec/blob/main/doc/04-extensions/01-artifact-types/README.md\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003eartifacts\u003c/em\u003e\u003c/a\u003e (e.g., Docker images, Helm charts, binaries, configuration data, etc.). Such artifacts are called \u003cem\u003eresources\u003c/em\u003e in this specification. Resources are usually built from something, e.g., code in a git repo. Those are named \u003cem\u003esources\u003c/em\u003e in this specification.\u003c/p\u003e","tags":[],"title":"Structure Software Products with OCM"},{"content":" Overview Input Types binary dir docker dockermulti file helm ociImage spiff utf-8 Access Types gitHub helm npm ociArtifact s3 Overview The Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\nAn Input type adds content by value, along with the component descriptor and stores it in the same target repository where the component is stored. After pushing the content to the target registry this always resolves to the attribute\nrelation: local\rin a component descriptor.\nAn Access Type just adds content by reference to an external location, e.g., an OCI registry. It is a kind of pointer in a component descriptor. It resolves to the attribute\nrelation: external\rin a component descriptor.\nThe following input types are supported:\nbinary dir docker dockermulti file helm ociImage spiff utf-8 Please use the latest ocm-cli to check available input types:\nocm add resources --help | grep \u0026#39; - Input type\u0026#39; | sort -f\rThe following list of access types is supported:\ngitHub localBlob ociArtifact ociBlob s3 Please use the latest ocm-cli to check available access types:\nocm ocm-accessmethods | grep \u0026#39; - Access type\u0026#39; | sort -f\rNot all access and input types can be combined in useful ways with all artifact types. But the OCM specification does not define any restrictions on possible combinations.\nThe following sections give an overview and typical usage examples for access and input types. It does not describe the full list of possible fields and their meaning. For a complete list of attributes, please see the command reference. The examples below are meant to be used in a component that looks like this:\n- name: github.com/open-component-model/megacomponent version: 0.1.0\rInput Types binary Allows to define resources with binary content being base64 encoded. Should only be used for smaller blobs.\nresources: - name: noticeencoded type : blob input: data: VGhpcyBpcyBzb21lIGJhc2U2NCBlbmNvZGVkIGRhdGEK mediaType: text/plain compress: false type: binary\rdir Defines a resource from content of a directory in the local file system. It is packed with tar and optionally compressed.\nresources: - name: megadir type : fileSystem input: type: dir path: ./logos\rdocker Takes an image from the local docker registry and adds it as a resource. Requires a running docker daemon.\nresources: - name: megaimage type : ociImage input: type: docker repository: images/mega path: megacomp:${VERSION}\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0 9aab9cbca56e 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/mega:1.10.\ndockermulti Takes multiple images from the local docker registry and adds them as single multi-arch image. Requires a running docker daemon. The images have to be built for different architectures/os and need a unique tag identifying them. As docker does not support multi-arch images at the time of writing this is a workaround.\nresources: - name: megaimagemulti type : ociImage input: type: dockermulti repository: images/megamulti variants: - megacomp:${VERSION}-linux-amd64 - megacomp:${VERSION}-linux-arm64\rif VERSION is set to 0.1.0 the following image is imported:\ndocker image ls REPOSITORY TAG IMAGE ID CREATED SIZE megacomp 0.1.0-linux-amd64 96659c4f7a35 5 days ago 7.05MB megacomp 0.1.0-linux-arm64 64f209acb814 5 days ago 7.46MB\rThe target location of the image can be set with the repository field. Here the resulting image will be stored at \u0026lt;REPO_URL\u0026gt;/github.com/open-component-model/megacomponent/images/megamulti:1.10.\nfile Imports a file from the local file system and adds it as a resource.\nresources: - name: mega-file type: blob input: type: file path: ./logos/logo-image.png\rhelm Imports a helm chart from the local file system and adds it as a resource.\nresources: - name: mega-chart type: helmChart input: type: helm path: ./megachart repository: charts/mega\rAfter transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mega prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mega. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used.\nIt is also possible to import a helm chart from a helm chart repository:\nresources: - name: mariadb-chart type: helmChart input: type: helm helmRepository: https://charts.bitnami.com/bitnami path: mariadb version: 12.2.7 repository: charts/mariadb\rHere the helm chart version 12.2.7 is copied from the path mariadb in helm chart repository https://charts.bitnami.com/bitnami. After transporting the corresponding component version to an OCI registry, the helm chart will be made available under charts/mariadb prefixed by the name of the component version. This auto-prefix can be disabled by using a leading slash /charts/mariadb. If the repository tag is omitted, the name of the helm chart from Chart.yaml will be used. There are additional optional fields caCert and caCertFile to specify a TLS certificate for the helm chart repository.\nociImage Takes an image that is located in an OCI registry and adds it as a resource.\nresources: - name: mega-image type: ociImage input: type: ociImage path: gcr.io/google_containers/echoserver:1.10 repository: images/echo\rThe target location of the image after transporting to an OCI registry can be set with the repository field. Here the resulting image will be prefixed with the name of the component version, e.g., github.com/open-component-model/megacomponent/images/echo:1.10. This auto-prefix can be disabled by using a leading slash /images/echo.\nspiff Processes a resource using the spiff templater and can provide values for variables.\nresources: - name: mega-package type: toiPackage input: type: spiff mediaType: application/vnd.toi.ocm.software.package.v1+yaml path: packagespec.yaml values: RELEASE_NAME: megacomp\rutf-8 Adds a resource from inline text.\nresources: - name: noticeplain type : blob input: text: \u0026#34;Here is some text\u0026#34; mediaType: text/plain compress: false type: utf8\rAccess Types gitHub Refers to a Git repository at a certain commit or tag.\nresources: - name: git-ocm type: blob version: ${VERSION} access: type: gitHub repoUrl: https://github.com/open-component-model/ocm commit: 42cc249aec77aa64984b2b91eb0f3b96dd63aacd\rhelm Refers to a helm chart located in a helm chart repository.\n- name: mariadb-chart type: helmChart version: ${VERSION} access: type: helm helmChart: mariadb:12.2.7 helmRepository: https://charts.bitnami.com/bitnami\rnpm Refers to an npm package located in a Javascript package registry.\n- name: prime-npm type: ocm/npmPackage version: ${VERSION} access: type: npm package: random-prime version: 4.0.0 registry: https://registry.npmjs.org\rociArtifact Refers to an image in an (external) OCI registry.\nresources: - name: echo-image version: \u0026#34;1.10\u0026#34; type: ociImage access: type: ociArtifact imageReference: gcr.io/google_containers/echoserver:1.10\rs3 Refers to an object in an AWS S3 store.\nresources: - name: gardenlinux-meta type: blob version: ${VERSION} access: type: s3 bucket: gardenlinux key: meta/singles/gcp-cloud-gardener-_prod-890.0-53b732\r","date":"0001-01-01","id":19,"permalink":"/docs/tutorials/input-and-access-types/","summary":"\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#overview\"\u003eOverview\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#input-types\"\u003eInput Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#binary\"\u003ebinary\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dir\"\u003edir\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#docker\"\u003edocker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#dockermulti\"\u003edockermulti\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#file\"\u003efile\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociimage\"\u003eociImage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#spiff\"\u003espiff\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#utf-8\"\u003eutf-8\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#access-types\"\u003eAccess Types\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#github\"\u003egitHub\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#helm-1\"\u003ehelm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#npm\"\u003enpm\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#ociartifact\"\u003eociArtifact\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"#s3\"\u003es3\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways to add content: Input Type and Access Type.\u003c/p\u003e","tags":[],"title":"Input and Access Types"},{"content":"Overview The OCM command line client can be configured by supplying it with a configuration file. By default, the CLI looks for configuration in $HOME/.ocmconfig, if it exists.\nThe configuration file can be used in particular to specify the credentials, which are required for the CLI to be able to access the artifact repositories referenced in CLI commands.\nExamples This page contains basic examples of credentials configuration for a few most common artifact repository types. The examples below are complete .ocmconfig files, not snippets.\nFor comprehensive documentation on the credentials topic, including usage of certificates or HashiCorp Vault, execute the command ocm credential-handling.\nRepositories and Consumers In the examples below, some configuration is located under configurations[0].repositories, and some other under configurations[0].consumers. This chapter explains the difference between repositories and consumers, which is potentially not as obvious as one could think.\nIn this context, repository is a place where credentials can be stored, i.e., it is a credentials repository. For example, Docker\u0026rsquo;s config.json can store multiple credentials, and in that sense the file serves as a repository that can store and provide credentials. That is why its location is configured under repositories. Other examples of credentials repositories can be the NPM\u0026rsquo;s .npmrc file or a HashiCorp Vault instance.\nA consumer is something the credentials are required for. For example, if you need to configure credentials that are required to log in to an OCI registry, one could say that the registry will be consuming these credentials, i.e., the registry is a credentials consumer. That is why it is configured under consumers.\nReuse Credentials Configured for Docker This .ocmconfig file will tell the OCM CLI to use credentials configuration from Docker\u0026rsquo;s config.json file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34;\rReuse Credentials Configured for npm This .ocmconfig file will tell OCM CLI to use credentials configuration from npm\u0026rsquo;s .npmrc file.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: NPMConfig/v1 npmrcFile: \u0026#39;~/.npmrc\u0026#39;\rAccessing OCI Registries HTTPS and Path To access artifacts in https://ghcr.io/open-component-model:\nThe different parts of the URL have to be specified in separate fields: scheme, hostname, and pathprefix The fields scheme and pathprefix are optional. If not specified, the OCM CLI will use the credentials for all schemes and paths on that host The password is the user\u0026rsquo;s basic authentication password. Some OCI registries allow to generate user access tokens, which can also be used for basic authentication type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rHTTP, Port Number, Empty Path To access artifacts in http://127.0.0.1:5001:\nThe fields scheme and port are optional. If not specified, the OCM CLI will use the credentials for all schemes and ports on that host As the URL has no path behind the port number, the pathprefix element can be removed type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: http hostname: 127.0.0.1 port: 5001 credentials: - type: Credentials properties: username: admin password: admin\rAccessing Helm Chart Repositories Similar to OCI registries, but uses HelmChartRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: HelmChartRepository hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token\rAccessing Maven Repositories Similar to OCI registries, but uses MavenRepository as identity type.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: MavenRepository hostname: maven.repo.host pathprefix: path/to/repo credentials: - type: Credentials properties: username: some-user password: some-password\rAccessing npm Registries Similar to OCI registries, but uses NpmRegistry as identity type. In addition, it is required to specify the email address matching with the one in the user record in the npm registry.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: NpmRegistry hostname: npm.registry.host pathprefix: path/to/registry credentials: - type: Credentials properties: username: some-user password: some-password email: foo.bar@acme.org\rAccessing GitHub Repositories To access code in https://my.github.enterprise/my-org/my-repo:\nUse Github as identity type hostname is the domain name of the GitHub instance pathprefix is a combination of organization and repository names token is a personal access token generated in GitHub Developer Settings type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\rAccessing Several Systems It is, of course, possible to configure credentials for several systems in the same .ocmconfig file. To do that, you can combine as many repositories and consumers as you need.\nThe example below instructs OCM CLI to look for credentials in Docker\u0026rsquo;s config.json, and in addition specifies dedicated credentials for an OCI registry and a GitHub repository.\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true consumers: - identity: type: OCIRegistry hostname: ghcr.io pathprefix: open-component-model credentials: - type: Credentials properties: username: some-user password: some-token - identity: type: Github hostname: my.github.enterprise pathprefix: my-org/my-repo credentials: - type: Credentials properties: token: ghp_my_personal_access_token\r","date":"0001-01-01","id":20,"permalink":"/docs/tutorials/credentials-in-an-.ocmconfig-file/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm.md\" target=\"_blank\" rel=\"noopener\"\u003eOCM command line client\u003c/a\u003e can be configured by supplying it with a \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_configfile.md\" target=\"_blank\" rel=\"noopener\"\u003econfiguration file\u003c/a\u003e. By default, the CLI looks for configuration in \u003ccode\u003e$HOME/.ocmconfig\u003c/code\u003e, if it exists.\u003c/p\u003e","tags":[],"title":"Credentials in an .ocmconfig File"},{"content":"OCM controller resources need access to OCM components and their resources. If these OCM components are stored in a private OCM repository, we need to configure credentials to allow OCM controller resources to access these repositories.\nHow to configure credentials? Currently, OCM controllers supports two ways to configure credentials for accessing private OCM repositories:\nKubernetes secret of type dockerconfigjson Kubernetes secret or configmap containing an .ocmconfig file Create a Kubernetes secret of type dockerconfigjson If you already have an existing Docker configuration file that you use to access your private OCM repository, you can create a Kubernetes secret of type dockerconfigjson that contains the credentials:\nkubectl create secret docker-registry ocm-secret --from-file=\u0026lt;path-to-your-docker-config-file\u0026gt;\rBe aware that Kubernetes secrets are only base64 encoded and not encrypted. This means that anyone with access to the Kubernetes secret can access the credentials.\nAccordingly, you should make sure that the Docker configuration file only contains information required for accessing the private OCM repository.\nIn case you want to create the secret manually, you can use the following command to create a Kubernetes secret of type dockerconfigjson:\nkubectl create secret docker-registry ocm-secret \\ --docker-username=\u0026lt;your-name\u0026gt; \\ --docker-password=\u0026lt;your-password\u0026gt; \\ --docker-server=\u0026lt;your-OCM-repository-url\u0026gt;\rCreate a Kubernetes secret or configmap from .ocmconfig file To create a Kubernetes secret or configmap containing an OCM configuration that allows OCM controller resources to access private OCM repositories, you can use the .ocmconfig file used to transfer the OCM component in the first place.\nUsually, the .ocmconfig file is located in your HOME directory. However, this .ocmconfig could contain more configurations than just the credentials for accessing private OCM repositories. As this .ocmconfig will be used to create a Kubernetes secret or configmap to which other users might have access to, you have to make sure that it only contains the configuration you want to share.\nWe recommend to create a new .ocmconfig file that only contains the credentials for accessing the private OCM repository.\nFor more information on how to create and use the .ocmconfig file, please refer to the [OCM CLI credentials documentation][ocm-credentials].\nFor instance, consider you used the following command and .ocmconfig file to transfer the OCM component:\ntype: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software consumers: - identity: type: OCIRegistry scheme: https hostname: ghcr.io pathprefix: \u0026lt;your-namespace\u0026gt; credentials: - type: Credentials properties: username: \u0026lt;your-username\u0026gt; password: \u0026lt;your-password/token\u0026gt;\rocm --config ./.ocmconfig transfer ctf ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rYou can now create a secret in the Kubernetes cluster that contains the .ocmconfig file:\nkubectl create secret generic ocm-secret --from-file=./.ocmconfig\rMake sure that the secret or configmap containing an OCM config has the correct key to the OCM config file .ocmconfig. This is required for OCM controller resources to be able to read the OCM configuration. Using the filename .ocmconfig in the --from-file option takes care of that.\nHow to use the configured credentials? Every OCM controller resource offers a spec.ocmConfig field that can be used to specify the credentials for accessing private OCM repositories. It expects an OCMConfiguration that contains a NamespacedObjectKindReference to the secret or configmap that contains the credentials.\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: helm-configuration-localization-repository spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m ocmConfig: - kind: secret name: ocm-secret\rBy default, the ocmConfig of a resource is propagated and can be consumed by other resources. So, instead of specifying the secret or configmap again, you can reference the resource in the ocmConfig field:\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: guide-repository namespace: default spec: repositorySpec: baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m ocmConfig: - kind: Secret name: ocm-secret --- apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: guide-component spec: component: ocm.software/ocm-k8s-toolkit/guide-component repositoryRef: name: guide-repository semver: 1.0.0 interval: 1m ocmConfig: - kind: Repository apiVersion: delivery.ocm.software/v1alpha1 name: guide-repository namespace: default\rThe above example shows how to use the ocmConfig field in an Repository and a Component. The Repository references a secret named ocm-secret that contains the credentials for accessing the private OCM repository. The Component then references the Repository in ocmConfigand uses the same credentials.\nHowever, you always need to specify a reference to the credentials either as secret, configmap, or as OCM Controller resource for each resource. The credentials will not be propagated automatically to all OCM controller resources in the cluster.\nIn some cases, you do not want to propagate the ocmConfig of a resource. To do so, you can set the policy to DoNotPropagate:\napiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: guide-component spec: component: ocm.software/ocm-k8s-toolkit/guide-component repositoryRef: name: guide-repository semver: 1.0.0 interval: 1m ocmConfig: - kind: Repository apiVersion: delivery.ocm.software/v1alpha1 name: guide-repository namespace: default policy: DoNotPropagate\r","date":"0001-01-01","id":21,"permalink":"/docs/tutorials/configure-credentials-for-ocm-controllers/","summary":"\u003cp\u003eOCM controller resources need access to OCM components and their resources. If these OCM components are stored in a\nprivate OCM repository, we need to configure credentials to allow OCM controller resources to access these\nrepositories.\u003c/p\u003e","tags":[],"title":"Configure Credentials for OCM Controllers"},{"content":"The following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\nThe component is publicly available in the GitHub container registry and can be inspected using the following command:\nocm componentversion get --repo ghcr.io/phoban01/ocm github.com/weaveworks/weave-gitops -oyaml\rmeta: # component schema version schemaVersion: v2 component: # name of the component. Must start with URL-prefix that should be controlled # by the owner of the component to avoid collisions # regex: ^[a-z][-a-z0-9]*([.][a-z][-a-z0-9]*)*[.][a-z]{2,}(/[a-z][-a-z0-9_]*([.][a-z][-a-z0-9_]*)*)+$ name: github.com/weaveworks/weave-gitops # version of the component. Must adhere to “relaxed SemVer” # major, minor (+ optional patch level) - optional v-prefix # regex: ^[v]?(0|[1-9]\\\\d*)(?:\\\\.(0|[1-9]\\\\d*))?(?:\\\\.(0|[1-9]\\\\d*))?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$ version: v1.0.0 # component provider provider: weaveworks # list of labels that can contain arbitrary metadata in form of K/V pairs # labels can be added on component root, resource, source and reference level labels: - name: link-to-documentation value: https://github.com/weaveworks/weave-gitops # list of repository context the component version \u0026#34;lived\u0026#34; in, # with the current one at the top repositoryContexts: - baseUrl: ghcr.io componentNameMapping: urlPath subPath: phoban01/ocm type: OCIRegistry # list of resources that describe the payload of the component resources: # resource name - name: image # resource location (external repository or internal to this repository) relation: external # resource type type: ociImage # resource version. Must also adhere to “relaxed SemVer” (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the resource access: # type of access information type: ociArtifact imageReference: ghcr.io/weaveworks/wego-app:v0.14.1 # signing metadata for the resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: ociArtifactDigest/v1 value: efa2b9980ca2de65dc5a0c8cc05638b1a4b4ce8f6972dc08d0e805e5563ba5bb # list of sources that describe the input for creating the resources sources: # source name - name: weave-gitops # source type type: git # source version. Must also adhere to “relaxed SemVer” (see `component.versio` above`) version: v0.14.1 # metadata describing how to access the source access: commit: 727513969553bfcc603e1c0ae1a75d79e4132b58 ref: refs/tags/v0.14.1 repoUrl: github.com/weaveworks/weave-gitops type: gitHub # list of references to other components componentReferences: # reference name - name: prometheus # reference version version: v1.0.0 # referenced component name componentName: cncf.io/prometheus # signing metadata for the referenced resource (if component has been signed) digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 04eb20b6fd942860325caf7f4415d1acf287a1aabd9e4827719328ba25d6f801 # list of signatures used for signing and verification signatures: # name of the signature - name: ww-dev # digest of the signature including the algorithm used digest: hashAlgorithm: SHA-256 normalisationAlgorithm: jsonNormalisation/v1 value: 4faff7822616305ecd09284d7c3e74a64f2269dcc524a9cdf0db4b592b8cee6a # signature including the algorithm used signature: algorithm: RSASSA-PSS mediaType: application/vnd.ocm.signature.rsa value: 26468587671bdbd2166cf5f69829f090c10768511b15e804294fcb26e552654316c8f4851ed396f279ec99335e5f4b11cb043feb97f1f9a42115f4fda2d31ae8b481b7303b9a913d3a4b92d446fbee9ed487c93b09e513f3f68355040ec08454675e1f407422062abbd2681f70dd5488ad29020b30cfa7e001455c550458da96166bc3243c8426977d73352aface5323fb2b5a374e9c31b272a59c160b85631231c9fc2f23c032401b80fef937029a39111cee34470c61ae86cd4942553466411a5a116159fdcc10e50fe9360c5184028e72d1fe9c7315f26e15d7b4849f62d197501b8cc6b6f1b1391ecc2fc2fc0c1290d2554594505b25fa8f9bfb28c8df24\r","date":"0001-01-01","id":22,"permalink":"/docs/tutorials/example-of-a-component-descriptor/","summary":"\u003cp\u003eThe following is an example of a public-key-based signed component descriptor containing a resource, source and one component reference.\u003c/p\u003e\n\u003cp\u003eThe component is publicly available in the GitHub container registry and can be inspected using the following command:\u003c/p\u003e","tags":[],"title":"Example of a Component Descriptor"},{"content":"The concept and the Deploy Helm Chart guide showed a basic example of how to deploy a Helm chart from an OCM component. By defining a ResourceGraphDefinition that contains all the required resources to deploy the Helm chart into a Kubernetes cluster.\nHowever, there are scenarios, where the developer already knows how the deployment instructions for the Helm chart should look like and what should be configured. Accordingly, the developer can create a ResourceGraphDefinition that contains all the required resources to deploy and configure the Helm chart, and deliver it with the OCM component version itself. This way, the deployment instructions can also be delivered securely through OCM and the operator does not need to know which resources are required.\nIn such a case, we need to bootstrap the ResourceGraphDefinition from the OCM component and apply it to the cluster.\nTo do so, we use the OCM controller resource Deployer. By referencing the Resource containing the ResourceGraphDefinition by name, the deployer will download the content from the OCM component and apply it to the cluster.\nThe following guide demonstrates how to deploy a Helm chart using a ResourceGraphDefinition that is also delivered with the same OCM component. Additionally, it shows how to localize a Helm chart.\nLocalization describes the process of inserting a new image reference into the deployment instructions, e.g. a Helm chart. It is a two-step process:\nWhen an OCM component and its resources are transferred to another registry, referential resources can potentially update their reference to the new location. For instance, a resource with an access type ociArtifact will update its image reference in the component descriptor to the new registry location, if the OCM transfer is done with the flag --copy-resources. However, the deployment using the image is not aware of this change. Accordingly, we need to insert the new image reference into the deployment instruction. This can be done using deployment tools like FluxCDs HelmRelease and Kustomization or ArgoCDs Helm and Kustomize. The following diagram shows an overview of the resources and their relationships of this guide:\nflowchart TB classDef cluster fill:white,color:black,stroke:black; classDef reconciledBy fill:#dedede,stroke:black,stroke-dasharray: 5,color:black; classDef k8sObject fill:#b3b3b3,color:black,stroke:black; classDef information fill:#b3b3b3,color:black,stroke:none; classDef templateOf fill:#b3b3b3,color:black,stroke:black,stroke-dasharray: 2; classDef ocm fill:white,stroke:black,color:black; classDef legendStyle fill:white,stroke:black,color:black,stroke-dasharray: 2; classDef legendStartEnd height:0px; classDef legendItems fill:#b3b3b3,stroke:none,color:black; subgraph legend[Legend] start1[ ] ---references[referenced by] --\u0026gt; end1[ ] start2[ ] -.-creates -.-\u0026gt; end2[ ] start3[ ] ---instanceOf[instance of] --\u0026gt; end3[ ] start4[ ] ~~~reconciledBy[reconciled by] ~~~ end4[ ] start5[ ] ~~~k8sObject[k8s object] ~~~ end5[ ] start6[ ] ~~~templateOf[template of] ~~~ end6[ ] end subgraph background[ ] direction TB subgraph ocmRepo[OCM Repository] subgraph ocmCV[OCM Component Version] direction RL subgraph ocmResourceHelm[OCM Resource: HelmChart] end subgraph ocmResourceImage[OCM Resource: Image] end subgraph ocmResourceRGD[OCM Resource: RGD] end end end subgraph k8sCluster[Kubernetes Cluster] subgraph bootstrap[OCM Controllers] k8sRepo[OCMRepository] k8sComponent[Component] k8sResourceRGD[Resource: RGD] k8sDeployer[Deployer] end subgraph kro[kro] subgraph rgd[RGD: Bootstrap] rgdResourceHelm[Resource: HelmChart] rgdResourceImage[Resource: Image] rgdSource[FluxCD: OCI Repository] rgdHelmRelease[FluxCD: HelmRelease] end crdBootstrap[CRD: Bootstrap] subgraph instanceBootstrap[Instance: Bootstrap] subgraph ocmControllers[OCM Controllers] k8sResourceHelm[Resource: HelmChart] k8sResourceImage[Resource: Image] end subgraph fluxCD[FluxCD] source[OCI Repository] helmRelease[HelmRelease] end k8sResourceImage ---info[localization reference] --\u0026gt; helmRelease end end helmRelease --\u0026gt; deployment[Deployment: Helm chart] end ocmRepo --\u0026gt; k8sRepo --\u0026gt; k8sComponent --\u0026gt; k8sResourceRGD --\u0026gt; k8sDeployer --\u0026gt; rgd --\u0026gt; crdBootstrap --\u0026gt; instanceBootstrap k8sComponent --\u0026gt; k8sResourceHelm \u0026amp; k8sResourceImage k8sResourceHelm --\u0026gt; source --\u0026gt; helmRelease end linkStyle default fill:none,stroke:black,color:black; linkStyle 2,3,20 stroke:black,fill:none,color:black,stroke-dasharray: 10; linkStyle 4,5,21 stroke:black,fill:none,color:black,stroke-dasharray: 4; class start1,end1,start2,end2,start3,end3,start4,end4,start5,end5,start6,end6 legendStartEnd; class references,creates,instanceOf legendItems; class templateOf,rgdResourceHelm,rgdResourceImage,rgdSource,rgdHelmRelease templateOf; class info information; class reconciledBy,ocmK8sToolkit,bootstrap,fluxCD,kro reconciledBy; class k8sObject,rgd,k8sRepo,k8sComponent,k8sResourceRGD,k8sDeployer,k8sResourceHelm,k8sResourceImage,source,helmRelease,deployment,crdBootstrap,instanceBootstrap k8sObject; class ocmRepo,ocmCV,ocmResourceHelm,ocmResourceRGD,ocmResourceImage ocm; class k8sCluster cluster; class legend legendStyle; As the diagram shows, we will start by creating an OCM component that contains three resources:\nAn OCM Resource containing the \u0026ldquo;HelmChart\u0026rdquo; we want to deploy. An OCM Resource containing an access specification to an \u0026ldquo;Image\u0026rdquo; we want to use for the deployment and localization. An OCM Resource containing the ResourceGraphDefinition (RGD) that will deploy the Helm chart and configure the localization. To enable the bootstrap of the ResourceGraphDefinition, we will create the respective OCM controller resources that point to the OCM repository (\u0026ldquo;Repository\u0026rdquo;), the OCM component version (\u0026ldquo;Component\u0026rdquo;), and the OCM Resource (\u0026ldquo;Resource: RGD\u0026rdquo;) that contains the ResourceGraphDefinition. The OCM controller resource \u0026ldquo;Deployer\u0026rdquo; will refer to the aforementioned \u0026ldquo;Resource: RGD\u0026rdquo;, download the ResourceGraphDefinition, and apply it to the cluster.\nAfter applying the ResourceGraphDefinition, kro will reconcile it and create a Custom Resource Definition (\u0026ldquo;CRD: Bootstrap\u0026rdquo;). By creating an instance of that CRD, we will deploy the resources as defined in the ResourceGraphDefinition:\nAn OCM controller resource \u0026ldquo;HelmChart\u0026rdquo; of type Resource that contains the location of the Helm chart in its status. An OCM controller resource \u0026ldquo;Image\u0026rdquo; of type Resource that contains the localized image reference in its status. A FluxCD resource of type OCIRepository that points to the location of the Helm chart retrieved from the status of the resource \u0026ldquo;HelmChart\u0026rdquo;. A FluxCD resource of type HelmRelease that points to FluxCDs OCIRepository, gets the Helm chart, and replaces the image location in the deployment using its spec.values-field and the status of the resource \u0026ldquo;Image\u0026rdquo; that contains the localized image reference. Finally, we will check if the deployment was successful and if the localization was applied correctly.\nBefore starting, make sure you have set up your environment as described in the setup guide.\nCreate the OCM component version First, we will create an OCM component version containing a Helm chart, the application image that is used in the Helm chart, and the ResourceGraphDefinition that contains all required resource to deploy the Helm chart and configure the localization. For this example, we will use the podinfo Helm chart and image, which is a simple web application that serves a pod information page. For more details on how to create an OCM component version, please refer to Create Component Versions\nTo create the OCM component version, we will use the following component-constructor.yaml file:\ncomponents: - name: ocm.software/ocm-k8s-toolkit/bootstrap version: \u0026#34;1.0.0\u0026#34; provider: name: ocm.software resources: - name: helm-resource type: helmChart version: \u0026#34;1.0.0\u0026#34; access: type: ociArtifact imageReference: \u0026#34;ghcr.io/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a\u0026#34; - name: image-resource type: ociArtifact version: \u0026#34;1.0.0\u0026#34; access: type: ociRegistry imageReference: \u0026#34;ghcr.io/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb\u0026#34; - name: resource-graph-definition type: blob version: \u0026#34;1.0.0\u0026#34; input: type: file path: ./resourceGraphDefinition.yaml\rAs you can see, the resource resource-graph-definition is of type blob and contains the path to a file resourceGraphDefinition.yaml. Before we can create the OCM component version, we need to create this file, with the following content:\napiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: bootstrap spec: schema: apiVersion: v1alpha1 kind: Bootstrap resources: # In this guide, we will not create a \u0026#34;Repository\u0026#34; and \u0026#34;Component\u0026#34; resource in this ResourceGraphDefinition. Those # resources will be created to bootstrap the ResourceGraphDefinition itself and will be present in the Kubernetes # cluster to be referenced by the following resources (see the bootstrap resource in one of the following sections). # This resource refers to the resource \u0026#34;helm-resource\u0026#34; defined in the OCM component version. It will be downloaded, # verified, and its location is made available in the status of the resource. - id: resourceChart template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-helm-resource spec: # This component will be part of the bootstrap resources that will be created later. componentRef: name: bootstrap-component resource: byReference: resource: name: helm-resource interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # This resource refers to the resource \u0026#34;image-resource\u0026#34; defined in the OCM component version. It will be downloaded, # verified, and its location is made available in the status of the resource. - id: resourceImage template: apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-image-resource spec: # This component will be part of the bootstrap resources that will be created later. componentRef: name: bootstrap-component resource: byReference: resource: name: image-resource interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: # OCIRepository watches and downloads the resource from the location provided by the Resource status. # The Helm chart location (url) refers to the status of the resource helm-resource. - id: ocirepository template: apiVersion: source.toolkit.fluxcd.io/v1beta2 kind: OCIRepository metadata: name: bootstrap-ocirepository spec: interval: 1m0s insecure: true layerSelector: mediaType: \u0026#34;application/vnd.cncf.helm.chart.content.v1.tar+gzip\u0026#34; operation: copy url: oci://${resourceChart.status.reference.registry}/${resourceChart.status.reference.repository} ref: tag: ${resourceChart.status.reference.tag} # secretRef is required, if the OCI repository requires credentials to access it. # secretRef: # HelmRelease refers to the OCIRepository, lets you configure the helm chart and deploys the Helm Chart into the # Kubernetes cluster. - id: helmrelease template: apiVersion: helm.toolkit.fluxcd.io/v2 kind: HelmRelease metadata: name: bootstrap-helmrelease spec: releaseName: bootstrap-release interval: 1m timeout: 5m chartRef: kind: OCIRepository name: ${ocirepository.metadata.name} namespace: default values: # This is the second step of the localization. We use the image reference from the resource \u0026#34;image-resource\u0026#34; # and insert it into the Helm chart values. image: repository: ${resourceImage.status.reference.registry}/${resourceImage.status.reference.repository} tag: ${resourceImage.status.reference.tag}\rIf you plan to push your OCM component version to a private registry, you need to provide credentials for the OCM controllers and FluxCDs OCIRepository (if the Helm chart is also stored in a private registry). Accordingly, you have to specify the ocmConfig field in the Resource resources and the secretRef field in the OCIRepository.\nIf you want to use the same credentials for FluxCD and for the OCM controller resources, create a Kubernetes secret of type dockerconfigjson and keep all the resources in the same namespace.\nAfter creating both files, we can create the OCM component version using the following command:\nocm add componentversion --create --file ./ctf component-constructor.yaml\rThis will create a local CTF (Component Transfer Format) directory ./ctf containing the OCM component version. Since the OCM component version must be accessible for the OCM controllers, we will transfer the CTF to a registry. For this example, we will use GitHub\u0026rsquo;s container registry, but you can use any OCI registry. Additionally, we will use the flag --copy-resources to make sure that all referential resources, for instance the Helm chart, will be localized in the first step - so, the image reference is updated to the new registry location:\nocm transfer ctf --copy-resources ./ctf ghcr.io/\u0026lt;your-namespace\u0026gt;\rIf you are using a registry that requires authentication, you need to provide credentials for ocm. Please refer to the OCM CLI credentials documentation for more information on how to set up and use credentials.\nIf everything went well, you should see the following output:\nocm get componentversion ghcr.io/\u0026lt;your-namespace\u0026gt;//ocm.software/ocm-k8s-toolkit/bootstrap:1.0.0 -o yaml | yq .component.resources\r# Output is truncated for brevity - access: imageReference: ghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/charts/podinfo:6.9.1@sha256:565d310746f1fa4be7f93ba7965bb393153a2d57a15cfe5befc909b790a73f8a type: ociArtifact digest: ... name: helm-resource relation: external type: helmChart version: 1.0.0 - access: imageReference: ghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/podinfo:6.9.1@sha256:262578cde928d5c9eba3bce079976444f624c13ed0afb741d90d5423877496cb type: ociArtifact digest: ... name: image-resource relation: external type: ociArtifact version: 1.0.0 - access: localReference: sha256:ed5252ff70bfe93e763ff6afeafe8dafd14c128981e4ae1472e35afc3ebe7a63 mediaType: application/octet-stream type: localBlob digest: ... name: resource-graph-definition relation: local type: blob version: 1.0.0\rDeploy the Helm Chart To deploy the Helm chart from the OCM component, we first need to create all resources that are required to bootstrap the ResourceGraphDefinition from the OCM component. Afterwards, we will create an instance of the resulting Custom Resource Definition (CRD) which will deploy the Helm chart and configure the localization.\nBootstrapping The bootstrap process consists of creating the OCM controller resources that will download and apply the ResourceGraphDefinition. First, we will create a Repository and Component resource that point to the OCM component in the registry (the Component resource is reused in the ResourceGraphDefinition (see above) as reference for the Resource resources). Then, we create the Resource resource that references by name to the OCM resource containing the ResourceGraphDefinition. Finally, we will create a Deployer resource that will download the ResourceGraphDefinition and apply it to the cluster.\nTo proceed, create the following file named bootstrap.yaml containing the above-mentioned resources:\napiVersion: delivery.ocm.software/v1alpha1 kind: Repository metadata: name: bootstrap-repository spec: repositorySpec: # Adjust to your OCM repository baseUrl: ghcr.io/\u0026lt;your-namespace\u0026gt; type: OCIRegistry interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Component metadata: name: bootstrap-component spec: component: ocm.software/ocm-k8s-toolkit/bootstrap repositoryRef: name: bootstrap-repository semver: 1.0.0 interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Resource metadata: name: bootstrap-rgd namespace: default spec: componentRef: name: bootstrap-component resource: byReference: resource: name: resource-graph-definition interval: 1m # ocmConfig is required, if the OCM repository requires credentials to access it. # ocmConfig: --- apiVersion: delivery.ocm.software/v1alpha1 kind: Deployer metadata: name: bootstrap-deployer spec: resourceRef: # Reference to the Kubernetes resource OCM resource that contains the ResourceGraphDefinition. name: bootstrap-rgd # As kro processes resources in cluster-scope*, the deployer must also be cluster-scoped. Accordingly, we have to # set the namespace of the resource here (usually, when the namespace is not specified, it is derived from the # referencing Kubernetes resource). # Check out the kro documentation for more details: # https://github.com/kro-run/kro/blob/8f53372bfde232db7ddd6809eebb6a1d69b34f2e/website/docs/docs/concepts/20-access-control.md namespace: default # ocmConfig is required, if the OCM repository requires credentials to access it. # (You also need to specify the namespace of the reference as the \u0026#39;deployer\u0026#39; is cluster-scoped.) # ocmConfig:\rAgain, if your OCM component version is stored in a private registry, you need to provide credentials for the OCM controller resources to access the OCM repository. You can do so by specifying the ocmConfig field in the Repository, Component, Resource, and Deployer resources. For more information on how to set up credentials, please refer to the OCM controller credentials guide.\nAfterwards, apply the bootstrap.yaml to the cluster:\nkubectl apply -f bootstrap.yaml\rThis will create all the defined resources in the cluster and reconcile them. This can take a few seconds. As a result, you should see the ResourceGraphDefinition being created in the cluster:\nkubectl get rgd\rNAME APIVERSION KIND STATE AGE bootstrap v1alpha1 Bootstrap Active 2m56s By applying the ResourceGraphDefinition successfully, a Custom Resource Definition (CRD) named Bootstrap is created in the cluster. Check if the CRD is available by using the following command:\nkubectl get crd bootstraps.kro.run\rNAME CREATED AT bootstraps.kro.run 2025-05-28T11:40:38Z Troubleshooting You can check the status of the ResourceGraphDefinition by investigating the status of the resources or the logs of the ocm-k8s-toolkit-controller-manager.\nOne common issue, when using GitHub\u0026rsquo;s container registry, is that the transferred OCM component is by default a private package. If so, you might see an error like the following:\nfailed to list versions: failed to list tags: GET \u0026#34;https://ghcr.io/v2...\u0026#34;: response status code 401: unauthorized: authentication required You can resolve this issue by making the package public or by providing credentials to the respective resources.\nCreating an instance After applying the ResourceGraphDefinition and making sure that the resulting CRD is available, we can create an instance of the CRD, which will deploy the Helm chart and configure the localization. To do so, create a file containing the following content and name it instance.yaml:\napiVersion: kro.run/v1alpha1 kind: Bootstrap metadata: name: bootstrap\rThen, apply the instance to the cluster:\nkubectl apply -f instance.yaml\rIf successful, you should see the following output:\nkubectl get bootstrap\rNAME STATE SYNCED AGE bootstrap ACTIVE True 3m23s If the instance is in the ACTIVE state, the resources defined in the ResourceGraphDefinition were created and reconciled. This includes the OCM controller resources for the Helm chart and the image, as well as FluxCDs resources for the OCI repository and the Helm release. Accordingly, you should see the following deployment in the cluster. To see, if the deployment was successful, you can use the following command:\nkubectl get deployments\rNAME READY UP-TO-DATE AVAILABLE AGE bootstrap-release-podinfo 1/1 1 1 4m25s Finally, you can check the pod itself to see if the localization was applied correctly by checking the image name in the container::\nkubectl get pods -l app.kubernetes.io/name=bootstrap-release-podinfo -o jsonpath=\u0026#39;{.items[0].spec.containers[0].image}\u0026#39;\rghcr.io/\u0026lt;your-namespace\u0026gt;/stefanprodan/podinfo:6.9.1 You now have successfully created an OCM component containing a Helm chart, the respective image for localization, and a ResourceGraphDefintion to deploy your Helm chart and localize the image. By creating the required bootstrap-resources you bootstrapped the ResourceGraphDefinition from the OCM component and created the resulting CRD. Finally, you created an instance of the CRD which deployed the Helm chart and configured the localization using the OCM controllers, kro, and FluxCD.\n","date":"0001-01-01","id":23,"permalink":"/docs/tutorials/deploy-a-helm-chart-with-bootstrap/","summary":"\u003cp\u003eThe \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/concepts/ocm-controllers/#concept\"\u003econcept\u003c/a\u003e and the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/getting-started/deploy-helm-charts/\"\u003eDeploy Helm Chart\u003c/a\u003e guide showed a basic example of how to deploy a Helm chart from an OCM component.\nBy defining a \u003ccode\u003eResourceGraphDefinition\u003c/code\u003e that contains all the required resources to deploy the Helm chart into a\nKubernetes cluster.\u003c/p\u003e","tags":[],"title":"Deploy a Helm Chart (with Bootstrap)"},{"content":"Working with air-gapped environments requires careful preparation and a systematic approach to ensure all component dependencies are available offline. This section demonstrates how to prepare, transport, and deploy OCM components in secure, disconnected environments.\nInspect Component Structure Begin by examining the component descriptor and its resolved references to understand the complete dependency tree:\nocm get resources ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -r -otree COMPONENT NAME VERSION IDENTITY TYPE RELATION └─ ocm.software/toi/demo/helmdemo 0.12.0 ├─ chart 0.12.0 helmChart local ├─ config-example 0.12.0 yaml local ├─ creds-example 0.12.0 yaml local ├─ image 1.0 ociImage external ├─ package 0.12.0 toiPackage local └─ ocm.software/toi/installers/helminstaller installer 0.12.0 ├─ toiexecutor 0.12.0 toiExecutor local └─ toiimage 0.12.0 ociImage local\rCreate Offline Package Download the complete component descriptor with all referenced resources as local blobs. This creates a self-contained package that includes all dependencies:\nocm transfer component ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 -r --copy-resources ./ctf-copy-resources transferring version \u0026#34;ocm.software/toi/demo/helmdemo:0.12.0\u0026#34;... transferring version \u0026#34;ocm.software/toi/installers/helminstaller:0.12.0\u0026#34;... ...resource 0 toiimage[ociImage](ocm.software/toi/installers/helminstaller/helminstaller:0.12.0)... ...resource 1 toiexecutor[toiExecutor]... ...adding component version... ...resource 0 package[toiPackage]... ...resource 1 chart[helmChart](ocm.software/toi/demo/helmdemo/echoserver:0.1.0)... ...resource 2 image[ociImage](google-containers/echoserver:1.10)... ...resource 3 config-example[yaml]... ...resource 4 creds-example[yaml]... ...adding component version... 2 versions transferred\rVerify Package Integrity Confirm that all resources have been successfully packaged and are available as local blobs:\ndu -shA ctf-copy-resources 106M ctf-copy-resources\rocm get resources ctf-copy-resources -o treewide COMPONENT NAME VERSION IDENTITY TYPE RELATION ACCESS ├─ ocm.software/toi/demo/helmdemo 0.12.0 │ ├─ chart 0.12.0 helmChart local localBlob │ ├─ config-example 0.12.0 yaml local localBlob │ ├─ creds-example 0.12.0 yaml local localBlob │ ├─ image 1.0 ociImage external localBlob │ └─ package 0.12.0 toiPackage local localBlob └─ ocm.software/toi/installers/helminstaller 0.12.0 ├─ toiexecutor 0.12.0 toiExecutor local localBlob └─ toiimage 0.12.0 ociImage local localBlob\rTransport to Air-Gapped Environment Copy the packaged OCM artifacts to your preferred portable storage medium for secure transport:\nsudo cp -r ./ctf-copy-resources /media/....\rPhysical Transport Phase ✈️\nTransport your portable storage device containing the OCM artefact to the air-gapped environment following your organization\u0026rsquo;s security protocols.\n___ ____/ \\____ o \u0026#34;Here I come!\u0026#34; | ✈️ | /|\\_┌▓┐ |___________| / \\ | | ___| |___\rDeploy in Air-Gapped Environment Transfer the OCM artifacts from your portable storage device to the air-gapped OCI registry:\nocm transfer ctf ./media/.../ctf-copy-resources $AIR_GAPPED_OCI_REGISTRY/... Deploy in Air-Gapped Environment Transfer the OCM artifacts from your portable storage device to the air-gapped OCI registry:\nocm transfer ctf ./media/.../ctf-copy-resources $AIR_GAPPED_OCI_REGISTRY/... Run local OCI image in Air-Gapped Environment Sometimes you do not have an air-gapped OCI registry from the start and need to run a OCI image from your portable storage device.\nPrerequisite: docker cli \u0026amp; ocm cli available.\nDownload OCM resource which you want to run as local image.\n$ ocm download resource ghcr.io/open-component-model/ocm//ocm.software/toi/demo/helmdemo:0.12.0 image -O ./local-image-1-0 ./local-image-1-0: 46181313 byte(s) written\rCopy the OCI image to your preferred portable storage medium for secure transport:\nsudo cp -r ./local-image-1-0 /media/....\rImport OCI image to docker\n$ docker import ./local-image-1-0 helmdemo-image:1.0 sha256:a107d637d6b8dd1d021d49b7f315f1b77eb763aec1205ad942a99e9a1255ed22 $ docker images | grep helmdemo helmdemo-image 1.0 a107d637d6b8 44 seconds ago 46.2MB\rStart Container\ndocker run helmdemo-image:1.0 ....\r","date":"0001-01-01","id":24,"permalink":"/docs/tutorials/transport-to-air-gapped-environments/","summary":"\u003cp\u003eWorking with air-gapped environments requires careful preparation and a systematic approach to ensure all component dependencies are available offline. This section demonstrates how to prepare, transport, and deploy OCM components in secure, disconnected environments.\u003c/p\u003e","tags":[],"title":"Transport to Air-Gapped Environments"},{"content":"Usage ocm add [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for add\rSee Also Sub Commands ocm add componentversions\t— add component version(s) to a (new) transport archive ocm add references\t— add aggregation information to a component version ocm add resource-configuration\t— add a resource specification to a resource config file ocm add resources\t— add resources to a component version ocm add routingslips\t— add routing slip entry ocm add source-configuration\t— add a source specification to a source config file ocm add sources\t— add source information to a component version ","date":"0001-01-01","id":25,"permalink":"/docs/reference/ocm-cli/add/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for add\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/componentversions/\"\u003eocm add \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — add component version(s) to a (new) transport archive\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/references/\"\u003eocm add \u003cb\u003ereferences\u003c/b\u003e\u003c/a\u003e\t — add aggregation information to a component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/resource-configuration/\"\u003eocm add \u003cb\u003eresource-configuration\u003c/b\u003e\u003c/a\u003e\t — add a resource specification to a resource config file\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/resources/\"\u003eocm add \u003cb\u003eresources\u003c/b\u003e\u003c/a\u003e\t — add resources to a component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/routingslips/\"\u003eocm add \u003cb\u003eroutingslips\u003c/b\u003e\u003c/a\u003e\t — add routing slip entry\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/source-configuration/\"\u003eocm add \u003cb\u003esource-configuration\u003c/b\u003e\u003c/a\u003e\t — add a source specification to a source config file\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/sources/\"\u003eocm add \u003cb\u003esources\u003c/b\u003e\u003c/a\u003e\t — add source information to a component version\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"add"},{"content":"Usage ocm describe artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact-reference\u0026gt;}\rOptions -h, --help help for artifacts --layerfiles list layer files -o, --output string output mode (JSON, json, yaml) --repo string repository name or spec\rDescription Describe lists all artifact versions specified, if only a repository is specified all tagged artifacts are listed. Per version a detailed, potentially recursive description is printed.\nIf the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax\n\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended OCI artifact references.\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nArtifactSet: v1 CommonTransportFormat: v1 DockerDaemon: v1 Empty: v1 OCIRegistry: v1 oci: v1 ociRegistry With the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json yaml Examples $ ocm describe artifact ghcr.io/open-component-model/ocm/component-descriptors/ocm.software/ocmcli:0.17.0 $ ocm describe artifact ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image:0.17.0\rSee Also ocm describe\t— Describe various elements by using appropriate sub commands. ","date":"0001-01-01","id":26,"permalink":"/docs/reference/ocm-cli/describe/artifacts/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm describe artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help            help for artifacts\n      --layerfiles      list layer files\n  -o, --output string   output mode (JSON, json, yaml)\n      --repo string     repository name or spec\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDescribe lists all artifact versions specified, if only a repository is specified\nall tagged artifacts are listed.\nPer version a detailed, potentially recursive description is printed.\u003c/p\u003e","tags":[],"title":"artifacts"},{"content":"Usage ocm download artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact\u0026gt;} Options --dirtree extract as effective filesystem content -h, --help help for artifacts --layers ints extract dedicated layers -O, --outfile string output file or directory --repo string repository name or spec -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\rDescription Download artifacts from an OCI registry. The result is stored in artifact set format, without the repository part\nThe files are named according to the artifact repository name.\nIf the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax\n\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended OCI artifact references.\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nArtifactSet: v1 CommonTransportFormat: v1 DockerDaemon: v1 Empty: v1 OCIRegistry: v1 oci: v1 ociRegistry With option \u0026ndash;layers it is possible to request the download of dedicated layers, only. Option \u0026ndash;dirtree expects the artifact to be a layered filesystem (for example OCI Image) and provided the effective filesystem content.\nThe \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nSee Also ocm download\t— Download oci artifacts, resources or complete components ","date":"0001-01-01","id":27,"permalink":"/docs/reference/ocm-cli/download/artifacts/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download artifacts [\u0026lt;options\u0026gt;]  {\u0026lt;artifact\u0026gt;} \u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --dirtree          extract as effective filesystem content\n  -h, --help             help for artifacts\n      --layers ints      extract dedicated layers\n  -O, --outfile string   output file or directory\n      --repo string      repository name or spec\n  -t, --type string      archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDownload artifacts from an OCI registry. The result is stored in\nartifact set format, without the repository part\u003c/p\u003e","tags":[],"title":"artifacts"},{"content":"Usage ocm get artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact-reference\u0026gt;}\rOptions -a, --attached show attached artifacts -h, --help help for artifacts -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --recursive follow index nesting --repo string repository name or spec -s, --sort stringArray sort fields\rDescription Get lists all artifact versions specified, if only a repository is specified all tagged artifacts are listed.\nIf the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax\n\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended OCI artifact references.\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nArtifactSet: v1 CommonTransportFormat: v1 DockerDaemon: v1 Empty: v1 OCIRegistry: v1 oci: v1 ociRegistry With the option \u0026ndash;recursive the complete reference tree of a index is traversed.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json tree wide yaml Examples $ ocm get artifact ghcr.io/open-component-model/ocm/component-descriptors/ocm.software/ocmcli $ ocm get artifact ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image:0.17.0\rSee Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":28,"permalink":"/docs/reference/ocm-cli/get/artifacts/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -a, --attached           show attached artifacts\n  -h, --help               help for artifacts\n  -o, --output string      output mode (JSON, json, tree, wide, yaml)\n  -r, --recursive          follow index nesting\n      --repo string        repository name or spec\n  -s, --sort stringArray   sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet lists all artifact versions specified, if only a repository is specified\nall tagged artifacts are listed.\u003c/p\u003e","tags":[],"title":"artifacts"},{"content":"Usage ocm transfer artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact-reference\u0026gt;} \u0026lt;target\u0026gt;\rOptions -h, --help help for artifacts --repo string repository name or spec -R, --repo-name transfer repository name\rDescription Transfer OCI artifacts from one registry to another one. Several transfer scenarios are supported:\ncopy a set of artifacts (for the same repository) into another registry copy a set of artifacts (for the same repository) into another repository copy artifacts from multiple repositories into another registry copy artifacts from multiple repositories into another registry with a given repository prefix (option -R) By default, the target is seen as a single repository if a repository is specified. If a complete registry is specified as target, option -R is implied, but the source must provide a repository. THis combination does not allow an artifact set as source, which specifies no repository for the artifacts.\nSources may be specified as\ndedicated artifacts with repository and version or tag repository (without version), which is resolved to all available tags registry, if the specified registry implementation supports a namespace/repository lister, which is not the case for registries conforming to the OCI distribution specification. Note that there is an indirection of \u0026ldquo;ocm oci artifact\u0026rdquo; to \u0026ldquo;ocm transfer artifact\u0026rdquo; out of convenience.\nIf the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax\n\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended OCI artifact references.\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nArtifactSet: v1 CommonTransportFormat: v1 DockerDaemon: v1 Empty: v1 OCIRegistry: v1 oci: v1 ociRegistry Examples # Simple: $ ocm transfer artifact ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image:0.17.0 ghcr.io/MY_USER/ocmcli:0.17.0 $ ocm transfer artifact ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image ghcr.io/MY_USER/ocmcli $ ocm transfer artifact ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image gcr.io $ ocm transfer artifact transfer /tmp/ctf ghcr.io/MY_USER/ocmcli # Equivalent to ocm transfer artifact: $ ocm oci artifact transfer # Complex: # Transfer an artifact from a CTF into an OCI Repository: # 1. Get the link to all artifacts in the CTF with \u0026#34;ocm get artifact $PATH_TO_CTF\u0026#34;, $ ocm get artifact $PATH_TO_CTF REGISTRY REPOSITORY CommonTransportFormat::$PATH_TO_CTF/ component-descriptors/ocm.software/ocmcli # 2. Then use any combination to form an artifact reference: $ ocm transfer artifact CommonTransportFormat::$PATH_TO_CTF//component-descriptors/ocm.software/ocmcli ghcr.io/open-component-model/ocm:latest\rSee Also ocm transfer\t— Transfer artifacts or components ","date":"0001-01-01","id":29,"permalink":"/docs/reference/ocm-cli/transfer/artifacts/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm transfer artifacts [\u0026lt;options\u0026gt;] {\u0026lt;artifact-reference\u0026gt;} \u0026lt;target\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help          help for artifacts\n      --repo string   repository name or spec\n  -R, --repo-name     transfer repository name\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eTransfer OCI artifacts from one registry to another one.\nSeveral transfer scenarios are supported:\u003c/p\u003e","tags":[],"title":"artifacts"},{"content":"Description The OCM library supports a set of attributes, which can be used to influence the behaviour of various functions. The CLI also supports setting of those attributes using the config file (see ocm configfile) or by command line options of the main command (see ocm).\nThe following options are available in the currently used version of the OCM library:\ngithub.com/mandelsoft/logforward [logfwd]: logconfig Logging config structure used for config forwarding\nThis attribute is used to specify a logging configuration intended to be forwarded to other tools. (For example: TOI passes this config to the executor)\ngithub.com/mandelsoft/oci/cache [cache]: string\nFilesystem folder to use for caching OCI blobs\ngithub.com/mandelsoft/ocm/compat [compat]: bool\nCompatibility mode: Avoid generic local access methods and prefer type specific ones.\ngithub.com/mandelsoft/ocm/hasher: JSON\nPreferred hash algorithm to calculate resource digests. The following digesters are supported:\nNO-DIGEST SHA-256 (default) SHA-512 github.com/mandelsoft/ocm/keeplocalblob [keeplocalblob]: bool\nKeep local blobs when importing OCI artifacts to OCI registries from localBlob access methods. By default, they will be expanded to OCI artifacts with the access method ociRegistry. If this option is set to true, they will be stored as local blobs, also. The access method will still be localBlob but with a nested ociRegistry access method for describing the global access.\ngithub.com/mandelsoft/ocm/mapocirepo [mapocirepo]: bool|YAML\nWhen uploading an OCI artifact blob to an OCI based OCM repository and the artifact is uploaded as OCI artifact, the repository path part is shortened, either by hashing all but the last repository name part or by executing some prefix based name mappings.\nIf a boolean is given the short hash or none mode is enabled. The YAML flavor uses the following fields:\nmode string: hash, shortHash, prefixMapping or none. If unset, no mapping is done. prefixMappings: map[string]string repository path prefix mapping. prefix: string repository prefix to use (replaces potential sub path of OCM repo). or none. prefixMapping: map[string]string repository path prefix mapping. Notes:\nThe mapping only occurs in transfer commands and only when transferring to OCI registries (e.g. when transferring to a CTF archive this option will be ignored). The mapping in mode prefixMapping requires a full prefix of the composed final name. Partial matches are not supported. The host name of the target will be skipped. The artifact name of the component-descriptor is not mapped. If the mapping is provided on the command line it must be JSON format and needs to be properly escaped (see example below). Example:\nAssume a component named github.com/my_org/myexamplewithalongname and a chart name echo in the Charts.yaml of the chart archive. The following input to a resource.yaml creates a component version:\nname: mychart type: helmChart input: type: helm path: charts/mychart.tgz --- name: myimage type: ociImage version: 0.1.0 input: type: ociImage repository: ocm/ocm.software/ocmcli/ocmcli-image path: ghcr.io/acme/ocm/ocm.software/ocmcli/ocmcli-image:0.1.0 The following command:\nocm \"-X mapocirepo={\\\"mode\\\":\\\"mapping\\\",\\\"prefixMappings\\\":{\\\"acme/github.com/my_org/myexamplewithalongname/ocm/ocm.software/ocmcli\\\":\\\"acme/cli\\\", \\\"acme/github.com/my_org/myexamplewithalongnameabc123\\\":\\\"acme/mychart\\\"}}\" transfer ctf -f --copy-resources ./ctf ghcr.io/acme will result in the following artifacts in ghcr.io/my_org:\nmychart/echo cli/ocmcli-image Note that the host name part of the transfer target ghcr.io/acme is excluded from the prefix but the path acme is considered.\nThe same using a config file .ocmconfig:\ntype: generic.config.ocm.software/v1 configurations: ... - type: attributes.config.ocm.software attributes: ... mapocirepo: mode: mapping prefixMappings: acme/github.com/my\\_org/myexamplewithalongname/ocm/ocm.software/ocmcli: acme/cli acme/github.com/my\\_org/myexamplewithalongnameabc123: acme/mychart ocm transfer ca -f --copy-resources ./ca ghcr.io/acme github.com/mandelsoft/ocm/ociuploadrepo [ociuploadrepo]: oci base repository ref\nUpload local OCI artifact blobs to a dedicated repository.\ngithub.com/mandelsoft/ocm/plugindir [plugindir]: plugin directory\nDirectory to look for OCM plugin executables.\ngithub.com/mandelsoft/ocm/rootcerts [rootcerts]: JSON\nGeneral root certificate settings given as JSON document with the following format:\n{ \"rootCertificates\": [ { \"data\": \"\"\u0026lt;base64\u003e\" }, { \"path\": \"\"\u0026lt;file path\u003e\" } ] } One of following data fields are possible:\ndata: base64 encoded binary data stringdata: plain text data path: a file path to read the data from github.com/mandelsoft/ocm/signing: JSON\nPublic and private Key settings given as JSON document with the following format:\n{ \"publicKeys\": [ \"\u0026lt;provider\u003e\": { \"data\": \"\"\u0026lt;base64\u003e\" } ], \"privateKeys\"\": [ \"\u0026lt;provider\u003e\": { \"path\": \"\"\u0026lt;file path\u003e\" } ] } One of following data fields are possible:\ndata: base64 encoded binary data stringdata: plain text data path: a file path to read the data from github.com/mandelsoft/tempblobcache [blobcache]: string Foldername for temporary blob cache\nThe temporary blob cache is used to accessing large blobs from remote systems. The are temporarily stored in the filesystem, instead of the memory, to avoid blowing up the memory consumption.\nocm.software/cliconfig [cliconfig]: cliconfig Configuration Object passed to command line plugin.\nocm.software/compositionmode [compositionmode]: bool (default: false)\nComposition mode decouples a component version provided by a repository implementation from the backend persistence. Added local blobs will and other changes will not be forwarded to the backend repository until an AddVersion is called on the component. If composition mode is disabled blobs will directly be forwarded to the backend and descriptor updated will be persisted on AddVersion or closing a provided existing component version.\nocm.software/ocm/oci/preferrelativeaccess [preferrelativeaccess]: bool\nIf an artifact blob is uploaded to the technical repository used as OCM repository, the uploader should prefer to return a relative access method.\nocm.software/signing/sigstore [sigstore]: sigstore config Configuration to use for sigstore based signing.\nThe following fields are used.\nfulcioURL string default is https://fulcio.sigstore.dev rekorURL string default is https://rekor.sigstore.dev OIDCIssuer string default is https://oauth2.sigstore.dev/auth OIDCClientID string default is sigstore See Also ","date":"0001-01-01","id":30,"permalink":"/docs/reference/ocm-cli/help/attributes/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eThe OCM library supports a set of attributes, which can be used to influence\nthe behaviour of various functions. The CLI also supports setting of those\nattributes using the config file (see \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/configfile/\"\u003eocm configfile\u003c/a\u003e) or by\ncommand line options of the main command (see \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/\"\u003eocm\u003c/a\u003e).\u003c/p\u003e","tags":[],"title":"attributes"},{"content":"Usage ocm clean cache [\u0026lt;options\u0026gt;]\rOptions -b, --before string time since last usage -s, --dry-run show size to be removed -h, --help help for cache\rDescription Cleanup all blobs stored in oci blob cache (if given).\nExamples $ ocm clean cache\rSee Also ocm clean\t— Cleanup/re-organize elements ","date":"0001-01-01","id":31,"permalink":"/docs/reference/ocm-cli/clean/cache/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm clean cache [\u0026lt;options\u0026gt;]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -b, --before string   time since last usage\n  -s, --dry-run         show size to be removed\n  -h, --help            help for cache\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eCleanup all blobs stored in oci blob cache (if given).\u003c/p\u003e","tags":[],"title":"cache"},{"content":"Usage ocm describe cache [\u0026lt;options\u0026gt;]\rOptions -h, --help help for cache\rDescription Show details about the OCI blob cache (if given).\nExamples $ ocm cache info\rSee Also ocm describe\t— Describe various elements by using appropriate sub commands. ","date":"0001-01-01","id":32,"permalink":"/docs/reference/ocm-cli/describe/cache/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm describe cache [\u0026lt;options\u0026gt;]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for cache\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eShow details about the OCI blob cache (if given).\u003c/p\u003e","tags":[],"title":"cache"},{"content":"Usage ocm check [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for check\rSee Also Sub Commands ocm check componentversions\t— Check completeness of a component version in an OCM repository ","date":"0001-01-01","id":33,"permalink":"/docs/reference/ocm-cli/check/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm check [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for check\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/check/componentversions/\"\u003eocm check \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — Check completeness of a component version in an OCM repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"check"},{"content":"Usage ocm clean [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for clean\rSee Also Sub Commands ocm clean cache\t— cleanup oci blob cache ","date":"0001-01-01","id":34,"permalink":"/docs/reference/ocm-cli/clean/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm clean [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for clean\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/clean/cache/\"\u003eocm clean \u003cb\u003ecache\u003c/b\u003e\u003c/a\u003e\t — cleanup oci blob cache\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"clean"},{"content":"Usage ocm download cli [\u0026lt;options\u0026gt;] [\u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}]\rOptions -c, --constraints constraints version constraint -h, --help help for cli -O, --outfile string output file or directory -p, --path lookup executable in PATH --repo string repository name or spec --use-verified enable verification store --verified string file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;) --verify verify downloads\rDescription Download an OCM CLI executable. By default, the standard publishing component and repository is used. Optionally, another component or repo and even a resource can be specified. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.\nThe option -O is used to declare the output destination. The default location is the location of the ocm executable in the actual PATH.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry The library supports some downloads with semantics based on resource types. For example a helm chart can be download directly as helm chart archive, even if stored as OCI artifact. This is handled by download handler. Their usage can be enabled with the \u0026ndash;download-handlers option. Otherwise the resource as returned by the access method is stored.\nIf the verification store is enabled, resources downloaded from signed or verified component versions are verified against their digests provided by the component version.(not supported for using downloaders for the resource download).\nThe usage of the verification store is enabled by \u0026ndash;use-verified or by specifying a verification file with \u0026ndash;verified.\nSee Also ocm download\t— Download oci artifacts, resources or complete components ","date":"0001-01-01","id":35,"permalink":"/docs/reference/ocm-cli/download/cli/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download cli [\u0026lt;options\u0026gt;]  [\u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -c, --constraints constraints   version constraint\n  -h, --help                      help for cli\n  -O, --outfile string            output file or directory\n  -p, --path                      lookup executable in PATH\n      --repo string               repository name or spec\n      --use-verified              enable verification store\n      --verified string           file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;)\n      --verify                    verify downloads\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDownload an OCM CLI executable. By default, the standard publishing component\nand repository is used. Optionally, another component or repo and even a resource\ncan be specified. Resources are specified by identities. An identity consists of\na name argument followed by optional \u003ccode\u003e\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\u003c/code\u003e\narguments.\u003c/p\u003e","tags":[],"title":"cli"},{"content":"Usage ocm transfer commontransportarchive [\u0026lt;options\u0026gt;] \u0026lt;ctf\u0026gt; \u0026lt;target\u0026gt;\rOptions -L, --copy-local-resources transfer referenced local resources by-value -V, --copy-resources transfer referenced resources by-value --copy-sources transfer referenced sources by-value --enforce enforce transport as if target version were not present -h, --help help for commontransportarchive --lookup stringArray repository name or spec for closure lookup fallback --no-update don\u0026#39;t touch existing versions in target -N, --omit-access-types strings omit by-value transfer for resource types -f, --overwrite overwrite existing component versions -r, --recursive follow component reference nesting --script string config name of transfer handler script -s, --scriptFile string filename of transfer handler script -E, --stop-on-existing stop on existing component version in target repository -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;) --uploader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; repository uploader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default [])\rDescription Transfer content of a Common Transport Archive to the given target repository.\nWith the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nWith the option \u0026ndash;no-update existing versions in the target repository will not be touched at all. An additional specification of the option \u0026ndash;overwrite is ignored. By default, updates of volatile (non-signature-relevant) information is enabled, but the modification of non-volatile data is prohibited unless the overwrite option is given.\nIf the option \u0026ndash;overwrite is given, component versions in the target repository will be overwritten, if they already exist, but with different digest. If the option \u0026ndash;enforce is given, component versions in the target repository will be transported as if they were not present on the target side, regardless of their state (this is independent on their actual state, even identical versions are re-transported).\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nThe \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nIf the option \u0026ndash;copy-resources is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository. If the option \u0026ndash;copy-local-resources is given, instead, only resources with the relation local will be transferred. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the option \u0026ndash;copy-sources is given, all referential sources will potentially be localized, mapped to component version local resources in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the option \u0026ndash;omit-access-types is given, by-value transfer is omitted completely for the given resource types.\nIf the option \u0026ndash;stop-on-existing is given together with the \u0026ndash;recursive option, the recursion is stopped for component versions already existing in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the \u0026ndash;uploader option is specified, appropriate uploader handlers are configured for the operation. It has the following format\n\u0026lt;name\u003e:\u0026lt;artifact type\u003e:\u0026lt;media type\u003e=\u0026lt;yaml target config\u003e The uploader name may be a path expression with the following possibilities:\nocm/mavenPackage: uploading maven artifacts\nThe ocm/mavenPackage uploader is able to upload maven artifacts (whole GAV only!) as artifact archive according to the maven artifact spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the maven repository.\nocm/npmPackage: uploading npm artifacts\nThe ocm/npmPackage uploader is able to upload npm artifacts as artifact archive according to the npm package spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the npm repository.\nocm/ociArtifacts: downloading OCI artifacts\nThe ociArtifacts downloader is able to download OCI artifacts as artifact archive according to the OCI distribution spec. The following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar application/vnd.oci.image.manifest.v1+tar+gzip application/vnd.oci.image.index.v1+tar application/vnd.oci.image.index.v1+tar+gzip application/vnd.docker.distribution.manifest.v2+tar application/vnd.docker.distribution.manifest.v2+tar+gzip application/vnd.docker.distribution.manifest.list.v2+tar application/vnd.docker.distribution.manifest.list.v2+tar+gzip By default, it is registered for these mimetypes.\nIt accepts a config with the following fields:\nnamespacePrefix: a namespace prefix used for the uploaded artifacts ociRef: an OCI repository reference repository: an OCI repository specification for the target OCI registry Alternatively, a single string value can be given representing an OCI repository reference.\nplugin: [downloaders provided by plugins]\nsub namespace of the form \u0026lt;plugin name\u0026gt;/\u0026lt;handler\u0026gt;\nplugin/jfrog/JFrogHelm: upload artifacts to JFrog HELM repositories by using the JFrog REST API.\nSee ocm ocm-uploadhandlers for further details on using upload handlers.\nIt is possible to use a dedicated transfer script based on spiff. The option \u0026ndash;scriptFile can be used to specify this script by a file name. With \u0026ndash;script it can be taken from the CLI config using an entry of the following format:\ntype: scripts.ocm.config.ocm.software scripts: \u0026lt;name\u003e: path: \u0026lt;filepath\u003e script: \u0026lt;scriptdata\u003e Only one of the fields path or script can be used.\nIf no script option is given and the cli config defines a script default this one is used.\nExamples $ ocm transfer ctf ctf.tgz ghcr.io/mandelsoft/components\rSee Also ocm transfer\t— Transfer artifacts or components ","date":"0001-01-01","id":36,"permalink":"/docs/reference/ocm-cli/transfer/commontransportarchive/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm transfer commontransportarchive [\u0026lt;options\u0026gt;] \u0026lt;ctf\u0026gt; \u0026lt;target\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -L, --copy-local-resources        transfer referenced local resources by-value\n  -V, --copy-resources              transfer referenced resources by-value\n      --copy-sources                transfer referenced sources by-value\n      --enforce                     enforce transport as if target version were not present\n  -h, --help                        help for commontransportarchive\n      --lookup stringArray          repository name or spec for closure lookup fallback\n      --no-update                   don\u0026#39;t touch existing versions in target\n  -N, --omit-access-types strings   omit by-value transfer for resource types\n  -f, --overwrite                   overwrite existing component versions\n  -r, --recursive                   follow component reference nesting\n      --script string               config name of transfer handler script\n  -s, --scriptFile string           filename of transfer handler script\n  -E, --stop-on-existing            stop on existing component version in target repository\n  -t, --type string                 archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\n      --uploader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;     repository uploader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default [])\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eTransfer content of a Common Transport Archive to the given target repository.\u003c/p\u003e","tags":[],"title":"commontransportarchive"},{"content":"Usage ocm create componentarchive [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; \u0026lt;version\u0026gt; --provider \u0026lt;provider-name\u0026gt; {--provider \u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;} {\u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;}\rOptions -F, --file string target file/directory (default \u0026#34;component-archive\u0026#34;) -f, --force remove existing content -h, --help help for componentarchive -p, --provider stringArray provider attribute -S, --scheme string schema version (default \u0026#34;v2\u0026#34;) -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\rDescription Create a new component archive. This might be either a directory prepared to host component version content or a tar/tgz file (see option \u0026ndash;type).\nA provider must be specified, additional provider labels are optional.\nThe \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nIf the option \u0026ndash;scheme is given, the specified component descriptor format is used/generated.\nThe following schema versions are supported for explicit conversions:\nocm.software/v3alpha1 v2 (default) Examples $ ocm create componentarchive --file myfirst --provider acme.org --provider email=alice@acme.org acme.org/demo 1.0\rSee Also ocm create\t— Create transport or component archive ","date":"0001-01-01","id":37,"permalink":"/docs/reference/ocm-cli/create/componentarchive/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm create componentarchive [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; \u0026lt;version\u0026gt; --provider \u0026lt;provider-name\u0026gt; {--provider \u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;} {\u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -F, --file string            target file/directory (default \u0026#34;component-archive\u0026#34;)\n  -f, --force                  remove existing content\n  -h, --help                   help for componentarchive\n  -p, --provider stringArray   provider attribute\n  -S, --scheme string          schema version (default \u0026#34;v2\u0026#34;)\n  -t, --type string            archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eCreate a new component archive. This might be either a directory prepared\nto host component version content or a tar/tgz file (see option \u0026ndash;type).\u003c/p\u003e","tags":[],"title":"componentarchive"},{"content":"Usage ocm transfer componentarchive [\u0026lt;options\u0026gt;] \u0026lt;source\u0026gt; \u0026lt;target\u0026gt;\rOptions -L, --copy-local-resources transfer referenced local resources by-value -V, --copy-resources transfer referenced resources by-value --copy-sources transfer referenced sources by-value --enforce enforce transport as if target version were not present -h, --help help for componentarchive --lookup stringArray repository name or spec for closure lookup fallback --no-update don\u0026#39;t touch existing versions in target -f, --overwrite overwrite existing component versions -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\rDescription Transfer a component archive to some component repository. This might be a CTF Archive or a regular repository. If the type CTF is specified the target must already exist, if CTF flavor is specified it will be created if it does not exist.\nBesides those explicitly known types a complete repository spec might be configured, either via inline argument or command configuration file and name.\nThe \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nWith the option \u0026ndash;no-update existing versions in the target repository will not be touched at all. An additional specification of the option \u0026ndash;overwrite is ignored. By default, updates of volatile (non-signature-relevant) information is enabled, but the modification of non-volatile data is prohibited unless the overwrite option is given.\nIf the option \u0026ndash;overwrite is given, component versions in the target repository will be overwritten, if they already exist, but with different digest. If the option \u0026ndash;enforce is given, component versions in the target repository will be transported as if they were not present on the target side, regardless of their state (this is independent on their actual state, even identical versions are re-transported).\nIf the option \u0026ndash;copy-resources is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository. If the option \u0026ndash;copy-local-resources is given, instead, only resources with the relation local will be transferred. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the option \u0026ndash;copy-sources is given, all referential sources will potentially be localized, mapped to component version local resources in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.\nSee Also ocm transfer\t— Transfer artifacts or components ","date":"0001-01-01","id":38,"permalink":"/docs/reference/ocm-cli/transfer/componentarchive/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm transfer componentarchive [\u0026lt;options\u0026gt;] \u0026lt;source\u0026gt; \u0026lt;target\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -L, --copy-local-resources   transfer referenced local resources by-value\n  -V, --copy-resources         transfer referenced resources by-value\n      --copy-sources           transfer referenced sources by-value\n      --enforce                enforce transport as if target version were not present\n  -h, --help                   help for componentarchive\n      --lookup stringArray     repository name or spec for closure lookup fallback\n      --no-update              don\u0026#39;t touch existing versions in target\n  -f, --overwrite              overwrite existing component versions\n  -t, --type string            archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eTransfer a component archive to some component repository. This might\nbe a CTF Archive or a regular repository.\nIf the type CTF is specified the target must already exist, if CTF flavor\nis specified it will be created if it does not exist.\u003c/p\u003e","tags":[],"title":"componentarchive"},{"content":"Usage ocm add componentversions [\u0026lt;options\u0026gt;] [--version \u0026lt;version\u0026gt;] [\u0026lt;ctf archive\u0026gt;] {\u0026lt;component-constructor.yaml\u0026gt;}\rOptions --addenv access environment for templating -C, --complete include all referenced component version -L, --copy-local-resources transfer referenced local resources by-value -V, --copy-resources transfer referenced resources by-value -c, --create (re)create archive --dry-run evaluate and print component specifications -F, --file string target file/directory (default \u0026#34;transport-archive\u0026#34;) -f, --force remove existing content -h, --help help for componentversions --lookup stringArray repository name or spec for closure lookup fallback -O, --output string output file for dry-run -P, --preserve-signature preserve existing signatures -R, --replace replace existing elements -S, --scheme string schema version (default \u0026#34;v2\u0026#34;) -s, --settings stringArray settings file with variable settings (yaml) --skip-digest-generation skip digest creation --templater string templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;) -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;) --uploader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; repository uploader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default []) -v, --version string default version for components\rDescription Add component versions specified by a constructor file to a Common Transport Archive. The archive might be either a directory prepared to host component version content or a tar/tgz file (see option \u0026ndash;type).\nIf option \u0026ndash;create is given, the archive is created first. An additional option \u0026ndash;force will recreate an empty archive if it already exists.\nIf option \u0026ndash;complete is given all component versions referenced by the added one, will be added, also. Therefore, the \u0026ndash;lookup is required to specify an OCM repository to lookup the missing component versions. If additionally the -V is given, the resources of those additional components will be added by value.\nThe \u0026ndash;replace option allows users to specify whether adding an element with the same name and extra identity but different version as an existing element, append (false) or replace (true) the existing element.\nThe \u0026ndash;preserve-signature option prohibits changes of signature relevant elements.\nThe source, resource and reference list can be composed according to the commands ocm add sources, ocm add resources, ocm add references, respectively.\nThe description file might contain:\na single component as shown in the example a list of components under the key components a list of yaml documents with a single component or component list The optional field meta.configuredSchemaVersion for a component entry can be used to specify a dedicated serialization format to use for the component descriptor. If given it overrides the \u0026ndash;schema option of the command. By default, v2 is used.\nVarious elements support to add arbitrary information by using labels (see ocm ocm-labels).\nThe \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nIf the option \u0026ndash;copy-resources is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository. If the option \u0026ndash;copy-local-resources is given, instead, only resources with the relation local will be transferred. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the \u0026ndash;uploader option is specified, appropriate uploader handlers are configured for the operation. It has the following format\n\u0026lt;name\u003e:\u0026lt;artifact type\u003e:\u0026lt;media type\u003e=\u0026lt;yaml target config\u003e The uploader name may be a path expression with the following possibilities:\nocm/mavenPackage: uploading maven artifacts\nThe ocm/mavenPackage uploader is able to upload maven artifacts (whole GAV only!) as artifact archive according to the maven artifact spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the maven repository.\nocm/npmPackage: uploading npm artifacts\nThe ocm/npmPackage uploader is able to upload npm artifacts as artifact archive according to the npm package spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the npm repository.\nocm/ociArtifacts: downloading OCI artifacts\nThe ociArtifacts downloader is able to download OCI artifacts as artifact archive according to the OCI distribution spec. The following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar application/vnd.oci.image.manifest.v1+tar+gzip application/vnd.oci.image.index.v1+tar application/vnd.oci.image.index.v1+tar+gzip application/vnd.docker.distribution.manifest.v2+tar application/vnd.docker.distribution.manifest.v2+tar+gzip application/vnd.docker.distribution.manifest.list.v2+tar application/vnd.docker.distribution.manifest.list.v2+tar+gzip By default, it is registered for these mimetypes.\nIt accepts a config with the following fields:\nnamespacePrefix: a namespace prefix used for the uploaded artifacts ociRef: an OCI repository reference repository: an OCI repository specification for the target OCI registry Alternatively, a single string value can be given representing an OCI repository reference.\nplugin: [downloaders provided by plugins]\nsub namespace of the form \u0026lt;plugin name\u0026gt;/\u0026lt;handler\u0026gt;\nplugin/jfrog/JFrogHelm: upload artifacts to JFrog HELM repositories by using the JFrog REST API.\nSee ocm ocm-uploadhandlers for further details on using upload handlers.\nExamples $ ocm add componentversions --file ctf --version 1.0 component-constructor.yaml and a file \u0026lt;code\u0026gt;component-constructor.yaml\u0026lt;/code\u0026gt;: name: ocm.software/demo/test version: 1.0.0 provider: name: ocm.software labels: - name: city value: Karlsruhe labels: - name: purpose value: test resources: - name: text type: PlainText input: type: file path: testdata - name: data type: PlainText input: type: binary data: IXN0cmluZ2RhdGE= The resource \u0026lt;code\u0026gt;text\u0026lt;/code\u0026gt; is taken from a file \u0026lt;code\u0026gt;testdata\u0026lt;/code\u0026gt; located next to the description file.\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":39,"permalink":"/docs/reference/ocm-cli/add/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add componentversions [\u0026lt;options\u0026gt;] [--version \u0026lt;version\u0026gt;] [\u0026lt;ctf archive\u0026gt;] {\u0026lt;component-constructor.yaml\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --addenv                    access environment for templating\n  -C, --complete                  include all referenced component version\n  -L, --copy-local-resources      transfer referenced local resources by-value\n  -V, --copy-resources            transfer referenced resources by-value\n  -c, --create                    (re)create archive\n      --dry-run                   evaluate and print component specifications\n  -F, --file string               target file/directory (default \u0026#34;transport-archive\u0026#34;)\n  -f, --force                     remove existing content\n  -h, --help                      help for componentversions\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -O, --output string             output file for dry-run\n  -P, --preserve-signature        preserve existing signatures\n  -R, --replace                   replace existing elements\n  -S, --scheme string             schema version (default \u0026#34;v2\u0026#34;)\n  -s, --settings stringArray      settings file with variable settings (yaml)\n      --skip-digest-generation    skip digest creation\n      --templater string          templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;)\n  -t, --type string               archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\n      --uploader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;   repository uploader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default [])\n  -v, --version string            default version for components\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdd component versions specified by a constructor file to a Common Transport\nArchive. The archive might be either a directory prepared to host component version\ncontent or a tar/tgz file (see option \u0026ndash;type).\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm check componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\rOptions --fail-on-error fail on validation error -h, --help help for componentversions -R, --local-resources check also for describing resources with local access method, only -S, --local-sources check also for describing sources with local access method, only -o, --output string output mode (JSON, json, wide, yaml) --repo string repository name or spec -s, --sort stringArray sort fields\rDescription This command checks, whether component versions are completely contained in an OCM repository with all its dependent component references.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry If the options \u0026ndash;local-resources and/or \u0026ndash;local-sources are given the check additionally assures that all resources or sources are included into the component version. This means that they are using local access methods, only.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json wide yaml Examples $ ocm check componentversion ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.17.0 $ ocm check componentversion --repo OCIRegistry::ghcr.io/open-component-model/ocm ocm.software/ocmcli:0.17.0\rSee Also ocm check\t— check components in OCM repository ","date":"0001-01-01","id":40,"permalink":"/docs/reference/ocm-cli/check/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm check componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --fail-on-error      fail on validation error\n  -h, --help               help for componentversions\n  -R, --local-resources    check also for describing resources with local access method, only\n  -S, --local-sources      check also for describing sources with local access method, only\n  -o, --output string      output mode (JSON, json, wide, yaml)\n      --repo string        repository name or spec\n  -s, --sort stringArray   sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eThis command checks, whether component versions are completely contained\nin an OCM repository with all its dependent component references.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm download componentversions [\u0026lt;options\u0026gt;] {\u0026lt;components\u0026gt;} Options -h, --help help for componentversions -O, --outfile string output file or directory --repo string repository name or spec -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\rDescription Download component versions from an OCM repository. The result is stored in component archives.\nThe files are named according to the component version name.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry The \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nSee Also ocm download\t— Download oci artifacts, resources or complete components ","date":"0001-01-01","id":41,"permalink":"/docs/reference/ocm-cli/download/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download componentversions [\u0026lt;options\u0026gt;] {\u0026lt;components\u0026gt;} \u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help             help for componentversions\n  -O, --outfile string   output file or directory\n      --repo string      repository name or spec\n  -t, --type string      archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDownload component versions from an OCM repository. The result is stored in\ncomponent archives.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm get componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\rOptions -c, --constraints constraints version constraint -h, --help help for componentversions --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --recursive follow component reference nesting --repo string repository name or spec -S, --scheme string schema version -s, --sort stringArray sort fields\rDescription Get lists all component versions specified, if only a component is specified all versions are listed.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry With the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nIf the option \u0026ndash;scheme is given, the component descriptor is converted to the specified format for output. If no format is given the storage format of the actual descriptor is used or, for new ones v2 is used. With internal the internal representation is shown. The following schema versions are supported for explicit conversions:\nocm.software/v3alpha1 v2 With the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json tree wide yaml Examples $ ocm get componentversion ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.17.0 $ ocm get componentversion --repo OCIRegistry::ghcr.io/open-component-model/ocm ocm.software/ocmcli:0.17.0\rSee Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":42,"permalink":"/docs/reference/ocm-cli/get/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -c, --constraints constraints   version constraint\n  -h, --help                      help for componentversions\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -o, --output string             output mode (JSON, json, tree, wide, yaml)\n  -r, --recursive                 follow component reference nesting\n      --repo string               repository name or spec\n  -S, --scheme string             schema version\n  -s, --sort stringArray          sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet lists all component versions specified, if only a component is specified\nall versions are listed.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm list componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\rOptions -c, --constraints constraints version constraint -h, --help help for componentversions --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, yaml) --repo string repository name or spec -S, --scheme string schema version -s, --sort stringArray sort fields\rDescription List lists the version names of the specified objects, if only a component is specified all versions according to the given version constraints are listed.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nIf the option \u0026ndash;scheme is given, the component descriptor is converted to the specified format for output. If no format is given the storage format of the actual descriptor is used or, for new ones v2 is used. With internal the internal representation is shown. The following schema versions are supported for explicit conversions:\nocm.software/v3alpha1 v2 With the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json yaml Examples $ ocm list componentversion ghcr.io/open-component-model/ocm//ocm.software/ocmcli $ ocm list componentversion --repo OCIRegistry::ghcr.io/open-component-model/ocm ocm.software/ocmcli\rSee Also ocm list\t— List information about components ","date":"0001-01-01","id":43,"permalink":"/docs/reference/ocm-cli/list/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm list componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -c, --constraints constraints   version constraint\n  -h, --help                      help for componentversions\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -o, --output string             output mode (JSON, json, yaml)\n      --repo string               repository name or spec\n  -S, --scheme string             schema version\n  -s, --sort stringArray          sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eList lists the version names of the specified objects, if only a component is specified\nall versions according to the given version constraints are listed.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm sign componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\rOptions -- enable verification store -S, --algorithm string signature handler (default \u0026#34;RSASSA-PKCS1-V1_5\u0026#34;) --ca-cert stringArray additional root certificate authorities (for signing certificates) -c, --constraints constraints version constraint -H, --hash string hash algorithm (default \u0026#34;SHA-256\u0026#34;) -h, --help help for componentversions -I, --issuer stringArray issuer name or distinguished name (DN) (optionally for dedicated signature) ([\u0026lt;name\u0026gt;:=]\u0026lt;dn\u0026gt;) --keyless use keyless signing --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -N, --normalization string normalization algorithm (default \u0026#34;jsonNormalisation/v3\u0026#34;) -K, --private-key stringArray private key setting -k, --public-key stringArray public key setting -R, --recursive recursively sign component versions --repo string repository name or spec -s, --signature stringArray signature name --tsa use timestamp authority (default server: http://timestamp.digicert.com) --tsa-url string TSA server URL --update update digest in component versions (default true) --verified string file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;) -V, --verify verify existing digests (default true)\rDescription Sign specified component versions.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry The \u0026ndash;public-key and \u0026ndash;private-key options can be used to define public and private keys on the command line. The options have an argument of the form [\u0026lt;name\u0026gt;=]\u0026lt;filepath\u0026gt;. The optional name specifies the signature name the key should be used for. By default, this is the signature name specified with the option \u0026ndash;signature.\nAlternatively a key can be specified as base64 encoded string if the argument start with the prefix ! or as direct string with the prefix =.\nIf the verification store is enabled, resources downloaded from signed or verified component versions are verified against their digests provided by the component version.(not supported for using downloaders for the resource download).\nThe usage of the verification store is enabled by \u0026ndash; or by specifying a verification file with \u0026ndash;verified.\nIf in signing mode a public key is specified, existing signatures for the given signature name will be verified, instead of recreated.\nThe following signing types are supported with option \u0026ndash;algorithm:\nRSASSA-PKCS1-V1_5 (default) RSASSA-PSS rsa-signingservice rsapss-signingservice sigstore The following normalization modes are supported with option \u0026ndash;normalization:\njsonNormalisation/v1 jsonNormalisation/v2 jsonNormalisation/v3 (default) The following hash modes are supported with option \u0026ndash;hash:\nNO-DIGEST SHA-256 (default) SHA-512 If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nExamples $ ocm sign componentversion --signature mysignature --private-key=my.key ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.17.0\rSee Also ocm sign\t— Sign components or hashes ","date":"0001-01-01","id":44,"permalink":"/docs/reference/ocm-cli/sign/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm sign componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --                          enable verification store\n  -S, --algorithm string          signature handler (default \u0026#34;RSASSA-PKCS1-V1_5\u0026#34;)\n      --ca-cert stringArray       additional root certificate authorities (for signing certificates)\n  -c, --constraints constraints   version constraint\n  -H, --hash string               hash algorithm (default \u0026#34;SHA-256\u0026#34;)\n  -h, --help                      help for componentversions\n  -I, --issuer stringArray        issuer name or distinguished name (DN) (optionally for dedicated signature) ([\u0026lt;name\u0026gt;:=]\u0026lt;dn\u0026gt;)\n      --keyless                   use keyless signing\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -N, --normalization string      normalization algorithm (default \u0026#34;jsonNormalisation/v3\u0026#34;)\n  -K, --private-key stringArray   private key setting\n  -k, --public-key stringArray    public key setting\n  -R, --recursive                 recursively sign component versions\n      --repo string               repository name or spec\n  -s, --signature stringArray     signature name\n      --tsa                       use timestamp authority (default server: http://timestamp.digicert.com)\n      --tsa-url string            TSA server URL\n      --update                    update digest in component versions (default true)\n      --verified string           file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;)\n  -V, --verify                    verify existing digests (default true)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eSign specified component versions.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm transfer componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} \u0026lt;target\u0026gt;\rOptions -B, --bom-file string file name to write the component version BOM -c, --constraints constraints version constraint -L, --copy-local-resources transfer referenced local resources by-value -V, --copy-resources transfer referenced resources by-value --copy-sources transfer referenced sources by-value --disable-uploads disable standard upload handlers for transport --enforce enforce transport as if target version were not present -h, --help help for componentversions --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback --no-update don\u0026#39;t touch existing versions in target -N, --omit-access-types strings omit by-value transfer for resource types -f, --overwrite overwrite existing component versions -r, --recursive follow component reference nesting --repo string repository name or spec --script string config name of transfer handler script -s, --scriptFile string filename of transfer handler script -E, --stop-on-existing stop on existing component version in target repository -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;) --uploader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; repository uploader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default [])\rDescription Transfer all component versions specified to the given target repository. If only a component (instead of a component version) is specified all versions are transferred.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry The \u0026ndash;type option accepts a file format for the target archive to use. It is only evaluated if the target archive does not exist yet. The following formats are supported:\ndirectory tar tgz The default format is directory.\nWith the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nIf the option \u0026ndash;overwrite is given, component versions in the target repository will be overwritten, if they already exist, but with different digest. If the option \u0026ndash;enforce is given, component versions in the target repository will be transported as if they were not present on the target side, regardless of their state (this is independent on their actual state, even identical versions are re-transported).\nWith the option \u0026ndash;no-update existing versions in the target repository will not be touched at all. An additional specification of the option \u0026ndash;overwrite is ignored. By default, updates of volatile (non-signature-relevant) information is enabled, but the modification of non-volatile data is prohibited unless the overwrite option is given.\nIf the option \u0026ndash;copy-resources is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository. If the option \u0026ndash;copy-local-resources is given, instead, only resources with the relation local will be transferred. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the option \u0026ndash;copy-sources is given, all referential sources will potentially be localized, mapped to component version local resources in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the option \u0026ndash;omit-access-types is given, by-value transfer is omitted completely for the given resource types.\nIf the option \u0026ndash;stop-on-existing is given together with the \u0026ndash;recursive option, the recursion is stopped for component versions already existing in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.\nIf the \u0026ndash;uploader option is specified, appropriate uploader handlers are configured for the operation. It has the following format\n\u0026lt;name\u003e:\u0026lt;artifact type\u003e:\u0026lt;media type\u003e=\u0026lt;yaml target config\u003e The uploader name may be a path expression with the following possibilities:\nocm/mavenPackage: uploading maven artifacts\nThe ocm/mavenPackage uploader is able to upload maven artifacts (whole GAV only!) as artifact archive according to the maven artifact spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the maven repository.\nocm/npmPackage: uploading npm artifacts\nThe ocm/npmPackage uploader is able to upload npm artifacts as artifact archive according to the npm package spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the npm repository.\nocm/ociArtifacts: downloading OCI artifacts\nThe ociArtifacts downloader is able to download OCI artifacts as artifact archive according to the OCI distribution spec. The following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar application/vnd.oci.image.manifest.v1+tar+gzip application/vnd.oci.image.index.v1+tar application/vnd.oci.image.index.v1+tar+gzip application/vnd.docker.distribution.manifest.v2+tar application/vnd.docker.distribution.manifest.v2+tar+gzip application/vnd.docker.distribution.manifest.list.v2+tar application/vnd.docker.distribution.manifest.list.v2+tar+gzip By default, it is registered for these mimetypes.\nIt accepts a config with the following fields:\nnamespacePrefix: a namespace prefix used for the uploaded artifacts ociRef: an OCI repository reference repository: an OCI repository specification for the target OCI registry Alternatively, a single string value can be given representing an OCI repository reference.\nplugin: [downloaders provided by plugins]\nsub namespace of the form \u0026lt;plugin name\u0026gt;/\u0026lt;handler\u0026gt;\nplugin/jfrog/JFrogHelm: upload artifacts to JFrog HELM repositories by using the JFrog REST API.\nSee ocm ocm-uploadhandlers for further details on using upload handlers.\nIt is possible to use a dedicated transfer script based on spiff. The option \u0026ndash;scriptFile can be used to specify this script by a file name. With \u0026ndash;script it can be taken from the CLI config using an entry of the following format:\ntype: scripts.ocm.config.ocm.software scripts: \u0026lt;name\u003e: path: \u0026lt;filepath\u003e script: \u0026lt;scriptdata\u003e Only one of the fields path or script can be used.\nIf no script option is given and the cli config defines a script default this one is used.\nExamples $ ocm transfer components -t tgz ghcr.io/open-component-model/ocm//ocm.software/ocmcli:0.17.0 ./ctf.tgz $ ocm transfer components --latest -t tgz --repo OCIRegistry::ghcr.io/open-component-model/ocm ocm.software/ocmcli ./ctf.tgz $ ocm transfer components --latest --copy-resources --type directory ghcr.io/open-component-model/ocm//ocm.software/ocmcli ./ctf\rSee Also ocm transfer\t— Transfer artifacts or components ","date":"0001-01-01","id":45,"permalink":"/docs/reference/ocm-cli/transfer/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm transfer componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} \u0026lt;target\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -B, --bom-file string             file name to write the component version BOM\n  -c, --constraints constraints     version constraint\n  -L, --copy-local-resources        transfer referenced local resources by-value\n  -V, --copy-resources              transfer referenced resources by-value\n      --copy-sources                transfer referenced sources by-value\n      --disable-uploads             disable standard upload handlers for transport\n      --enforce                     enforce transport as if target version were not present\n  -h, --help                        help for componentversions\n      --latest                      restrict component versions to latest\n      --lookup stringArray          repository name or spec for closure lookup fallback\n      --no-update                   don\u0026#39;t touch existing versions in target\n  -N, --omit-access-types strings   omit by-value transfer for resource types\n  -f, --overwrite                   overwrite existing component versions\n  -r, --recursive                   follow component reference nesting\n      --repo string                 repository name or spec\n      --script string               config name of transfer handler script\n  -s, --scriptFile string           filename of transfer handler script\n  -E, --stop-on-existing            stop on existing component version in target repository\n  -t, --type string                 archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\n      --uploader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;     repository uploader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default [])\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eTransfer all component versions specified to the given target repository.\nIf only a component (instead of a component version) is specified all versions\nare transferred.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm verify componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\rOptions -- enable verification store --ca-cert stringArray additional root certificate authorities (for signing certificates) -c, --constraints constraints version constraint -h, --help help for componentversions -I, --issuer stringArray issuer name or distinguished name (DN) (optionally for dedicated signature) ([\u0026lt;name\u0026gt;:=]\u0026lt;dn\u0026gt;) --keyless use keyless signing --latest restrict component versions to latest -L, --local verification based on information found in component versions, only --lookup stringArray repository name or spec for closure lookup fallback -K, --private-key stringArray private key setting -k, --public-key stringArray public key setting --repo string repository name or spec -s, --signature stringArray signature name --verified string file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;) -V, --verify verify existing digests\rDescription Verify signature of specified component versions.\nIf no signature name is given, only the digests are validated against the registered ones at the component version.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry The \u0026ndash;public-key and \u0026ndash;private-key options can be used to define public and private keys on the command line. The options have an argument of the form [\u0026lt;name\u0026gt;=]\u0026lt;filepath\u0026gt;. The optional name specifies the signature name the key should be used for. By default, this is the signature name specified with the option \u0026ndash;signature.\nAlternatively a key can be specified as base64 encoded string if the argument start with the prefix ! or as direct string with the prefix =.\nIf the verification store is enabled, resources downloaded from signed or verified component versions are verified against their digests provided by the component version.(not supported for using downloaders for the resource download).\nThe usage of the verification store is enabled by \u0026ndash; or by specifying a verification file with \u0026ndash;verified.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nExamples $ ocm verify componentversion --signature mysig --public-key=pub.key ghcr.io/open-component-model/ocm//ocm.software/ocm:0.17.0\rSee Also ocm verify\t— Verify component version signatures ","date":"0001-01-01","id":46,"permalink":"/docs/reference/ocm-cli/verify/componentversions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm verify componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --                          enable verification store\n      --ca-cert stringArray       additional root certificate authorities (for signing certificates)\n  -c, --constraints constraints   version constraint\n  -h, --help                      help for componentversions\n  -I, --issuer stringArray        issuer name or distinguished name (DN) (optionally for dedicated signature) ([\u0026lt;name\u0026gt;:=]\u0026lt;dn\u0026gt;)\n      --keyless                   use keyless signing\n      --latest                    restrict component versions to latest\n  -L, --local                     verification based on information found in component versions, only\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -K, --private-key stringArray   private key setting\n  -k, --public-key stringArray    public key setting\n      --repo string               repository name or spec\n  -s, --signature stringArray     signature name\n      --verified string           file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;)\n  -V, --verify                    verify existing digests\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eVerify signature of specified component versions.\u003c/p\u003e","tags":[],"title":"componentversions"},{"content":"Usage ocm get config \u0026lt;options\u0026gt;\rOptions -h, --help help for config -O, --outfile string output file or directory -o, --output string output mode (JSON, json, yaml)\rDescription Evaluate the command line arguments and all explicitly or implicitly used configuration files and provide a single configuration object.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json yaml See Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":47,"permalink":"/docs/reference/ocm-cli/get/config/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get config \u0026lt;options\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help             help for config\n  -O, --outfile string   output file or directory\n  -o, --output string    output mode (JSON, json, yaml)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eEvaluate the command line arguments and all explicitly\nor implicitly used configuration files and provide\na single configuration object.\u003c/p\u003e","tags":[],"title":"config"},{"content":"Description The command line client supports configuring by a given configuration file. If existent, by default, the file $HOME/.ocmconfig will be read. Using the option \u0026ndash;config an alternative file can be specified.\nThe file format is yaml. It uses the same type mechanism used for all kinds of typed specification in the ocm area. The file must have the type of a configuration specification. Instead, the command line client supports a generic configuration specification able to host a list of arbitrary configuration specifications. The type for this spec is generic.config.ocm.software/v1.\nThe following configuration types are supported:\nattributes.config.ocm.software The config type attributes.config.ocm.software can be used to define a list of arbitrary attribute specifications:\ntype: attributes.config.ocm.software attributes: \u0026lt;name\u003e: \u0026lt;yaml defining the attribute\u003e ... blobLimits.ocireg.ocm.config.ocm.software The config type blobLimits.ocireg.ocm.config.ocm.software can be used to set some blob layer limits for particular OCI registries used to host OCM repositories. The blobLimits field maps a OCI registry address to the blob limit to use:\ntype: blobLimits.ocireg.ocm.config.ocm.software blobLimits: dummy.io: 65564 dummy.io:8443: 32768 // with :8443 specifying the port and 32768 specifying the byte limit If blob limits apply to a registry, local blobs with a size larger than the configured limit will be split into several layers with a maximum size of the given value.\nThese settings can be overwritten by explicit settings in an OCM repository specification for those repositories.\nThe most specific entry will be used. If a registry with a dedicated port is requested, but no explicit configuration is found, the setting for the sole hostname is used (if configured).\ncli.ocm.config.ocm.software The config type cli.ocm.config.ocm.software is used to handle the main configuration flags of the OCM command line tool.\ntype: cli.ocm.config.ocm.software aliases: \u0026lt;name\u003e: \u0026lt;OCI registry specification\u003e ... credentials.config.ocm.software The config type credentials.config.ocm.software can be used to define a list of arbitrary configuration specifications:\ntype: credentials.config.ocm.software consumers: - identity: \u0026lt;name\u003e: \u0026lt;value\u003e ... credentials: - \u0026lt;credential specification\u003e ... credential chain repositories: - repository: \u0026lt;repository specification\u003e credentials: - \u0026lt;credential specification\u003e ... credential chain aliases: \u0026lt;name\u003e: repository: \u0026lt;repository specification\u003e credentials: - \u0026lt;credential specification\u003e ... credential chain downloader.ocm.config.ocm.software The config type downloader.ocm.config.ocm.software can be used to define a list of preconfigured download handler registrations (see ocm ocm-downloadhandlers), the default priority is 200:\ntype: downloader.ocm.config.ocm.software description: \"my standard download handler configuration\" registrations: - name: oci/artifact artifactType: ociImage mimeType: ... description: ... priority: ... config: ... ... generic.config.ocm.software The config type generic.config.ocm.software can be used to define a list of arbitrary configuration specifications and named configuration sets:\ntype: generic.config.ocm.software configurations: - type: \u0026lt;any config type\u003e ... ... sets: standard: description: my selectable standard config configurations: - type: ... ... ... Configurations are directly applied. Configuration sets are just stored in the configuration context and can be applied on-demand. On the CLI, this can be done using the main command option \u0026ndash;config-set \u0026lt;name\u0026gt;.\nhasher.config.ocm.software The config type hasher.config.ocm.software can be used to define the default hash algorithm used to calculate digests for resources. It supports the field hashAlgorithm, with one of the following values:\nNO-DIGEST SHA-256 (default) SHA-512 keys.config.ocm.software The config type keys.config.ocm.software can be used to define public and private keys. A key value might be given by one of the fields:\npath: path of file with key data data: base64 encoded binary data stringdata: data a string parsed by key handler type: keys.config.ocm.software privateKeys: \u0026lt;name\u003e: path: \u0026lt;file path\u003e ... publicKeys: \u0026lt;name\u003e: data: \u0026lt;base64 encoded key representation\u003e ... rootCertificates: - path: \u0026lt;file path\u003e issuers: \u0026lt;name\u003e: commonName: acme.org Issuers define an expected distinguished name for public key certificates optionally provided together with signatures. They support the following fields:\ncommonName string organization string array organizationalUnit string array country string array locality string array province string array streetAddress string array postalCode string array At least the given values must be present in the certificate to be accepted for a successful signature validation.\nlogging.config.ocm.software The config type logging.config.ocm.software can be used to configure the logging aspect of a dedicated context type:\ntype: logging.config.ocm.software contextType: attributes.context.ocm.software settings: defaultLevel: Info rules: - ... The context type attributes.context.ocm.software is the root context of a context hierarchy.\nIf no context type is specified, the config will be applies to any target acting as logging context provider, which is not a non-root context.\nmemory.credentials.config.ocm.software The config type memory.credentials.config.ocm.software can be used to define a list of arbitrary credentials stored in a memory based credentials repository:\ntype: memory.credentials.config.ocm.software repoName: default credentials: - credentialsName: ref reference: # refer to a credential set stored in some other credential repository type: Credentials # this is a repo providing just one explicit credential set properties: username: password: - credentialsName: direct credentials: # direct credential specification username: password: merge.config.ocm.software The config type merge.config.ocm.software can be used to set some assignments for the merging of (label) values. It applies to a value merge handler registry, either directly or via an OCM context.\ntype: merge.config.ocm.software labels: - name: acme.org/audit/level merge: algorithm: acme.org/audit config: ... assignments: label:acme.org/audit/level@v1: algorithm: acme.org/audit config: ... ... oci.config.ocm.software The config type oci.config.ocm.software can be used to define OCI registry aliases:\ntype: oci.config.ocm.software aliases: \u0026lt;name\u003e: \u0026lt;OCI registry specification\u003e ... oci.uploader.config.ocm.software WARNING: This is an experimental feature. Will be replaced with native local blob support in OCM in the future.\nThe config type oci.uploader.config.ocm.software can be used to set some configurations for the implicit OCI artifact upload for OCI based OCM repositories.\ntype: oci.uploader.config.ocm.software preferRelativeAccess: true # use relative access methods for given target repositories. repositories: - localhost:5000 If preferRelativeAccess is set to true the OCI uploader for OCI based OCM repositories does not use the OCI repository to create absolute OCI access methods if the target repository is in the repositories list. Instead, a relative relativeOciReference access method is created. If this list is empty, all uploads are handled this way.\nIf the global attribute preferrelativeaccess is configured, it overrides the preferRelativeAccess setting.\nocm.cmd.config.ocm.software The config type ocm.cmd.config.ocm.software can be used to configure predefined aliases for dedicated OCM repositories and OCI registries.\ntype: ocm.cmd.config.ocm.software ocmRepositories: \u0026lt;name\u003e: \u0026lt;specification of OCM repository\u003e ... ociRepositories: \u0026lt;name\u003e: \u0026lt;specification of OCI registry\u003e ... ocm.config.ocm.software The config type ocm.config.ocm.software can be used to set some configurations for an OCM context;\ntype: ocm.config.ocm.software aliases: myrepo: type: \u0026lt;any repository type\u003e \u0026lt;specification attributes\u003e ... resolvers: - repository: type: \u0026lt;any repository type\u003e \u0026lt;specification attributes\u003e ... prefix: ghcr.io/open-component-model/ocm priority: 10 With aliases repository alias names can be mapped to a repository specification. The alias name can be used in a string notation for an OCM repository.\nResolvers define a list of OCM repository specifications to be used to resolve dedicated component versions. These settings are used to compose a standard component version resolver provided for an OCM context. Optionally, a component name prefix can be given. It limits the usage of the repository to resolve only components with the given name prefix (always complete name segments). An optional priority can be used to influence the lookup order. Larger value means higher priority (default 10).\nAll matching entries are tried to lookup a component version in the following order:\nhighest priority first longest matching sequence of component name segments first. If resolvers are defined, it is possible to use component version names on the command line without a repository. The names are resolved with the specified resolution rule. They are also used as default lookup repositories to lookup component references for recursive operations on component versions (\u0026ndash;lookup option).\nplugin.config.ocm.software The config type plugin.config.ocm.software can be used to configure a plugin.\ntype: plugin.config.ocm.software plugin: \u0026lt;plugin name\u003e config: \u0026lt;arbitrary configuration structure\u003e disableAutoRegistration: \u0026lt;boolean flag to disable auto registration for up- and download handlers\u003e rootcerts.config.ocm.software The config type rootcerts.config.ocm.software can be used to define general root certificates. A certificate value might be given by one of the fields:\npath: path of file with key data data: base64 encoded binary data stringdata: data a string parsed by key handler rootCertificates: - path: \u0026lt;file path\u003e scripts.ocm.config.ocm.software The config type scripts.ocm.config.ocm.software can be used to define transfer scripts:\ntype: scripts.ocm.config.ocm.software scripts: \u0026lt;name\u003e: path: \u0026lt;\u003efile path\u003e \u0026lt;other name\u003e: script: \u0026lt;\u003enested script as yaml\u003e transport.ocm.config.ocm.software The config type transport.ocm.config.ocm.software can be used to define transfer scripts:\ntype: transport.ocm.config.ocm.software recursive: true overwrite: true localResourcesByValue: false resourcesByValue: true sourcesByValue: false keepGlobalAccess: false stopOnExistingVersion: false omitAccessTypes: - s3 uploader.ocm.config.ocm.software The config type uploader.ocm.config.ocm.software can be used to define a list of preconfigured upload handler registrations (see ocm ocm-uploadhandlers), the default priority is 200:\ntype: uploader.ocm.config.ocm.software description: \"my standard upload handler configuration\" registrations: - name: oci/artifact artifactType: ociImage config: ociRef: ghcr.io/open-component-model/... ... Examples type: generic.config.ocm.software/v1 configurations: - type: credentials.config.ocm.software repositories: - repository: type: DockerConfig/v1 dockerConfigFile: \u0026#34;~/.docker/config.json\u0026#34; propagateConsumerIdentity: true - type: attributes.config.ocm.software attributes: # map of attribute settings compat: true # - type: scripts.ocm.config.ocm.software # scripts: # \u0026#34;default\u0026#34;: # script: # process: true\rSee Also ","date":"0001-01-01","id":48,"permalink":"/docs/reference/ocm-cli/help/configfile/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eThe command line client supports configuring by a given configuration file.\nIf existent, by default, the file \u003ccode\u003e$HOME/.ocmconfig\u003c/code\u003e will be read.\nUsing the option \u003ccode\u003e\u0026ndash;config\u003c/code\u003e an alternative file can be specified.\u003c/p\u003e","tags":[],"title":"configfile"},{"content":"Usage ocm create [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for create\rSee Also Sub Commands ocm create componentarchive\t— (DEPRECATED) create new component archive ocm create rsakeypair\t— create RSA public key pair ocm create transportarchive\t— create new OCI/OCM transport archive ","date":"0001-01-01","id":49,"permalink":"/docs/reference/ocm-cli/create/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm create [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for create\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/create/componentarchive/\"\u003eocm create \u003cb\u003ecomponentarchive\u003c/b\u003e\u003c/a\u003e\t — (DEPRECATED) create new component archive\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/create/rsakeypair/\"\u003eocm create \u003cb\u003ersakeypair\u003c/b\u003e\u003c/a\u003e\t — create RSA public key pair\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/create/transportarchive/\"\u003eocm create \u003cb\u003etransportarchive\u003c/b\u003e\u003c/a\u003e\t — create new OCI/OCM transport  archive\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"create"},{"content":"Description In contrast to libraries intended for a dedicated technical environment, for example the handling of OCI images in OCI registries, the OCM ecosystem cannot provide a specialized credential management for a dedicated environment.\nBecause of its extensibility working with component versions could require access to any kind of technical system, either for storing the model elements in a storage backend, or for accessing content in any kind of technical storage system. There are several kinds of credential consumers with potentially completely different kinds of credentials. Therefore, a common uniform credential management is required, capable to serve all those use cases.\nThis credential management brings together various kinds of credential consumers, for example the access to artifacts in OCI registries or accessing Git repository content, and credential providers, like vaults or local files in the filesystem (for example a technology specific credential source like the docker config json file for accessing OCI registries).\nThe used credential management model is based on four elements:\nCredentials:\nCredentials are described property set (key/value pairs).\nConsumer Ids\nBecause of the extensible nature of the OCM model, credential consumers must be formally identified. A consumer id described a concrete access, which must be authorized.\nThis is again achieved by a set of simple named attributes. There is only one defined property, which must always be present, the type attribute. It denotes the type of the technical environment credentials are required for. For example, for accessing OCI or Git registries. Additionally, there may be any number of arbitrary attributes used to describe the concrete instance of such an environment and access paths in this environment, which should be accessed (for example the OCI registry URL to describe the instance and the repository path for the set of objects, which should be accessed)\nThere are two use cases for consumer ids:\nCredential Request. They are used by a credential consumer to issue a credential request to the credential management. Hereby, they describe the concrete element, which should accessed. Credential Assignment. The credential management allows to assign credentials to consumer ids Credential Providers or repositories\nCredential repositories are dedicated kinds of implementations, which provide access to names sets of credentials stored in any kind of technical environment, for example a vault or a credentials somewhere on the local filesystem.\nIdentity Matchers\nThe credential management must resolve credential requests against a set of credential assignments. This is not necessarily a complete attribute match for the involved consumer ids. There is typically some kind of matching involved. For example, an assignment is done for an OCI registry with a dedicated server url and prefix for the repository path (type is OCIRegistry, host is ghcr.io, prefix path is open-component-model). The assigned credentials should be applicable for sub repositories. So the assignment uses a more general consumer id than the concrete credential request (for example for repository path open-component-model/ocm/ocmcli)\nThis kind of matching depend on the used attribute and is therefore in general type specific. Therefore, every consumer type uses an own identity matcher, which is then used by the credential management to find the best matching assignment.\nThe general process for a credential management then looks as follows.\ncredentials provided by credential repositories are assigned to generalized consumer ids. a concrete access operation for a technical environment calculates a detailed consumer id for the element, which should be accessed it asks the credential management for credentials for this id the management examines all defined assignments to find the best matching one based on the provided matching mechanism. it then returns the mapped credentials from the references repository. The critical task for a user of the toolset is to define those assignments. This is basically a manual task, because the credentials stored in vault (for example) could be usable for any kind of system, which typically cannot be derived from the credential values.\nBut luckily, those could partly be automated:\nthere may be credential providers, which are technology specific, for example the docker config json is used to describe credentials for OCI registries. Such providers can automatically assign the found credentials to appropriate consumer ids. If the credential store has the possibility to store custom meta data for a credential set, this metadata can be used to describe the intended consumer ids. The provider implementation then uses this info create the appropriate assignments. Consumer Types and Matchers The following credential consumer types are used/supported:\nBuildcredentials.ocm.software: Gardener config credential matcher\nIt matches the Buildcredentials.ocm.software consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type Buildcredentials.ocm.software evaluate the following credential properties:\nkey: secret key use to access the credential server Git: Git credential matcher\nIt matches the Git consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type Git evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password token: HTTP token authentication privateKey: Private Key authentication certificate Github: GitHub credential matcher\nThis matcher is a hostpath matcher.\nCredential consumers of the consumer type Github evaluate the following credential properties:\ntoken: GitHub personal access token HashiCorpVault: HashiCorp Vault credential matcher\nThis matcher matches credentials for a HashiCorp vault instance. It uses the following identity attributes:\nhostname: vault server host scheme: (optional) URL scheme port: (optional) server port namespace: vault namespace mountPath: mount path pathprefix: path prefix for secret Credential consumers of the consumer type HashiCorpVault evaluate the following credential properties:\nauthmeth: auth method token: vault token roleid: app-role role id secretid: app-role secret id The only supported auth methods, so far, are token and approle.\nHelmChartRepository: Helm chart repository\nIt matches the HelmChartRepository consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type HelmChartRepository evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password certificate: TLS client certificate privateKey: TLS private key certificateAuthority: TLS certificate authority MavenRepository: MVN repository\nIt matches the MavenRepository consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type MavenRepository evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password NpmRegistry: NPM registry\nIt matches the NpmRegistry consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type NpmRegistry evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password email: NPM registry, require an email address token: the token attribute. May exist after login at any npm registry. Check your .npmrc file! OCIRegistry: OCI registry credential matcher\nIt matches the OCIRegistry consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type OCIRegistry evaluate the following credential properties:\nusername: the basic auth username password: the basic auth password identityToken: the bearer token used for non-basic auth authorization certificateAuthority: the certificate authority certificate used to verify certificates S3: S3 credential matcher\nThis matcher is a hostpath matcher.\nCredential consumers of the consumer type S3 evaluate the following credential properties:\nawsAccessKeyID: AWS access key id awsSecretAccessKey: AWS secret for access key id token: AWS access token (alternatively) Signingserver.gardener.cloud: signing service credential matcher\nThis matcher matches credentials for a Signing Service instance. It uses the following identity attributes:\nhostname: signing server host scheme: (optional) URL scheme port: (optional) server port pathprefix: path prefix for the server URL Credential consumers of the consumer type Signingserver.gardener.cloud evaluate the following credential properties:\nclientCert: client certificate for authentication privateKey: private key for client certificate caCerts: root certificate for signing server wget: wget credential matcher\nIt matches the wget consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type wget evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password identityToken: the bearer token used for non-basic auth authorization certificateAuthority: the certificate authority certificate used to verify certificates presented by the server certificate: the certificate used to present to the server privateKey: the private key corresponding to the certificate Those consumer types provide their own matchers, which are often based on some standard generic matches. Those generic matchers and their behaviors are described in the following list:\nexact: exact match of given pattern set\nhostpath: Host and path based credential matcher\nThis matcher works on the following properties:\ntype (required if set in pattern): the identity type hostname (required if set in pattern): the hostname of a server scheme (optional): the URL scheme of a server port (optional): the port of a server pathprefix (optional): a path prefix to match. The element with the most matching path components is selected (separator is /). partial: complete match of given pattern ignoring additional attributes\nCredential Providers Credential providers offer sets of named credentials from various sources, which might be directly mapped to consumer identities (if supported by the provider type).\nThe type Credentials can be used to inline credentials in credential configuration objects to configure mappings of consumer identities to a credential set (see ocm configfile).\nThe following types are currently available:\nCredential provider Credentials\nThis repository type can be used to specify a single inline credential set. The default name is the empty string or Credentials.\nThe following versions are supported:\nVersion v1\nThe repository specification supports the following fields:\nproperties: map[string]string: direct credential fields Credential provider DockerConfig\nThis repository type can be used to access credentials stored in a file following the docker config json format. It take into account the credentials helper section, also. If enabled, the described credentials will be automatically assigned to appropriate consumer ids.\nThe following versions are supported:\nVersion v1\nThe repository specification supports the following fields:\ndockerConfigFile: string: the file path to a docker config file dockerConfig: json: an embedded docker config json propagateConsumerIdentity: bool(optional): enable consumer id propagation Credential provider HashiCorpVault\nThis repository type can be used to access credentials stored in a HashiCorp Vault.\nIt provides access to list of secrets stored under a dedicated path in a vault namespace. This list can either explicitly be specified, or it is taken from the metadata of a specified secret.\nThe following custom metadata attributes are evaluated:\nsecrets this attribute may contain a comma separated list of vault secrets, which should be exposed by this repository instance. The names are evaluated under the path prefix used for the repository. consumerId this attribute may contain a JSON encoded consumer id , this secret should be assigned to. type if no special attribute is defined this attribute indicated to use the complete custom metadata as consumer id. It uses the HashiCorpVault identity matcher and consumer type to requests credentials for the access.\nThis matcher matches credentials for a HashiCorp vault instance. It uses the following identity attributes:\nhostname: vault server host scheme: (optional) URL scheme port: (optional) server port namespace: vault namespace mountPath: mount path pathprefix: path prefix for secret It requires the following credential attributes:\nauthmeth: auth method token: vault token roleid: app-role role id secretid: app-role secret id The only supported auth methods, so far, are token and approle.\nThe following versions are supported:\nVersion v1\nThe repository specification supports the following fields:\nserverURL: string (required): the URL of the vault instance namespace: string (optional): the namespace used to evaluate secrets mountPath: string (optional): the mount path to use (default: secrets) path: string (optional): the path prefix used to lookup secrets secrets: []string (optional): list of secrets propagateConsumerIdentity: bool(optional): evaluate metadata for consumer id propagation If the secrets list is empty, all secret entries found in the given path is read.\nCredential provider NPMConfig\nThis repository type can be used to access credentials stored in a file following the NPM npmrc format (~/.npmrc). It take into account the credentials helper section, also. If enabled, the described credentials will be automatically assigned to appropriate consumer ids.\nThe following versions are supported:\nVersion v1\nThe repository specification supports the following fields:\nnpmrcFile: string: the file path to a NPM npmrc file propagateConsumerIdentity: bool(optional): enable consumer id propagation See Also ","date":"0001-01-01","id":50,"permalink":"/docs/reference/ocm-cli/help/credential-handling/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eIn contrast to libraries intended for a dedicated technical environment,\nfor example the handling of OCI images in OCI registries, the OCM\necosystem cannot provide a specialized credential management for a dedicated\nenvironment.\u003c/p\u003e","tags":[],"title":"credential-handling"},{"content":"Usage ocm get credentials {\u0026lt;consumer property\u0026gt;=\u0026lt;value\u0026gt;}\rOptions -h, --help help for credentials -m, --matcher string matcher type override -s, --sloppy sloppy matching of consumer type\rDescription Try to resolve a given consumer specification against the configured credential settings and show the found credential attributes.\nMatchers exist for the following usage contexts or consumer types:\nBuildcredentials.ocm.software: Gardener config credential matcher\nIt matches the Buildcredentials.ocm.software consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type Buildcredentials.ocm.software evaluate the following credential properties:\nkey: secret key use to access the credential server Git: Git credential matcher\nIt matches the Git consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type Git evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password token: HTTP token authentication privateKey: Private Key authentication certificate Github: GitHub credential matcher\nThis matcher is a hostpath matcher.\nCredential consumers of the consumer type Github evaluate the following credential properties:\ntoken: GitHub personal access token HashiCorpVault: HashiCorp Vault credential matcher\nThis matcher matches credentials for a HashiCorp vault instance. It uses the following identity attributes:\nhostname: vault server host scheme: (optional) URL scheme port: (optional) server port namespace: vault namespace mountPath: mount path pathprefix: path prefix for secret Credential consumers of the consumer type HashiCorpVault evaluate the following credential properties:\nauthmeth: auth method token: vault token roleid: app-role role id secretid: app-role secret id The only supported auth methods, so far, are token and approle.\nHelmChartRepository: Helm chart repository\nIt matches the HelmChartRepository consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type HelmChartRepository evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password certificate: TLS client certificate privateKey: TLS private key certificateAuthority: TLS certificate authority MavenRepository: MVN repository\nIt matches the MavenRepository consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type MavenRepository evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password NpmRegistry: NPM registry\nIt matches the NpmRegistry consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type NpmRegistry evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password email: NPM registry, require an email address token: the token attribute. May exist after login at any npm registry. Check your .npmrc file! OCIRegistry: OCI registry credential matcher\nIt matches the OCIRegistry consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type OCIRegistry evaluate the following credential properties:\nusername: the basic auth username password: the basic auth password identityToken: the bearer token used for non-basic auth authorization certificateAuthority: the certificate authority certificate used to verify certificates S3: S3 credential matcher\nThis matcher is a hostpath matcher.\nCredential consumers of the consumer type S3 evaluate the following credential properties:\nawsAccessKeyID: AWS access key id awsSecretAccessKey: AWS secret for access key id token: AWS access token (alternatively) Signingserver.gardener.cloud: signing service credential matcher\nThis matcher matches credentials for a Signing Service instance. It uses the following identity attributes:\nhostname: signing server host scheme: (optional) URL scheme port: (optional) server port pathprefix: path prefix for the server URL Credential consumers of the consumer type Signingserver.gardener.cloud evaluate the following credential properties:\nclientCert: client certificate for authentication privateKey: private key for client certificate caCerts: root certificate for signing server wget: wget credential matcher\nIt matches the wget consumer type and additionally acts like the hostpath type.\nCredential consumers of the consumer type wget evaluate the following credential properties:\nusername: the basic auth user name password: the basic auth password identityToken: the bearer token used for non-basic auth authorization certificateAuthority: the certificate authority certificate used to verify certificates presented by the server certificate: the certificate used to present to the server privateKey: the private key corresponding to the certificate The following standard identity matchers are supported:\nexact: exact match of given pattern set\nhostpath: Host and path based credential matcher\nThis matcher works on the following properties:\ntype (required if set in pattern): the identity type hostname (required if set in pattern): the hostname of a server scheme (optional): the URL scheme of a server port (optional): the port of a server pathprefix (optional): a path prefix to match. The element with the most matching path components is selected (separator is /). partial (default): complete match of given pattern ignoring additional attributes\nThe used matcher is derived from the consumer attribute type. For all other consumer types a matcher matching all attributes will be used. The usage of a dedicated matcher can be enforced by the option \u0026ndash;matcher.\nSee Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":51,"permalink":"/docs/reference/ocm-cli/get/credentials/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get credentials {\u0026lt;consumer property\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help             help for credentials\n  -m, --matcher string   matcher type override\n  -s, --sloppy           sloppy matching of consumer type\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eTry to resolve a given consumer specification against the configured credential\nsettings and show the found credential attributes.\u003c/p\u003e","tags":[],"title":"credentials"},{"content":"Usage ocm describe [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for describe\rSee Also Sub Commands ocm describe artifacts\t— describe artifact version ocm describe cache\t— show OCI blob cache information ocm describe package\t— describe TOI package ocm describe plugins\t— get plugins ","date":"0001-01-01","id":52,"permalink":"/docs/reference/ocm-cli/describe/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm describe [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for describe\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/describe/artifacts/\"\u003eocm describe \u003cb\u003eartifacts\u003c/b\u003e\u003c/a\u003e\t — describe artifact version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/describe/cache/\"\u003eocm describe \u003cb\u003ecache\u003c/b\u003e\u003c/a\u003e\t — show OCI blob cache information\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/describe/package/\"\u003eocm describe \u003cb\u003epackage\u003c/b\u003e\u003c/a\u003e\t — describe TOI package\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/describe/plugins/\"\u003eocm describe \u003cb\u003eplugins\u003c/b\u003e\u003c/a\u003e\t — get plugins\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"describe"},{"content":"Usage ocm download [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for download\rSee Also Sub Commands ocm download artifacts\t— download oci artifacts ocm download cli\t— download OCM CLI from an OCM repository ocm download componentversions\t— download ocm component versions ocm download resources\t— download resources of a component version ","date":"0001-01-01","id":53,"permalink":"/docs/reference/ocm-cli/download/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for download\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/download/artifacts/\"\u003eocm download \u003cb\u003eartifacts\u003c/b\u003e\u003c/a\u003e\t — download oci artifacts\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/download/cli/\"\u003eocm download \u003cb\u003ecli\u003c/b\u003e\u003c/a\u003e\t — download OCM CLI from an OCM repository\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/download/componentversions/\"\u003eocm download \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — download ocm component versions\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/download/resources/\"\u003eocm download \u003cb\u003eresources\u003c/b\u003e\u003c/a\u003e\t — download resources of a component version\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"download"},{"content":"Usage ocm get [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for get\rSee Also Sub Commands ocm get artifacts\t— get artifact version ocm get componentversions\t— get component version ocm get config\t— Get evaluated config for actual command call ocm get credentials\t— Get credentials for a dedicated consumer spec ocm get plugins\t— get plugins ocm get pubsub\t— Get the pubsub spec for an ocm repository ocm get references\t— get references of a component version ocm get resources\t— get resources of a component version ocm get routingslips\t— get routings slips for a component version ocm get sources\t— get sources of a component version ocm get verified\t— get verified component versions ","date":"0001-01-01","id":54,"permalink":"/docs/reference/ocm-cli/get/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for get\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/artifacts/\"\u003eocm get \u003cb\u003eartifacts\u003c/b\u003e\u003c/a\u003e\t — get artifact version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/componentversions/\"\u003eocm get \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — get component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/config/\"\u003eocm get \u003cb\u003econfig\u003c/b\u003e\u003c/a\u003e\t — Get evaluated config for actual command call\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/credentials/\"\u003eocm get \u003cb\u003ecredentials\u003c/b\u003e\u003c/a\u003e\t — Get credentials for a dedicated consumer spec\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/plugins/\"\u003eocm get \u003cb\u003eplugins\u003c/b\u003e\u003c/a\u003e\t — get plugins\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/pubsub/\"\u003eocm get \u003cb\u003epubsub\u003c/b\u003e\u003c/a\u003e\t — Get the pubsub spec for an ocm repository\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/references/\"\u003eocm get \u003cb\u003ereferences\u003c/b\u003e\u003c/a\u003e\t — get references of a component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/resources/\"\u003eocm get \u003cb\u003eresources\u003c/b\u003e\u003c/a\u003e\t — get resources of a component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/routingslips/\"\u003eocm get \u003cb\u003eroutingslips\u003c/b\u003e\u003c/a\u003e\t — get routings slips for a component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/sources/\"\u003eocm get \u003cb\u003esources\u003c/b\u003e\u003c/a\u003e\t — get sources of a component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/verified/\"\u003eocm get \u003cb\u003everified\u003c/b\u003e\u003c/a\u003e\t — get verified component versions\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"get"},{"content":"Usage ocm sign hash \u0026lt;private key file\u0026gt; \u0026lt;hash\u0026gt; [\u0026lt;issuer\u0026gt;]\rOptions -S, --algorithm string signature algorithm (default \u0026#34;RSASSA-PKCS1-V1_5\u0026#34;) --ca-cert stringArray additional root certificate authorities (for signing certificates) -h, --help help for hash --publicKey string public key certificate file --rootCerts string root certificates file (deprecated)\rDescription Print the signature for a dedicated digest value.\nExamples $ ocm sign hash key.priv SHA-256:810ff2fb242a5dee4220f2cb0e6a519891fb67f2f828a6cab4ef8894633b1f50\rSee Also ocm sign\t— Sign components or hashes ","date":"0001-01-01","id":55,"permalink":"/docs/reference/ocm-cli/sign/hash/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm sign hash \u0026lt;private key file\u0026gt; \u0026lt;hash\u0026gt; [\u0026lt;issuer\u0026gt;]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -S, --algorithm string      signature algorithm (default \u0026#34;RSASSA-PKCS1-V1_5\u0026#34;)\n      --ca-cert stringArray   additional root certificate authorities (for signing certificates)\n  -h, --help                  help for hash\n      --publicKey string      public key certificate file\n      --rootCerts string      root certificates file (deprecated)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003ePrint the signature for a dedicated digest value.\u003c/p\u003e","tags":[],"title":"hash"},{"content":"Additional Topics attributes — attributes configfile — configfile credential-handling — credential-handling logging — logging oci-references — oci-references ocm-accessmethods — ocm-accessmethods ocm-downloadhandlers — ocm-downloadhandlers ocm-labels — ocm-labels ocm-pubsub — ocm-pubsub ocm-references — ocm-references ocm-uploadhandlers — ocm-uploadhandlers toi-bootstrapping — toi-bootstrapping ","date":"0001-01-01","id":56,"permalink":"/docs/reference/ocm-cli/help/","summary":"\u003ch3 id=\"additional-topics\"\u003eAdditional Topics\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/attributes/\"\u003eattributes\u003c/a\u003e — attributes\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/configfile/\"\u003econfigfile\u003c/a\u003e — configfile\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/credential-handling/\"\u003ecredential-handling\u003c/a\u003e — credential-handling\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/logging/\"\u003elogging\u003c/a\u003e — logging\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/oci-references/\"\u003eoci-references\u003c/a\u003e — oci-references\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-accessmethods/\"\u003eocm-accessmethods\u003c/a\u003e — ocm-accessmethods\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-downloadhandlers/\"\u003eocm-downloadhandlers\u003c/a\u003e — ocm-downloadhandlers\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-labels/\"\u003eocm-labels\u003c/a\u003e — ocm-labels\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-pubsub/\"\u003eocm-pubsub\u003c/a\u003e — ocm-pubsub\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-references/\"\u003eocm-references\u003c/a\u003e — ocm-references\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-uploadhandlers/\"\u003eocm-uploadhandlers\u003c/a\u003e — ocm-uploadhandlers\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/toi-bootstrapping/\"\u003etoi-bootstrapping\u003c/a\u003e — toi-bootstrapping\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"help"},{"content":"Usage ocm list [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for list\rSee Also Sub Commands ocm list componentversions\t— list component version names ","date":"0001-01-01","id":57,"permalink":"/docs/reference/ocm-cli/list/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm list [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for list\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/list/componentversions/\"\u003eocm list \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — list component version names\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"list"},{"content":"Description Logging can be configured as part of the ocm config file ( ocm configfile) or by command line options of the ocm command. Details about the YAML structure of a logging settings can be found on https://github.com/mandelsoft/logging.\nThe command line also supports some quick-config options for enabling log levels for dedicated tags and realms or realm prefixes (logging keys).\nThe following tags are used by the command line tool:\nblobhandler: execution of blob handler used to upload resource blobs to an ocm repository. cd-diff: component descriptor modification The following realms are used by the command line tool:\nocm: general realm used for the ocm go library. ocm/accessmethod/ociartifact: access method ociArtifact ocm/accessmethod/wget: access method for wget ocm/blobaccess/wget: blob access for wget ocm/compdesc: component descriptor handling ocm/compdesc/normalizations/legacy: component descriptor legacy normalization defaulting ocm/config: configuration management ocm/context: context lifecycle ocm/credentials: Credentials ocm/credentials/dockerconfig: docker config handling as credential repository ocm/credentials/vault: HashiCorp Vault Access ocm/downloader: Downloaders ocm/git: git repository ocm/maven: Maven repository ocm/npm: NPM registry ocm/oci/docker: Docker repository handling ocm/oci/mapping: OCM to OCI Registry Mapping ocm/oci/ocireg: OCI repository handling ocm/plugins: OCM plugin handling ocm/processing: output processing chains ocm/refcnt: reference counting ocm/toi: TOI logging ocm/transfer: OCM transfer handling ocm/valuemerge: value merge handling Examples type: logging.config.ocm.software contextType: attributes.context.ocm.software settings: defaultLevel: Info rules: - ...\rSee Also ","date":"0001-01-01","id":58,"permalink":"/docs/reference/ocm-cli/help/logging/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eLogging can be configured as part of the ocm config file (\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/configfile/\"\u003eocm configfile\u003c/a\u003e)\nor by command line options of the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/\"\u003eocm\u003c/a\u003e command. Details about\nthe YAML structure of a logging settings can be found on https://github.com/mandelsoft/logging.\u003c/p\u003e","tags":[],"title":"logging"},{"content":"Description The command line client supports a special notation scheme for specifying references to instances of oci like registries. This allows for specifying references to any registry supported by the OCM toolset that can host OCI artifacts. As a subset the regular OCI artifact notation used for docker images are possible:\n[+][\u0026lt;type\u003e::][./][\u0026lt;file path\u003e//\u0026lt;repository\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] or\n[+][\u0026lt;type\u003e::][\u0026lt;json repo spec\u003e//]\u0026lt;repository\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] Notice that if you specify the \u0026lt;type\u0026gt; in the beginning of this notation AND in the \u0026lt;json repo spec\u0026gt;, the types have to match (but there is no reason to specify the type in both places).\nor\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;domain\u003e[:\u0026lt;port\u003e][/]/\u0026lt;repository\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] Notice that this notation optionally also allows a double slash to separate \u0026lt;domain\u0026gt;[:\u0026lt;port\u0026gt;] and \u0026lt;repository\u0026gt;. While it is not necessary for unambiguous parsing here, it is supported for consistency with the other notations.\nor\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;host\u003e:\u0026lt;port\u003e/\u0026lt;repository\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] Notice that \u0026lt;port\u0026gt; is required in this notation. Without \u0026lt;port\u0026gt;, this notation would be ambiguous with the docker library notation mentioned below.\nor\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;host\u003e[:\u0026lt;port\u003e]//\u0026lt;repository\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] Notice the double slash (//) before the \u0026lt;repository\u0026gt;. This serves as a clear separator between \u0026lt;host\u0026gt;[:\u0026lt;port\u0026gt;] and \u0026lt;repository\u0026gt;. Thus, with this notation, the port is optional and can therefore be omitted without creating ambiguity with the docker library notation mentioned below.\nor\n\u0026lt;docker library\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] or\n\u0026lt;docker repository\u003e/\u0026lt;docker image\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] Besides dedicated artifacts it is also possible to denote registries as a whole:\n[+][\u0026lt;type\u003e::][./]\u0026lt;file path\u003e or\n[+][\u0026lt;type\u003e::]\u0026lt;json repo spec\u003e Notice that if you specify the \u0026lt;type\u0026gt; in the beginning of this notation AND in the \u0026lt;json repo spec\u0026gt;, the types have to match (but there is no reason to specify the type in both places).\nor\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;domain\u003e[:\u0026lt;port\u003e] or\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;host\u003e[:\u0026lt;port\u003e] Notice that \u0026lt;port\u0026gt; is optional in this notation since this cannot be an image reference and therefore cannot be ambiguous with the docker library notation.\nThe optional + is used for file based implementations (Common Transport Format) to indicate the creation of a not yet existing file.\nThe type may contain a file format qualifier separated by a + character. The following formats are supported: directory, tar, tgz\nExamples +ctf+directory::./ocm/ctf//ocm.software/ocmcli/ocmcli-image:0.7.0@sha256:29c842be1ef1da67f6a1c07a3a3a8eb101bbcc4c80f174b87d147b341bca9625 oci::{\u0026#34;baseUrl\u0026#34;: \u0026#34;ghcr.io\u0026#34;}//open-component-model/ocm/ocm.software/ocmcli/ocmcli-image:0.7.0@sha256:29c842be1ef1da67f6a1c07a3a3a8eb101bbcc4c80f174b87d147b341bca9625 oci::https://ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image:0.7.0@sha256:29c842be1ef1da67f6a1c07a3a3a8eb101bbcc4c80f174b87d147b341bca9625 oci::https://ghcr.io//open-component-model/ocm/ocm.software/ocmcli/ocmcli-image:0.7.0@sha256:29c842be1ef1da67f6a1c07a3a3a8eb101bbcc4c80f174b87d147b341bca9625 oci::http://localhost:8080/ocm.software/ocmcli/ocmcli-image:0.7.0@sha256:29c842be1ef1da67f6a1c07a3a3a8eb101bbcc4c80f174b87d147b341bca9625 oci::http://localhost:8080//ocm.software/ocmcli/ocmcli-image:0.7.0@sha256:29c842be1ef1da67f6a1c07a3a3a8eb101bbcc4c80f174b87d147b341bca9625 ubuntu:24.04 ubuntu tensorflow/tensorflow:2.15.0 tensorflow/tensorflow\rSee Also ","date":"0001-01-01","id":59,"permalink":"/docs/reference/ocm-cli/help/oci-references/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eThe command line client supports a special notation scheme for specifying\nreferences to instances of oci like registries. This allows for specifying\nreferences to any registry supported by the OCM toolset that can host OCI\nartifacts. As a subset the regular OCI artifact notation used for docker\nimages are possible:\u003c/p\u003e","tags":[],"title":"oci-references"},{"content":"Options -X, --attribute stringArray attribute setting --ca-cert stringArray additional root certificate authorities (for signing certificates) --config stringArray configuration file --config-set strings apply configuration set -C, --cred stringArray credential setting -h, --help help for ocm -I, --issuer stringArray issuer name or distinguished name (DN) (optionally for dedicated signature) ([\u0026lt;name\u0026gt;:=]\u0026lt;dn\u0026gt;) --logJson log as json instead of human readable logs --logconfig string log config -L, --logfile string set log file --logkeys stringArray log tags/realms(with leading /) to be enabled ([/[+]]name{,[/[+]]name}[=level]) -l, --loglevel string set log level -K, --private-key stringArray private key setting -k, --public-key stringArray public key setting -v, --verbose deprecated: enable logrus verbose logging --version show version\rIntroduction The Open Component Model command line client supports the work with OCM artifacts, like Common Transport Archive, Component Repositories, and Component Versions.\nAdditionally it provides some limited support for the docker daemon, OCI artifacts and registries.\nIt can be used in two ways:\nverb/operation first: here the sub commands follow the pattern \u0026lt;verb\u0026gt; \u0026lt;object kind\u0026gt; \u0026lt;arguments\u0026gt; area/kind first: here the area and/or object kind is given first followed by the operation according to the pattern [\u0026lt;area\u0026gt;] \u0026lt;object kind\u0026gt; \u0026lt;verb/operation\u0026gt; \u0026lt;arguments\u0026gt; The command accepts some top level options, they can only be given before the sub commands.\nA configuration according to ocm configfile is read from a .ocmconfig file located in the HOME directory. With the option \u0026ndash;config other file locations can be specified. If nothing is specified and no file is found at the default location a default configuration is composed according to known type specific configuration files.\nThe following configuration sources are used:\nThe docker configuration file at ~/.docker/config.json is read to feed in the configured credentials for OCI registries.\nThe npm configuration file at ~/.npmrc is read to feed in the configured credentials for NPM registries.\nWith the option \u0026ndash;cred it is possible to specify arbitrary credentials for various environments on the command line. Nevertheless it is always preferable to use the cli config file. Every credential setting is related to a dedicated consumer and provides a set of credential attributes. All this can be specified by a sequence of \u0026ndash;cred options.\nEvery option value has the format\n--cred [:]\u0026lt;attr\u003e=\u0026lt;value\u003e Consumer identity attributes are prefixed with the colon \u0026lsquo;:\u0026rsquo;. A credential settings always start with a sequence of at least one identity attributes, followed by a sequence of credential attributes. If a credential attribute is followed by an identity attribute a new credential setting is started.\nThe first credential setting may omit identity attributes. In this case it is used as default credential, always used if no dedicated match is found.\nFor example:\n--cred :type=OCIRegistry --cred :hostname=ghcr.io --cred username=mandelsoft --cred password=xyz With the option -X it is possible to pass global settings of the form\n-X \u0026lt;attribute\u003e=\u0026lt;value\u003e The \u0026ndash;log* options can be used to configure the logging behaviour. For details see ocm logging.\nThere is a quick config option \u0026ndash;logkeys to configure simple tag/realm based condition rules. The comma-separated names build an AND rule. Hereby, names starting with a slash (/) denote a realm (without the leading slash). A realm is a slash separated sequence of identifiers. If the realm name starts with a plus (+) character the generated rule will match the realm and all its sub-realms, otherwise, only the dedicated realm is affected. For example /+ocm=trace will enable all log output of the OCM library.\nA tag directly matches the logging tags. Used tags and realms can be found under topic ocm logging. The ocm coding basically uses the realm ocm. The default level to enable is info. Separated by an equal sign (=) optionally a dedicated level can be specified. Log levels can be (error, warn, info, debug and trace. The default level is warn. The \u0026ndash;logconfig* options can be used to configure a complete logging configuration (yaml/json) via command line. If the argument starts with an @, the logging configuration is taken from a file.\nThe value can be a simple type or a JSON/YAML string for complex values (see ocm attributes). The following attributes are supported:\ngithub.com/mandelsoft/logforward [logfwd]: logconfig Logging config structure used for config forwarding\nThis attribute is used to specify a logging configuration intended to be forwarded to other tools. (For example: TOI passes this config to the executor)\ngithub.com/mandelsoft/oci/cache [cache]: string\nFilesystem folder to use for caching OCI blobs\ngithub.com/mandelsoft/ocm/compat [compat]: bool\nCompatibility mode: Avoid generic local access methods and prefer type specific ones.\ngithub.com/mandelsoft/ocm/hasher: JSON\nPreferred hash algorithm to calculate resource digests. The following digesters are supported:\nNO-DIGEST SHA-256 (default) SHA-512 github.com/mandelsoft/ocm/keeplocalblob [keeplocalblob]: bool\nKeep local blobs when importing OCI artifacts to OCI registries from localBlob access methods. By default, they will be expanded to OCI artifacts with the access method ociRegistry. If this option is set to true, they will be stored as local blobs, also. The access method will still be localBlob but with a nested ociRegistry access method for describing the global access.\ngithub.com/mandelsoft/ocm/mapocirepo [mapocirepo]: bool|YAML\nWhen uploading an OCI artifact blob to an OCI based OCM repository and the artifact is uploaded as OCI artifact, the repository path part is shortened, either by hashing all but the last repository name part or by executing some prefix based name mappings.\nIf a boolean is given the short hash or none mode is enabled. The YAML flavor uses the following fields:\nmode string: hash, shortHash, prefixMapping or none. If unset, no mapping is done. prefixMappings: map[string]string repository path prefix mapping. prefix: string repository prefix to use (replaces potential sub path of OCM repo). or none. prefixMapping: map[string]string repository path prefix mapping. Notes:\nThe mapping only occurs in transfer commands and only when transferring to OCI registries (e.g. when transferring to a CTF archive this option will be ignored). The mapping in mode prefixMapping requires a full prefix of the composed final name. Partial matches are not supported. The host name of the target will be skipped. The artifact name of the component-descriptor is not mapped. If the mapping is provided on the command line it must be JSON format and needs to be properly escaped (see example below). Example:\nAssume a component named github.com/my_org/myexamplewithalongname and a chart name echo in the Charts.yaml of the chart archive. The following input to a resource.yaml creates a component version:\nname: mychart type: helmChart input: type: helm path: charts/mychart.tgz --- name: myimage type: ociImage version: 0.1.0 input: type: ociImage repository: ocm/ocm.software/ocmcli/ocmcli-image path: ghcr.io/acme/ocm/ocm.software/ocmcli/ocmcli-image:0.1.0 The following command:\nocm \"-X mapocirepo={\\\"mode\\\":\\\"mapping\\\",\\\"prefixMappings\\\":{\\\"acme/github.com/my_org/myexamplewithalongname/ocm/ocm.software/ocmcli\\\":\\\"acme/cli\\\", \\\"acme/github.com/my_org/myexamplewithalongnameabc123\\\":\\\"acme/mychart\\\"}}\" transfer ctf -f --copy-resources ./ctf ghcr.io/acme will result in the following artifacts in ghcr.io/my_org:\nmychart/echo cli/ocmcli-image Note that the host name part of the transfer target ghcr.io/acme is excluded from the prefix but the path acme is considered.\nThe same using a config file .ocmconfig:\ntype: generic.config.ocm.software/v1 configurations: ... - type: attributes.config.ocm.software attributes: ... mapocirepo: mode: mapping prefixMappings: acme/github.com/my\\_org/myexamplewithalongname/ocm/ocm.software/ocmcli: acme/cli acme/github.com/my\\_org/myexamplewithalongnameabc123: acme/mychart ocm transfer ca -f --copy-resources ./ca ghcr.io/acme github.com/mandelsoft/ocm/ociuploadrepo [ociuploadrepo]: oci base repository ref\nUpload local OCI artifact blobs to a dedicated repository.\ngithub.com/mandelsoft/ocm/plugindir [plugindir]: plugin directory\nDirectory to look for OCM plugin executables.\ngithub.com/mandelsoft/ocm/rootcerts [rootcerts]: JSON\nGeneral root certificate settings given as JSON document with the following format:\n{ \"rootCertificates\": [ { \"data\": \"\"\u0026lt;base64\u003e\" }, { \"path\": \"\"\u0026lt;file path\u003e\" } ] } One of following data fields are possible:\ndata: base64 encoded binary data stringdata: plain text data path: a file path to read the data from github.com/mandelsoft/ocm/signing: JSON\nPublic and private Key settings given as JSON document with the following format:\n{ \"publicKeys\": [ \"\u0026lt;provider\u003e\": { \"data\": \"\"\u0026lt;base64\u003e\" } ], \"privateKeys\"\": [ \"\u0026lt;provider\u003e\": { \"path\": \"\"\u0026lt;file path\u003e\" } ] } One of following data fields are possible:\ndata: base64 encoded binary data stringdata: plain text data path: a file path to read the data from github.com/mandelsoft/tempblobcache [blobcache]: string Foldername for temporary blob cache\nThe temporary blob cache is used to accessing large blobs from remote systems. The are temporarily stored in the filesystem, instead of the memory, to avoid blowing up the memory consumption.\nocm.software/cliconfig [cliconfig]: cliconfig Configuration Object passed to command line plugin.\nocm.software/compositionmode [compositionmode]: bool (default: false)\nComposition mode decouples a component version provided by a repository implementation from the backend persistence. Added local blobs will and other changes will not be forwarded to the backend repository until an AddVersion is called on the component. If composition mode is disabled blobs will directly be forwarded to the backend and descriptor updated will be persisted on AddVersion or closing a provided existing component version.\nocm.software/ocm/oci/preferrelativeaccess [preferrelativeaccess]: bool\nIf an artifact blob is uploaded to the technical repository used as OCM repository, the uploader should prefer to return a relative access method.\nocm.software/signing/sigstore [sigstore]: sigstore config Configuration to use for sigstore based signing.\nThe following fields are used.\nfulcioURL string default is https://fulcio.sigstore.dev rekorURL string default is https://rekor.sigstore.dev OIDCIssuer string default is https://oauth2.sigstore.dev/auth OIDCClientID string default is sigstore For several options (like -X) it is possible to pass complex values using JSON or YAML syntax. To pass those arguments the escaping of the used shell must be used to pass quotes, commas, curly brackets or newlines. for the bash the easiest way to achieve this is to put the complete value into single quotes.\n-X 'mapocirepo={\"mode\": \"shortHash\"}'. Alternatively, quotes and opening curly brackets can be escaped by using a backslash (\\). Often a tagged value can also be substituted from a file with the syntax\n\u0026lt;attr\u003e=@\u0026lt;filepath\u003e The \u0026ndash;public-key and \u0026ndash;private-key options can be used to define public and private keys on the command line. The options have an argument of the form \u0026lt;name\u0026gt;=\u0026lt;filepath\u0026gt;. The name is the name of the key and represents the context is used for (For example the signature name of a component version)\nAlternatively a key can be specified as base64 encoded string if the argument start with the prefix ! or as direct string with the prefix =.\nWith \u0026ndash;issuer it is possible to declare expected issuer constraints for public key certificates provided as part of a signature required to accept the provisioned public key (besides the successful validation of the certificate). By default, the issuer constraint is derived from the signature name. If it is not a formal distinguished name, it is assumed to be a plain common name.\nWith \u0026ndash;ca-cert it is possible to define additional root certificates for signature verification, if public keys are provided by a certificate delivered with the signature.\nSee Also Sub Commands ocm add\t— Add elements to a component repository or component version ocm check\t— check components in OCM repository ocm clean\t— Cleanup/re-organize elements ocm create\t— Create transport or component archive ocm describe\t— Describe various elements by using appropriate sub commands. ocm download\t— Download oci artifacts, resources or complete components ocm get\t— Get information about artifacts and components ocm list\t— List information about components ocm set\t— Set information about OCM repositories ocm show\t— Show tags or versions ocm sign\t— Sign components or hashes ocm transfer\t— Transfer artifacts or components ocm verify\t— Verify component version signatures Additional Help Topics ocm attributes\t— configuration attributes used to control the behaviour ocm configfile\t— configuration file ocm credential-handling\t— Provisioning of credentials for credential consumers ocm logging\t— Configured logging keys ocm oci-references\t— notation for OCI references ocm ocm-accessmethods\t— List of all supported access methods ocm ocm-downloadhandlers\t— List of all available download handlers ocm ocm-labels\t— Labels and Label Merging ocm ocm-pubsub\t— List of all supported publish/subscribe implementations ocm ocm-references\t— notation for OCM references ocm ocm-uploadhandlers\t— List of all available upload handlers ocm toi-bootstrapping\t— Tiny OCM Installer based on component versions ","date":"0001-01-01","id":60,"permalink":"/docs/reference/ocm-cli/","summary":"\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -X, --attribute stringArray     attribute setting\n      --ca-cert stringArray       additional root certificate authorities (for signing certificates)\n      --config stringArray        configuration file\n      --config-set strings        apply configuration set\n  -C, --cred stringArray          credential setting\n  -h, --help                      help for ocm\n  -I, --issuer stringArray        issuer name or distinguished name (DN) (optionally for dedicated signature) ([\u0026lt;name\u0026gt;:=]\u0026lt;dn\u0026gt;)\n      --logJson                   log as json instead of human readable logs\n      --logconfig string          log config\n  -L, --logfile string            set log file\n      --logkeys stringArray       log tags/realms(with leading /) to be enabled ([/[+]]name{,[/[+]]name}[=level])\n  -l, --loglevel string           set log level\n  -K, --private-key stringArray   private key setting\n  -k, --public-key stringArray    public key setting\n  -v, --verbose                   deprecated: enable logrus verbose logging\n      --version                   show version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"introduction\"\u003eIntroduction\u003c/h3\u003e\n\u003cp\u003eThe Open Component Model command line client supports the work with OCM\nartifacts, like Common Transport Archive,\nComponent Repositories, and Component Versions.\u003c/p\u003e","tags":[],"title":"OCM CLI"},{"content":"Description Access methods are used to handle the access to the content of artifacts described in a component version. Therefore, an artifact entry contains an access specification describing the access attributes for the dedicated artifact.\nThe following list describes the supported access methods, their versions and specification formats. Typically there is special support for the CLI artifact add commands. The access method specification can be put below the access field. If always requires the field type describing the kind and version shown below.\nAccess type git\nThis method implements the access of the content of a git commit stored in a Git repository.\nThe following versions are supported:\nVersion v1alpha1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;commit, \u0026ndash;reference\nAccess type gitHub\nThis method implements the access of the content of a git commit stored in a GitHub repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessHostname, \u0026ndash;accessRepository, \u0026ndash;commit\nAccess type helm\nThis method implements the access of a Helm chart stored in a Helm repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nhelmRepository string\nHelm repository URL.\nhelmChart string\nThe name of the Helm chart and its version separated by a colon.\nversion string\nThe version of the Helm chart if not specified as part of the chart name.\ncaCert string\nAn optional TLS root certificate.\nkeyring string\nAn optional keyring used to verify the chart.\nIt uses the consumer identity type HelmChartRepository with the fields for a hostpath identity matcher (see ocm get credentials).\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type localBlob\nThis method is used to store a resource blob along with the component descriptor on behalf of the hosting OCM repository.\nIts implementation is specific to the implementation of OCM repository used to read the component descriptor. Every repository implementation may decide how and where local blobs are stored, but it MUST provide an implementation for this method.\nRegardless of the chosen implementation the attribute specification is defined globally the same.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nlocalReference string\nRepository type specific location information as string. The value may encode any deep structure, but typically just an access path is sufficient.\nmediaType string\nThe media type of the blob used to store the resource. It may add format information like +tar or +gzip.\nreferenceName (optional) string\nThis optional attribute may contain identity information used by other repositories to restore some global access with an identity related to the original source.\nFor example, if an OCI artifact originally referenced using the access method ociArtifact is stored during some transport step as local artifact, the reference name can be set to its original repository name. An import step into an OCI based OCM repository may then decide to make this artifact available again as regular OCI artifact.\nglobalAccess (optional) access method specification\nIf a resource blob is stored locally, the repository implementation may decide to provide an external access information (independent of the OCM model).\nFor example, an OCI artifact stored as local blob can be additionally stored as regular OCI artifact in an OCI registry.\nThis additional external access information can be added using a second external access method specification.\nOptions used to configure fields: \u0026ndash;globalAccess, \u0026ndash;hint, \u0026ndash;mediaType, \u0026ndash;reference\nAccess type maven\nThis method implements the access of a Maven artifact in a Maven repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nURL of the Maven repository\ngroupId string\nThe groupId of the Maven artifact\nartifactId string\nThe artifactId of the Maven artifact\nversion string\nThe version name of the Maven artifact\nclassifier string\nThe optional classifier of the Maven artifact\nextension string\nThe optional extension of the Maven artifact\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId\nAccess type none\ndummy resource with no access\nAccess type npm\nThis method implements the access of an NPM package in an NPM registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregistry string\nBase URL of the NPM registry.\npackage string\nThe name of the NPM package\nversion string\nThe version name of the NPM package\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type ociArtifact\nThis method implements the access of an OCI artifact stored in an OCI registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI image/artifact reference following the possible docker schemes:\n\u0026lt;repo\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;digest\u0026gt;@\u0026lt;tag\u0026gt; [\u0026lt;port\u0026gt;]/\u0026lt;repo path\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;version\u0026gt;@\u0026lt;tag\u0026gt; Options used to configure fields: \u0026ndash;reference\nAccess type ociBlob\nThis method implements the access of an OCI blob stored in an OCI repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI repository reference (this artifact name used to store the blob).\nmediaType string\nThe media type of the blob\ndigest string\nThe digest of the blob used to access the blob in the OCI repository.\nsize integer\nThe size of the blob\nOptions used to configure fields: \u0026ndash;digest, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;size\nAccess type ocm\nThis method implements the access of any resource artifact stored in an OCM repository. Only repository types supporting remote access should be used.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nocmRepository json\nThe repository spec for the OCM repository\ncomponent string\n(Optional) The name of the component. The default is the own component.\nversion string\n(Optional) The version of the component. The default is the own component version.\nresourceRef relative resource ref\nThe resource reference of the denoted resource relative to the given component version.\nIt uses the consumer identity and credentials for the intermediate repositories and the final resource access.\nOptions used to configure fields: \u0026ndash;accessComponent, \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;identityPath\nAccess type s3\nThis method implements the access of a blob stored in an S3 bucket.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucket string\nThe name of the S3 bucket containing the blob\nkey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nVersion v2\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucketName string\nThe name of the S3 bucket containing the blob\nobjectKey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nOptions used to configure fields: \u0026ndash;accessVersion, \u0026ndash;bucket, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;region\nAccess type wget\nThis method implements access to resources stored on an http server.\nThe following versions are supported:\nVersion v1\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string This REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string This OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string This OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string This OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte This OPTIONAL property describes the http body to be included in the request.\nnoredirect bool This OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nSee Also ","date":"0001-01-01","id":61,"permalink":"/docs/reference/ocm-cli/help/ocm-accessmethods/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAccess methods are used to handle the access to the content of artifacts\ndescribed in a component version. Therefore, an artifact entry contains\nan access specification describing the access attributes for the dedicated\nartifact.\u003c/p\u003e","tags":[],"title":"ocm-accessmethods"},{"content":"Description A download handler can be used to process resources to be downloaded from on OCM repository. By default, the blobs provided from the access method (see ocm ocm-accessmethods) are used to store the resource content in the local filesystem. Download handlers can be used to tweak this process. They get access to the blob content and decide on their own what to do with it, or how to transform it into files stored in the file system.\nFor example, a pre-registered helm download handler will store OCI-based helm artifacts as regular helm archives in the local file system.\nHandler Registration Programmatically any kind of handlers can be registered for various download conditions. But this feature is available as command-line option, also. New handlers can be provided by plugins. In general available handlers, plugin-based or as part of the CLI coding are nameable using an hierarchical namespace. Those names can be used by a \u0026ndash;downloader option to register handlers for various conditions for CLI commands like ocm download resources (implicitly registered download handlers can be enabled using the option -d).\nBesides the activation constraints (resource type and media type of the resource blob), it is possible to pass handler configuration controlling the exact behaviour of the handler for selected artifacts.\nThe following handler names are possible:\nhelm/artifact: download helm chart resources\nThe helm downloader is able to download helm chart resources as helm chart packages. Thus, the downloader may perform transformations. For example, if the helm chart is currently stored as an oci artifact, the downloader performs the necessary extraction to provide the helm chart package from within that oci artifact.\nThe following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar+gzip application/vnd.cncf.helm.chart.content.v1.tar+gzip It accepts no config.\nlandscaper/blueprint: uploading an OCI artifact to an OCI registry\nThe artifact downloader is able to transfer OCI artifact-like resources into an OCI registry given by the combination of the download target and the registration config.\nIf no config is given, the target must be an OCI reference with a potentially omitted repository. The repo part is derived from the reference hint provided by the resource\u0026rsquo;s access specification.\nIf the config is given, the target is used as repository name prefixed with an optional repository prefix given by the configuration.\nThe following artifact media types are supported:\napplication/vnd.docker.distribution.manifest.v2+tar application/vnd.docker.distribution.manifest.v2+tar+gzip application/vnd.gardener.landscaper.blueprint.layer.v1.tar application/vnd.gardener.landscaper.blueprint.layer.v1.tar+gzip application/vnd.gardener.landscaper.blueprint.v1+tar application/vnd.gardener.landscaper.blueprint.v1+tar+gzip application/vnd.oci.image.manifest.v1+tar application/vnd.oci.image.manifest.v1+tar+gzip application/x-tar application/x-tar+gzip application/x-tgz It accepts a config with the following fields:\nociConfigTypes: a list of accepted OCI config archive mime types defaulted by application/vnd.gardener.landscaper.blueprint.config.v1. This handler is by default registered for the following artifact types: landscaper.gardener.cloud/blueprint,blueprint\noci/artifact: downloading an OCI artifact and optionally re-uploading to an OCI registry\nThe artifact download resources stored as oci artifact. Furthermore, it allows to specify another OCI registry as download destination, thereby, providing a kind of transfer functionality.\nIf no config is given, the target must be an OCI reference with a potentially omitted repository. The repo part is derived from the reference hint provided by the resource\u0026rsquo;s access specification.\nIf the config is given, the target is used as repository name prefixed with an optional repository prefix given by the configuration.\nThe following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar+gzip application/vnd.oci.image.index.v1+tar+gzip It accepts a config with the following fields:\nnamespacePrefix: a namespace prefix used for the uploaded artifacts ociRef: an OCI repository reference repository: an OCI repository specification for the target OCI registry ocm/dirtree: downloading directory tree-like resources\nThe dirtree downloader is able to download directory-tree like resources as directory structure (default) or archive. The following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar+gzip application/x-tgz application/x-tar+gzip application/x-tar By default, it is registered for the following resource types:\ndirectoryTree filesystem It accepts a config with the following fields:\nasArchive: flag to request an archive download ociConfigTypes: a list of accepted OCI config archive mime types defaulted by application/vnd.oci.image.config.v1+json. plugin: [downloaders provided by plugins]\nsub namespace of the form \u0026lt;plugin name\u0026gt;/\u0026lt;handler\u0026gt;\nSee ocm ocm-downloadhandlers for further details on using download handlers.\nSee Also ","date":"0001-01-01","id":62,"permalink":"/docs/reference/ocm-cli/help/ocm-downloadhandlers/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eA download handler can be used to process resources to be downloaded from\non OCM repository. By default, the blobs provided from the access method\n(see \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-accessmethods/\"\u003eocm ocm-accessmethods\u003c/a\u003e) are used to store the resource content\nin the local filesystem. Download handlers can be used to tweak this process.\nThey get access to the blob content and decide on their own what to do\nwith it, or how to transform it into files stored in the file system.\u003c/p\u003e","tags":[],"title":"ocm-downloadhandlers"},{"content":"Description Labels are a set of arbitrary properties, which can be attached to elements of a component version:\na component version itself the provider of a component version resources sources component references The dedicated elements support this by providing a field labels, which is a list of label definitions. Every label definition has several fields:\nname string\nThe name of the label also determines the interpretation of its value. All labels with a dedicated name must have the same globally unique meaning, enabling a common understanding of label content for tools working of such properties of an element.\nThere are several predefined labels, they just use flat names. To guarantee globally unique meanings of labels a label name may have a hierarchical structure. Names defined in dedicated definition realms must be prefixed by a DNS domain-like string identifying the organization of realm defining the label\u0026rsquo;s value structure. For example: acme.org/maturity/level.\nHereby, the name defines the meaning of the value and its value structure. To support the evolution of the value structure a label field optionally contains a version field, which finally defines the concrete value structure in the context of the meaning of the label name. A version is just a number prefixed with a v. If not specified, the version v1 is assumed.\nversion string (optional) (default: v1)\nThe format version of the label value in the context of the label name.\nvalue any\nThe value of the label according to the specified format version of the label in the context of its name.\nsigning bool (optional)\nBy default, labels are not signature-relevant and they will nor influence the digest of the component version. This allows adding, deleting or modifying labels as part of a process chain during the lifecycle of a component version.\nLabels which should describe relevant and unmodifiable content can be marked to be signing relevant by setting this label field to true.\nmerge merge spec (optional)\nModifiable labels can be changed independently in any transport target location of a component version. This might require to update label values when importing a new setting for a component version. This means a merging of content to reflect the combination of changes in the transport source and target.\nThis is supported by the possibility to specify merge algorithms. The can be bound to a dedicated label incarnation or to the label name.\nMerge Specification A merge specification consists of two fields:\nalgorithm string (optional) (default: default)\nThe name of the algorithm to be used for the merge process.\nconfig any (optional)\nAn algorithm specific configuration to control the merge process.\nThere is an often used configuration field overwrite with a common meaning for all algorithms supporting it. It controls the conflict resolution and has the following values:\nnone: conflicting values prevent the merging. An update transfer process will be aborted.\nlocal: a conflict will be resolved to the local change (in the target environment)\ninbound: a conflict will be resolved to the value provided by the source environment\n\u0026lt;empty\u0026gt;: use a default provided by the dedicated algorithm.\nThe default behaviour might mean to apply a cascaded merge specification, if the merge specification supports to specify appropriate fields to specify this specification (for example a field entries).\nDetermining a Merge Specification A merge specification directly attached to a label is always preferred. If no algorithm is specified a merge assignment for the label name and its version is evaluated. The assignment hint is composed with\nlabel:\u0026lt;*label name*\u003e@%lt;version\u003e The label version is defaulted to v1.\nSupported Merge Algorithms There are some built-in algorithms featuring a flat name. But it will be possible to add arbitrary algorithms using the plugin concept.\nThe following algorithms are possible:\ndefault (default): This handler merges arbitrary label values by deciding for one or none side.\nIt supports the following config structure:\noverwrite string (optional) determines how to handle conflicts.\nnone no change possible, if entry differs the merge is rejected. local the local value is preserved. inbound (default) the inbound value overwrites the local one. mapListMerge: This handler merges values with a list of map values by observing a key field to identify similar map entries. The default entry key is taken from map field name.\nIt supports the following config structure:\nkeyField string (optional)\nthe key field to identify entries in the maps.\noverwrite string (optional) determines how to handle conflicts.\nnone (default) no change possible, if entry differs the merge is rejected. local the local value is preserved. inbound the inbound value overwrites the local one. *entries merge spec (optional)\nThe merge specification (algorithm and config) used to merge conflicting changes in list entries.\nsimpleListMerge: This handler merges simple list labels values.\nIt supports the following config structure:\noverwrite string (optional) determines how to handle conflicts. simpleMapMerge: This handler merges simple map labels values.\nIt supports the following config structure:\noverwrite string (optional) determines how to handle conflicts.\nnone (default) no change possible, if entry differs the merge is rejected. local the local value is preserved. inbound the inbound value overwrites the local one. *entries merge spec (optional)\nThe merge specification (algorithm and config) used to merge conflicting changes in map entries.\nThe following label assignments are configured:\nlabel:routing-slips: simpleMapMerge See Also ","date":"0001-01-01","id":63,"permalink":"/docs/reference/ocm-cli/help/ocm-labels/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eLabels are a set of arbitrary properties, which can be attached to elements\nof a component version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea component version itself\u003c/li\u003e\n\u003cli\u003ethe provider of a component version\u003c/li\u003e\n\u003cli\u003eresources\u003c/li\u003e\n\u003cli\u003esources\u003c/li\u003e\n\u003cli\u003ecomponent references\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe dedicated elements support this by providing a field \u003ccode\u003elabels\u003c/code\u003e,\nwhich is a list of label definitions. Every label definition has several fields:\u003c/p\u003e","tags":[],"title":"ocm-labels"},{"content":"Description An OCM repository can be configured to propagate change events via a publish/subscribe system, if there is a persistence provider for the dedicated repository type. If available any known publish/subscribe system can be configured with ocm set pubsub and shown with ocm get pubsub. Hereby, the pub/sub system is described by a typed specification.\nThe following list describes the supported publish/subscribe system types, their specification versions, and formats:\nPubSub type compound\nA pub/sub system forwarding events to described sub-level systems.\nThe following versions are supported:\nVersion v1\nIt is described by the following field:\nspecifications list of pubsub specs\nA list of nested sub-level specifications the events should be forwarded to.\nPubSub type redis\na redis pubsub system.\nThe following versions are supported:\nVersion v1\nIt is describe by the following field:\nserverAddr Address of redis server\nchannel pubsub channel\ndatabase database number\nPublishing using the redis pubsub API. For every change a string message with the format : is published. If multiple repositories should be used, each repository should be configured with a different channel.\nThere are persistence providers for the following repository types:\nOCIRegistry See Also ","date":"0001-01-01","id":64,"permalink":"/docs/reference/ocm-cli/help/ocm-pubsub/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAn OCM repository can be configured to propagate change events via a\npublish/subscribe system, if there is a persistence provider for the dedicated\nrepository type. If available any known publish/subscribe system can\nbe configured with \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/set/pubsub/\"\u003eocm set pubsub\u003c/a\u003e and shown with\n\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/pubsub/\"\u003eocm get pubsub\u003c/a\u003e. Hereby, the pub/sub system\nis described by a typed specification.\u003c/p\u003e","tags":[],"title":"ocm-pubsub"},{"content":"Description The command line client supports a special notation scheme for specifying references to OCM components and repositories. This allows for specifying references to any registry supported by the OCM toolset that can host OCM components:\n[+][\u0026lt;type\u003e::][./]\u0026lt;file path\u003e//\u0026lt;component id\u003e[:\u0026lt;version\u003e] or\n[+][\u0026lt;type\u003e::][\u0026lt;json repo spec\u003e//]\u0026lt;component id\u003e[:\u0026lt;version\u003e] or\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;domain\u003e[:\u0026lt;port\u003e][/\u0026lt;repository prefix\u003e]//\u0026lt;component id\u003e[:\u0026lt;version] or\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;repository prefix\u003e]//\u0026lt;component id\u003e[:\u0026lt;version] Besides dedicated components it is also possible to denote repositories as a whole:\n[+][\u0026lt;type\u003e::][./]\u0026lt;file path\u003e or\n[+][\u0026lt;type\u003e::]\u0026lt;json repo spec\u003e or\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;domain\u003e[:\u0026lt;port\u003e][/\u0026lt;repository prefix\u003e] or\n[+][\u0026lt;type\u003e::][\u0026lt;scheme\u003e://]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;repository prefix\u003e] The optional + is used for file based implementations (Common Transport Format) to indicate the creation of a not yet existing file.\nThe type may contain a file format qualifier separated by a + character. The following formats are supported: directory, tar, tgz\nExamples Complete Component Reference Specifications (including all optional arguments): +ctf+directory::./ocm/ctf//ocm.software/ocmcli:0.7.0 oci::{\u0026#34;baseUrl\u0026#34;:\u0026#34;ghcr.io\u0026#34;,\u0026#34;componentNameMapping\u0026#34;:\u0026#34;urlPath\u0026#34;,\u0026#34;subPath\u0026#34;:\u0026#34;open-component-model\u0026#34;}//ocm.software/ocmcli.0.7.0 oci::https://ghcr.io:443/open-component-model//ocm.software/ocmcli:0.7.0 oci::http://localhost:8080/local-component-repository//ocm.software/ocmcli:0.7.0 --- Short-Hand Component Reference Specifications (omitting optional arguments): ./ocm/ctf//ocm.software/ocmcli:0.7.0 ghcr.io/open-component-model//ocm.software/ocmcli:0.7.0 localhost:8080/local-component-repository//ocm.software/ocmcli:0.7.0 (defaulting to https) http://localhost:8080/local-component-repository//ocm.software/ocmcli:0.7.0\rSee Also ","date":"0001-01-01","id":65,"permalink":"/docs/reference/ocm-cli/help/ocm-references/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eThe command line client supports a special notation scheme for specifying\nreferences to OCM components and repositories. This allows for specifying\nreferences to any registry supported by the OCM toolset that can host OCM\ncomponents:\u003c/p\u003e","tags":[],"title":"ocm-references"},{"content":"Description An upload handler is used to process resources using the access method localBlob transferred into an OCM repository. They may decide to store the content in some other storage repository. This may be an additional storage location or it may replace the storage of the resource as local blob. If an additional storage location is chosen, the local access method is kept and the additional location can be registered in the component descriptor as globalAccess attribute of the local access specification.\nFor example, there is a default upload handler responsible for OCI artifact blobs, which provides regular OCI artifacts for a local blob, if the target OCM repository is based on an OCI registry. Hereby, the referenceName attribute will be used to calculate a meaningful OCI repository name based on the repository prefix of the OCM repository (parallel to component-descriptors prefix used to store the component descriptor artifacts).\nHandler Registration Programmatically any kind of handlers can be registered for various upload conditions. But this feature is available as command-line option, also. New handlers can be provided by plugins. In general available handlers, plugin-based or as part of the CLI coding are nameable using an hierarchical namespace. Those names can be used by a \u0026ndash;uploader option to register handlers for various conditions for CLI commands like ocm transfer componentversions or ocm transfer commontransportarchive.\nBesides the activation constraints (resource type and media type of the resource blob), it is possible to pass a target configuration controlling the exact behaviour of the handler for selected artifacts.\nThe following handler names are possible:\nocm/mavenPackage: uploading maven artifacts\nThe ocm/mavenPackage uploader is able to upload maven artifacts (whole GAV only!) as artifact archive according to the maven artifact spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the maven repository.\nocm/npmPackage: uploading npm artifacts\nThe ocm/npmPackage uploader is able to upload npm artifacts as artifact archive according to the npm package spec. If registered the default mime type is: application/x-tgz\nIt accepts a plain string for the URL or a config with the following field: \u0026lsquo;url\u0026rsquo;: the URL of the npm repository.\nocm/ociArtifacts: downloading OCI artifacts\nThe ociArtifacts downloader is able to download OCI artifacts as artifact archive according to the OCI distribution spec. The following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar application/vnd.oci.image.manifest.v1+tar+gzip application/vnd.oci.image.index.v1+tar application/vnd.oci.image.index.v1+tar+gzip application/vnd.docker.distribution.manifest.v2+tar application/vnd.docker.distribution.manifest.v2+tar+gzip application/vnd.docker.distribution.manifest.list.v2+tar application/vnd.docker.distribution.manifest.list.v2+tar+gzip By default, it is registered for these mimetypes.\nIt accepts a config with the following fields:\nnamespacePrefix: a namespace prefix used for the uploaded artifacts ociRef: an OCI repository reference repository: an OCI repository specification for the target OCI registry Alternatively, a single string value can be given representing an OCI repository reference.\nplugin: [downloaders provided by plugins]\nsub namespace of the form \u0026lt;plugin name\u0026gt;/\u0026lt;handler\u0026gt;\nplugin/jfrog/JFrogHelm: upload artifacts to JFrog HELM repositories by using the JFrog REST API.\nSee ocm ocm-uploadhandlers for further details on using upload handlers.\nSee Also ","date":"0001-01-01","id":66,"permalink":"/docs/reference/ocm-cli/help/ocm-uploadhandlers/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAn upload handler is used to process resources using the access method\n\u003ccode\u003elocalBlob\u003c/code\u003e transferred into an OCM\nrepository. They may decide to store the content in some other\nstorage repository. This may be an additional storage location or it\nmay replace the storage of the resource as local blob.\nIf an additional storage location is chosen, the local access method\nis kept and the additional location can be registered in the component\ndescriptor as \u003ccode\u003eglobalAccess\u003c/code\u003e attribute of the local access\nspecification.\u003c/p\u003e","tags":[],"title":"ocm-uploadhandlers"},{"content":"Usage ocm describe package [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} {\u0026lt;resource id field\u0026gt;}\rOptions -h, --help help for package --lookup stringArray repository name or spec for closure lookup fallback --repo string repository name or spec\rDescription Describe a TOI package provided by a resource of an OCM component version.\nThe package resource must have the type toiPackage. This is a simple YAML file resource describing the bootstrapping of a dedicated kind of software. See also the topic ocm toi-bootstrapping.\nThe first matching resource of this type is selected. Optionally a set of identity attribute can be specified used to refine the match. This can be the resource name and/or other key/value pairs (\u0026lt;attr\u0026gt;=\u0026lt;value\u0026gt;).\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nExamples $ ocm toi describe package ghcr.io/mandelsoft/ocm//ocmdemoinstaller:0.0.1-dev\rSee Also ocm describe\t— Describe various elements by using appropriate sub commands. ","date":"0001-01-01","id":67,"permalink":"/docs/reference/ocm-cli/describe/package/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm describe package [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} {\u0026lt;resource id field\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help                 help for package\n      --lookup stringArray   repository name or spec for closure lookup fallback\n      --repo string          repository name or spec\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDescribe a TOI package provided by a resource of an OCM component version.\u003c/p\u003e","tags":[],"title":"package"},{"content":"Usage ocm describe plugins [\u0026lt;options\u0026gt;] {\u0026lt;plugin name\u0026gt;}\rOptions -h, --help help for plugins\rDescription Describes provides comprehensive information about the capabilities of a plugin.\nExamples $ ocm describe plugins $ ocm describe plugins demo\rSee Also ocm describe\t— Describe various elements by using appropriate sub commands. ","date":"0001-01-01","id":68,"permalink":"/docs/reference/ocm-cli/describe/plugins/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm describe plugins [\u0026lt;options\u0026gt;] {\u0026lt;plugin name\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for plugins\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDescribes provides comprehensive information about the capabilities of\na plugin.\u003c/p\u003e","tags":[],"title":"plugins"},{"content":"Usage ocm get plugins [\u0026lt;options\u0026gt;] {\u0026lt;plugin name\u0026gt;}\rOptions -h, --help help for plugins -o, --output string output mode (JSON, json, wide, yaml) -s, --sort stringArray sort fields\rDescription Get lists information for all plugins specified, if no plugin is specified all registered ones are listed.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json wide yaml Examples $ ocm get plugins $ ocm get plugins demo -o yaml\rSee Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":69,"permalink":"/docs/reference/ocm-cli/get/plugins/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get plugins [\u0026lt;options\u0026gt;] {\u0026lt;plugin name\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help               help for plugins\n  -o, --output string      output mode (JSON, json, wide, yaml)\n  -s, --sort stringArray   sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet lists information for all plugins specified, if no plugin is specified\nall registered ones are listed.\u003c/p\u003e","tags":[],"title":"plugins"},{"content":"Usage ocm get pubsub {\u0026lt;ocm repository\u0026gt;}\rOptions -h, --help help for pubsub -o, --output string output mode (JSON, json, yaml) -s, --sort stringArray sort fields\rDescription A repository may be able to store a publish/subscribe specification to propagate the creation or update of component versions. If such an implementation is available and a specification is assigned to the repository, it is shown. The specification can be set with the ocm set pubsub.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json yaml See Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":70,"permalink":"/docs/reference/ocm-cli/get/pubsub/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get pubsub {\u0026lt;ocm repository\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help               help for pubsub\n  -o, --output string      output mode (JSON, json, yaml)\n  -s, --sort stringArray   sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eA repository may be able to store a publish/subscribe specification\nto propagate the creation or update of component versions.\nIf such an implementation is available and a specification is\nassigned to the repository, it is shown. The specification\ncan be set with the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/set/pubsub/\"\u003eocm set pubsub\u003c/a\u003e.\u003c/p\u003e","tags":[],"title":"pubsub"},{"content":"Usage ocm set pubsub {\u0026lt;ocm repository\u0026gt;} [\u0026lt;pub/sub specification\u0026gt;]\rOptions -d, --delete delete pub/sub configuration -h, --help help for pubsub\rDescription A repository may be able to store a publish/subscribe specification to propagate the creation or update of component versions. If such an implementation is available this command can be used to set the pub/sub specification for a repository. If no specification is given an existing specification will be removed for the given repository. The specification can be queried with the ocm get pubsub. Types and specification formats are shown for the topic ocm ocm-pubsub.\nSee Also ocm set\t— Set information about OCM repositories ","date":"0001-01-01","id":71,"permalink":"/docs/reference/ocm-cli/set/pubsub/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm set pubsub {\u0026lt;ocm repository\u0026gt;} [\u0026lt;pub/sub specification\u0026gt;]\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -d, --delete   delete pub/sub configuration\n  -h, --help     help for pubsub\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eA repository may be able to store a publish/subscribe specification\nto propagate the creation or update of component versions.\nIf such an implementation is available this command can be used\nto set the pub/sub specification for a repository.\nIf no specification is given an existing specification\nwill be removed for the given repository.\nThe specification\ncan be queried with the \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/get/pubsub/\"\u003eocm get pubsub\u003c/a\u003e.\nTypes and specification formats are shown for the topic\n\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/help/ocm-pubsub/\"\u003eocm ocm-pubsub\u003c/a\u003e.\u003c/p\u003e","tags":[],"title":"pubsub"},{"content":"Usage ocm add references [\u0026lt;options\u0026gt;] [\u0026lt;target\u0026gt;] {\u0026lt;referencefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\rOptions --addenv access environment for templating --component string component name --dry-run evaluate and print reference specifications --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; reference extra identity (default []) -F, --file string target file/directory (default \u0026#34;component-archive\u0026#34;) -h, --help help for references --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt; reference label (leading * indicates signature relevant, optional version separated by @) --name string reference name -O, --output string output file for dry-run -P, --preserve-signature preserve existing signatures --reference YAML reference meta data (yaml) -R, --replace replace existing elements -s, --settings stringArray settings file with variable settings (yaml) --templater string templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;) --version string reference version\rDescription Add aggregation information specified in a reference file to a component version. So far only component archives are supported as target.\nThis command accepts reference specification files describing the references to add to a component version. Elements must follow the reference meta data description scheme of the component descriptor.\nThe description file might contain:\na single reference a list of references under the key references a list of yaml documents with a single reference or reference list It is possible to describe a single reference via command line options. The meta data of this element is described by the argument of option \u0026ndash;reference, which must be a YAML or JSON string. Alternatively, the name and version can be specified with the options \u0026ndash;name and \u0026ndash;version. With the option \u0026ndash;extra it is possible to add extra identity attributes. Explicitly specified options override values specified by the \u0026ndash;reference option. (Note: Go templates are not supported for YAML-based option values. Besides this restriction, the finally composed element description is still processed by the selected template engine.)\nThe component name can be specified with the option \u0026ndash;component. Therefore, basic references not requiring any additional labels or extra identities can just be specified by those simple value options without the need for the YAML option.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" The \u0026ndash;replace option allows users to specify whether adding an element with the same name and extra identity but different version as an existing element, append (false) or replace (true) the existing element.\nThe \u0026ndash;preserve-signature option prohibits changes of signature relevant elements.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" Examples Add a reference directly by options $ ocm add references --file path/to/ca --name myref --component github.com/my/component --version ${VERSION} Add a reference by a description file: *references.yaml*: --- name: myref component: github.com/my/component version: ${VERSION] $ ocm add references path/to/ca references.yaml VERSION=1.0.0\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":72,"permalink":"/docs/reference/ocm-cli/add/references/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add references [\u0026lt;options\u0026gt;] [\u0026lt;target\u0026gt;] {\u0026lt;referencefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --addenv                 access environment for templating\n      --component string       component name\n      --dry-run                evaluate and print reference specifications\n      --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;   reference extra identity (default [])\n  -F, --file string            target file/directory (default \u0026#34;component-archive\u0026#34;)\n  -h, --help                   help for references\n      --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt;    reference label (leading * indicates signature relevant, optional version separated by @)\n      --name string            reference name\n  -O, --output string          output file for dry-run\n  -P, --preserve-signature     preserve existing signatures\n      --reference YAML         reference meta data (yaml)\n  -R, --replace                replace existing elements\n  -s, --settings stringArray   settings file with variable settings (yaml)\n      --templater string       templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;)\n      --version string         reference version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdd aggregation information specified in a reference file to a component version.\nSo far only component archives are supported as target.\u003c/p\u003e","tags":[],"title":"references"},{"content":"Usage ocm get references [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\rOptions -c, --constraints constraints version constraint -h, --help help for references --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --recursive follow component reference nesting --repo string repository name or spec -s, --sort stringArray sort fields\rDescription Get references of a component version. References are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry With the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json tree wide yaml See Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":73,"permalink":"/docs/reference/ocm-cli/get/references/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get references [\u0026lt;options\u0026gt;]  \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -c, --constraints constraints   version constraint\n  -h, --help                      help for references\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -o, --output string             output mode (JSON, json, tree, wide, yaml)\n  -r, --recursive                 follow component reference nesting\n      --repo string               repository name or spec\n  -s, --sort stringArray          sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet references of a component version. References are specified\nby identities. An identity consists of\na name argument followed by optional \u003ccode\u003e\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\u003c/code\u003e\narguments.\u003c/p\u003e","tags":[],"title":"references"},{"content":"Usage ocm add resource-configuration [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;configfile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\rOptions --access YAML blob access specification (YAML) --accessComponent string component for access specification --accessHostname string hostname used for access --accessRepository string repository or registry URL --accessType string type of blob access specification --accessVersion string version for access specification --artifactId string maven artifact id --body string body of a http request --bucket string bucket name --classifier string maven classifier --commit string git commit id --digest string blob digest --extension string maven extension name --external flag non-local resource --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; resource extra identity (default []) --globalAccess YAML access specification for global access --groupId string maven group id --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,... http headers (default {}) -h, --help help for resource-configuration --hint string (repository) hint for local artifacts --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;} identity path for specification --input YAML blob input specification (YAML) --inputComponent string component name --inputCompress compress option for input --inputData !bytesBase64 data (string, !!string or !\u0026lt;base64\u0026gt; --inputExcludes stringArray excludes (path) for inputs --inputFollowSymlinks follow symbolic links during archive creation for inputs --inputFormattedJson YAML JSON formatted text --inputHelmRepository string helm repository base URL --inputIncludes stringArray includes (path) for inputs --inputJson YAML JSON formatted text --inputLibraries stringArray library path for inputs --inputPath filepath path field for input --inputPlatforms stringArray input filter for image platforms ([os]/[architecture]) --inputPreserveDir preserve directory in archive for inputs --inputRepository string repository or registry for inputs --inputText string utf8 text --inputType string type of blob input specification --inputValues YAML YAML based generic values for inputs --inputVariants stringArray (platform) variants for inputs --inputVersion string version info for inputs --inputYaml YAML YAML formatted text --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt; resource label (leading * indicates signature relevant, optional version separated by @) --mediaType string media type for artifact blob representation --name string resource name --noredirect http redirect behavior --package string package or object name --reference string reference name --region string region name --resource YAML resource meta data (yaml) -s, --settings stringArray settings file with variable settings (yaml) --size int blob size --type string resource type --url string artifact or server url --verb string http request method --version string resource version\rDescription Add a resource specification to a resource config file used by ocm add resources.\nIt is possible to describe a single resource via command line options. The meta data of this element is described by the argument of option \u0026ndash;resource, which must be a YAML or JSON string. Alternatively, the name and version can be specified with the options \u0026ndash;name and \u0026ndash;version. With the option \u0026ndash;extra it is possible to add extra identity attributes. Explicitly specified options override values specified by the \u0026ndash;resource option. (Note: Go templates are not supported for YAML-based option values. Besides this restriction, the finally composed element description is still processed by the selected template engine.)\nThe resource type can be specified with the option \u0026ndash;type. Therefore, the minimal required meta data for elements can be completely specified by dedicated options and don\u0026rsquo;t need the YAML option.\nTo describe the content of this element one of the options \u0026ndash;access or \u0026ndash;input must be given. They take a YAML or JSON value describing an attribute set, also. The structure of those values is similar to the access or input fields of the description file format. Non-local resources can be indicated using the option \u0026ndash;external. Elements must follow the resource meta data description scheme of the component descriptor.\nIf expressions/templates are used in the specification file an appropriate templater and the required settings might be required to provide a correct input validation.\nThis command accepts additional resource specification files describing the sources to add to a component version.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" The resource specification supports the following blob input types, specified with the field type in the input field:\nInput type binary\nThis blob type is used to provide base64 encoded binary content. The specification supports the following fields:\ndata []byte\nThe binary data to provide.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputData, \u0026ndash;mediaType\nInput type dir\nThe path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no includes are specified all file not explicitly excluded are used.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to directory relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the file content should be stored compressed or not.\npreserveDir bool\nThis OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.\nfollowSymlinks bool\nThis OPTIONAL property describes whether symbolic links should be followed or included as links.\nexcludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.\nincludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputExcludes, \u0026ndash;inputFollowSymlinks, \u0026ndash;inputIncludes, \u0026ndash;inputPath, \u0026ndash;inputPreserveDir, \u0026ndash;mediaType\nInput type docker\nThe path must denote an image tag that can be found in the local docker daemon. The denoted image is packed as OCI artifact set. The OCI image will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the image name to import from the local docker daemon.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputPath\nInput type dockermulti\nThis input type describes the composition of a multi-platform OCI image. The various variants are taken from the local docker daemon. They should be built with the \u0026ldquo;buildx\u0026rdquo; command for cross platform docker builds (see https://ocm.software/docs/tutorials/best-practices/#building-multi-architecture-images). The denoted images, as well as the wrapping image index, are packed as OCI artifact set. They will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\nvariants []string\nThis REQUIRED property describes a set of image names to import from the local docker daemon used to compose a resulting image index.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputVariants\nInput type file\nThe path must denote a file relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;mediaType\nInput type git\nThe repository type allows accessing an arbitrary git repository using the manifest annotation software.ocm/component-version. The ref can be used to further specify the branch or tag to checkout, otherwise the remote HEAD is used.\nThis blob type specification supports the following fields:\nrepository string\nThis REQUIRED property describes the URL of the git repository to access. All git URL formats are supported.\nref string\nThis OPTIONAL property can be used to specify the remote branch or tag to checkout (commonly called ref). If not set, the default HEAD (remotes/origin/HEAD) of the remote is used.\ncommit string\nThis OPTIONAL property can be used to specify the commit hash to checkout. If not set, the default HEAD of the ref is used.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type helm\nThe path must denote an helm chart archive or directory relative to the resources file or a chart name in a helm chart repository. The denoted chart is packed as an OCI artifact set. For the filesystem version additional provider info is taken from a file with the same name and the suffix .prov.\nIf the chart should just be stored as plain archive, please use the type file or dir, instead.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to the helm chart relative to the resource file location.\nversion string\nThis OPTIONAL property can be set to configure an explicit version hint. If not specified the version from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.\nhelmRepository string\nThis OPTIONAL property can be set, if the helm chart should be loaded from a helm repository instead of the local filesystem. It describes the base URL of the chart repository. If specified, the path field must describe the name of the chart in the chart repository, and version must describe the version of the chart imported from the chart repository\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\ncaCertFile string\nThis OPTIONAL property can be used to specify a relative filename for the TLS root certificate used to access a helm repository.\ncaCert string\nThis OPTIONAL property can be used to specify a TLS root certificate used to access a helm repository.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputHelmRepository, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;mediaType\nInput type maven\nThe repoUrl is the url pointing either to the http endpoint of a maven repository (e.g. https://repo.maven.apache.org/maven2/) or to a file system based maven repository (e.g. file://local/directory).\nThis blob type specification supports the following fields:\nrepoUrl string\nThis REQUIRED property describes the url from which the resource is to be accessed.\ngroupId string\nThis REQUIRED property describes the groupId of a maven artifact.\nartifactId string\nThis REQUIRED property describes artifactId of a maven artifact.\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nclassifier string\nThis OPTIONAL property describes the classifier of a maven artifact.\nextension string\nThis OPTIONAL property describes the extension of a maven artifact.\nOptions used to configure fields: \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;url\nInput type npm\nThe registry is the url pointing to the npm registry from which a resource is downloaded.\nThis blob type specification supports the following fields:\nregistry string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\npackage string\nThis REQUIRED property describes the name of the package to download.\nversion string\nThis is an OPTIONAL property describing the version of the package to download. If not defined, latest will be used automatically.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion, \u0026ndash;package\nInput type ociArtifact\nThis input type is used to import an OCI image from an OCI registry. If it is a multi-arch image the set of platforms to be imported can be filtered using the \u0026ldquo;platforms\u0026rdquo; attribute. The path must denote an OCI image reference.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the OCI image reference of the image to import.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nplatforms []string\nThis OPTIONAL property can be used to filter index artifacts to include only images for dedicated operating systems/architectures. Elements must meet the syntax [\u0026lt;os\u0026gt;]/[\u0026lt;architecture\u0026gt;].\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ociImage\nDEPRECATED: This type is deprecated, please use ociArtifact instead.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ocm\nThis input type allows to get a resource artifact from an OCM repository.\nThis blob type specification supports the following fields:\nocmRepository repository specification\nThis REQUIRED property describes the OCM repository specification\ncomponent string\nThis REQUIRED property describes the component na,e\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nresourceRef relative resource reference\nThis REQUIRED property describes the resource reference for the desired resource relative to the given component version .\nOptions used to configure fields: \u0026ndash;identityPath, \u0026ndash;inputComponent, \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type spiff\nThe path must denote a spiff template relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nvalues map[string]any\nThis OPTIONAL property describes an additional value binding for the template processing. It will be available under the node inputvalues.\nlibraries []string\nThis OPTIONAL property describes a list of spiff libraries to include in template processing.\nThe variable settings from the command line are available as binding, also. They are provided under the node values.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputLibraries, \u0026ndash;inputPath, \u0026ndash;inputValues, \u0026ndash;mediaType\nInput type utf8\nThis blob type is used to provide inline text based content (UTF8). The specification supports the following fields:\ntext string\nThe utf8 string content to provide.\njson JSON or JSON string interpreted as JSON\nThe content emitted as JSON.\nformattedJson YAML/JSON or JSON/YAML string interpreted as JSON\nThe content emitted as formatted JSON.\nyaml AML/JSON or JSON/YAML string interpreted as YAML\nThe content emitted as YAML.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputFormattedJson, \u0026ndash;inputJson, \u0026ndash;inputText, \u0026ndash;inputYaml, \u0026ndash;mediaType\nInput type wget\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string\nThis OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string\nThis OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string\nThis OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte\nThis OPTIONAL property describes the http body to be included in the request.\nnoredirect bool\nThis OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nThe following list describes the supported access methods, their versions and specification formats. Typically there is special support for the CLI artifact add commands. The access method specification can be put below the access field. If always requires the field type describing the kind and version shown below.\nAccess type git\nThis method implements the access of the content of a git commit stored in a Git repository.\nThe following versions are supported:\nVersion v1alpha1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;commit, \u0026ndash;reference\nAccess type gitHub\nThis method implements the access of the content of a git commit stored in a GitHub repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessHostname, \u0026ndash;accessRepository, \u0026ndash;commit\nAccess type helm\nThis method implements the access of a Helm chart stored in a Helm repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nhelmRepository string\nHelm repository URL.\nhelmChart string\nThe name of the Helm chart and its version separated by a colon.\nversion string\nThe version of the Helm chart if not specified as part of the chart name.\ncaCert string\nAn optional TLS root certificate.\nkeyring string\nAn optional keyring used to verify the chart.\nIt uses the consumer identity type HelmChartRepository with the fields for a hostpath identity matcher (see ocm get credentials).\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type localBlob\nThis method is used to store a resource blob along with the component descriptor on behalf of the hosting OCM repository.\nIts implementation is specific to the implementation of OCM repository used to read the component descriptor. Every repository implementation may decide how and where local blobs are stored, but it MUST provide an implementation for this method.\nRegardless of the chosen implementation the attribute specification is defined globally the same.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nlocalReference string\nRepository type specific location information as string. The value may encode any deep structure, but typically just an access path is sufficient.\nmediaType string\nThe media type of the blob used to store the resource. It may add format information like +tar or +gzip.\nreferenceName (optional) string\nThis optional attribute may contain identity information used by other repositories to restore some global access with an identity related to the original source.\nFor example, if an OCI artifact originally referenced using the access method ociArtifact is stored during some transport step as local artifact, the reference name can be set to its original repository name. An import step into an OCI based OCM repository may then decide to make this artifact available again as regular OCI artifact.\nglobalAccess (optional) access method specification\nIf a resource blob is stored locally, the repository implementation may decide to provide an external access information (independent of the OCM model).\nFor example, an OCI artifact stored as local blob can be additionally stored as regular OCI artifact in an OCI registry.\nThis additional external access information can be added using a second external access method specification.\nOptions used to configure fields: \u0026ndash;globalAccess, \u0026ndash;hint, \u0026ndash;mediaType, \u0026ndash;reference\nAccess type maven\nThis method implements the access of a Maven artifact in a Maven repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nURL of the Maven repository\ngroupId string\nThe groupId of the Maven artifact\nartifactId string\nThe artifactId of the Maven artifact\nversion string\nThe version name of the Maven artifact\nclassifier string\nThe optional classifier of the Maven artifact\nextension string\nThe optional extension of the Maven artifact\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId\nAccess type none\ndummy resource with no access\nAccess type npm\nThis method implements the access of an NPM package in an NPM registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregistry string\nBase URL of the NPM registry.\npackage string\nThe name of the NPM package\nversion string\nThe version name of the NPM package\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type ociArtifact\nThis method implements the access of an OCI artifact stored in an OCI registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI image/artifact reference following the possible docker schemes:\n\u0026lt;repo\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;digest\u0026gt;@\u0026lt;tag\u0026gt; [\u0026lt;port\u0026gt;]/\u0026lt;repo path\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;version\u0026gt;@\u0026lt;tag\u0026gt; Options used to configure fields: \u0026ndash;reference\nAccess type ociBlob\nThis method implements the access of an OCI blob stored in an OCI repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI repository reference (this artifact name used to store the blob).\nmediaType string\nThe media type of the blob\ndigest string\nThe digest of the blob used to access the blob in the OCI repository.\nsize integer\nThe size of the blob\nOptions used to configure fields: \u0026ndash;digest, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;size\nAccess type ocm\nThis method implements the access of any resource artifact stored in an OCM repository. Only repository types supporting remote access should be used.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nocmRepository json\nThe repository spec for the OCM repository\ncomponent string\n(Optional) The name of the component. The default is the own component.\nversion string\n(Optional) The version of the component. The default is the own component version.\nresourceRef relative resource ref\nThe resource reference of the denoted resource relative to the given component version.\nIt uses the consumer identity and credentials for the intermediate repositories and the final resource access.\nOptions used to configure fields: \u0026ndash;accessComponent, \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;identityPath\nAccess type s3\nThis method implements the access of a blob stored in an S3 bucket.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucket string\nThe name of the S3 bucket containing the blob\nkey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nVersion v2\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucketName string\nThe name of the S3 bucket containing the blob\nobjectKey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nOptions used to configure fields: \u0026ndash;accessVersion, \u0026ndash;bucket, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;region\nAccess type wget\nThis method implements access to resources stored on an http server.\nThe following versions are supported:\nVersion v1\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string This REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string This OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string This OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string This OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte This OPTIONAL property describes the http body to be included in the request.\nnoredirect bool This OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" Examples $ ocm add resource-configuration resources.yaml --name myresource --type PlainText --input \u0026#39;{ \u0026#34;type\u0026#34;: \u0026#34;file\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;testdata/testcontent\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;text/plain\u0026#34; }\u0026#39;\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":74,"permalink":"/docs/reference/ocm-cli/add/resource-configuration/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add resource-configuration [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;configfile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --access YAML                         blob access specification (YAML)\n      --accessComponent string              component for access specification\n      --accessHostname string               hostname used for access\n      --accessRepository string             repository or registry URL\n      --accessType string                   type of blob access specification\n      --accessVersion string                version for access specification\n      --artifactId string                   maven artifact id\n      --body string                         body of a http request\n      --bucket string                       bucket name\n      --classifier string                   maven classifier\n      --commit string                       git commit id\n      --digest string                       blob digest\n      --extension string                    maven extension name\n      --external                            flag non-local resource\n      --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;                resource extra identity (default [])\n      --globalAccess YAML                   access specification for global access\n      --groupId string                      maven group id\n      --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,...   http headers (default {})\n  -h, --help                                help for resource-configuration\n      --hint string                         (repository) hint for local artifacts\n      --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;}       identity path for specification\n      --input YAML                          blob input specification (YAML)\n      --inputComponent string               component name\n      --inputCompress                       compress option for input\n      --inputData !bytesBase64              data (string, !!string or !\u0026lt;base64\u0026gt;\n      --inputExcludes stringArray           excludes (path) for inputs\n      --inputFollowSymlinks                 follow symbolic links during archive creation for inputs\n      --inputFormattedJson YAML             JSON formatted text\n      --inputHelmRepository string          helm repository base URL\n      --inputIncludes stringArray           includes (path) for inputs\n      --inputJson YAML                      JSON formatted text\n      --inputLibraries stringArray          library path for inputs\n      --inputPath filepath                  path field for input\n      --inputPlatforms stringArray          input filter for image platforms ([os]/[architecture])\n      --inputPreserveDir                    preserve directory in archive for inputs\n      --inputRepository string              repository or registry for inputs\n      --inputText string                    utf8 text\n      --inputType string                    type of blob input specification\n      --inputValues YAML                    YAML based generic values for inputs\n      --inputVariants stringArray           (platform) variants for inputs\n      --inputVersion string                 version info for inputs\n      --inputYaml YAML                      YAML formatted text\n      --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt;                 resource label (leading * indicates signature relevant, optional version separated by @)\n      --mediaType string                    media type for artifact blob representation\n      --name string                         resource name\n      --noredirect                          http redirect behavior\n      --package string                      package or object name\n      --reference string                    reference name\n      --region string                       region name\n      --resource YAML                       resource meta data (yaml)\n  -s, --settings stringArray                settings file with variable settings (yaml)\n      --size int                            blob size\n      --type string                         resource type\n      --url string                          artifact or server url\n      --verb string                         http request method\n      --version string                      resource version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdd a resource specification to a resource config file used by \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/resources/\"\u003eocm add resources\u003c/a\u003e.\u003c/p\u003e","tags":[],"title":"resource-configuration"},{"content":"Usage ocm add resources [\u0026lt;options\u0026gt;] [\u0026lt;target\u0026gt;] {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\rOptions --access YAML blob access specification (YAML) --accessComponent string component for access specification --accessHostname string hostname used for access --accessRepository string repository or registry URL --accessType string type of blob access specification --accessVersion string version for access specification --addenv access environment for templating --artifactId string maven artifact id --body string body of a http request --bucket string bucket name --classifier string maven classifier --commit string git commit id --digest string blob digest --dry-run evaluate and print resource specifications --extension string maven extension name --external flag non-local resource --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; resource extra identity (default []) -F, --file string target file/directory (default \u0026#34;component-archive\u0026#34;) --globalAccess YAML access specification for global access --groupId string maven group id --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,... http headers (default {}) -h, --help help for resources --hint string (repository) hint for local artifacts --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;} identity path for specification --input YAML blob input specification (YAML) --inputComponent string component name --inputCompress compress option for input --inputData !bytesBase64 data (string, !!string or !\u0026lt;base64\u0026gt; --inputExcludes stringArray excludes (path) for inputs --inputFollowSymlinks follow symbolic links during archive creation for inputs --inputFormattedJson YAML JSON formatted text --inputHelmRepository string helm repository base URL --inputIncludes stringArray includes (path) for inputs --inputJson YAML JSON formatted text --inputLibraries stringArray library path for inputs --inputPath filepath path field for input --inputPlatforms stringArray input filter for image platforms ([os]/[architecture]) --inputPreserveDir preserve directory in archive for inputs --inputRepository string repository or registry for inputs --inputText string utf8 text --inputType string type of blob input specification --inputValues YAML YAML based generic values for inputs --inputVariants stringArray (platform) variants for inputs --inputVersion string version info for inputs --inputYaml YAML YAML formatted text --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt; resource label (leading * indicates signature relevant, optional version separated by @) --mediaType string media type for artifact blob representation --name string resource name --noredirect http redirect behavior -O, --output string output file for dry-run --package string package or object name -P, --preserve-signature preserve existing signatures --reference string reference name --region string region name -R, --replace replace existing elements --resource YAML resource meta data (yaml) -s, --settings stringArray settings file with variable settings (yaml) --size int blob size --skip-digest-generation skip digest creation --templater string templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;) --type string resource type --url string artifact or server url --verb string http request method --version string resource version\rDescription Adds resources specified in a resource file to a component version. So far, only component archives are supported as target.\nThis command accepts resource specification files describing the resources to add to a component version. Elements must follow the resource meta data description scheme of the component descriptor. Besides referential resources using the access attribute to describe the access method, it is possible to describe local resources fed by local data using the input field (see below).\nThe description file might contain:\na single resource a list of resources under the key resources a list of yaml documents with a single resource or resource list It is possible to describe a single resource via command line options. The meta data of this element is described by the argument of option \u0026ndash;resource, which must be a YAML or JSON string. Alternatively, the name and version can be specified with the options \u0026ndash;name and \u0026ndash;version. With the option \u0026ndash;extra it is possible to add extra identity attributes. Explicitly specified options override values specified by the \u0026ndash;resource option. (Note: Go templates are not supported for YAML-based option values. Besides this restriction, the finally composed element description is still processed by the selected template engine.)\nThe resource type can be specified with the option \u0026ndash;type. Therefore, the minimal required meta data for elements can be completely specified by dedicated options and don\u0026rsquo;t need the YAML option.\nTo describe the content of this element one of the options \u0026ndash;access or \u0026ndash;input must be given. They take a YAML or JSON value describing an attribute set, also. The structure of those values is similar to the access or input fields of the description file format. Non-local resources can be indicated using the option \u0026ndash;external.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" The resource specification supports the following blob input types, specified with the field type in the input field:\nInput type binary\nThis blob type is used to provide base64 encoded binary content. The specification supports the following fields:\ndata []byte\nThe binary data to provide.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputData, \u0026ndash;mediaType\nInput type dir\nThe path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no includes are specified all file not explicitly excluded are used.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to directory relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the file content should be stored compressed or not.\npreserveDir bool\nThis OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.\nfollowSymlinks bool\nThis OPTIONAL property describes whether symbolic links should be followed or included as links.\nexcludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.\nincludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputExcludes, \u0026ndash;inputFollowSymlinks, \u0026ndash;inputIncludes, \u0026ndash;inputPath, \u0026ndash;inputPreserveDir, \u0026ndash;mediaType\nInput type docker\nThe path must denote an image tag that can be found in the local docker daemon. The denoted image is packed as OCI artifact set. The OCI image will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the image name to import from the local docker daemon.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputPath\nInput type dockermulti\nThis input type describes the composition of a multi-platform OCI image. The various variants are taken from the local docker daemon. They should be built with the \u0026ldquo;buildx\u0026rdquo; command for cross platform docker builds (see https://ocm.software/docs/tutorials/best-practices/#building-multi-architecture-images). The denoted images, as well as the wrapping image index, are packed as OCI artifact set. They will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\nvariants []string\nThis REQUIRED property describes a set of image names to import from the local docker daemon used to compose a resulting image index.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputVariants\nInput type file\nThe path must denote a file relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;mediaType\nInput type git\nThe repository type allows accessing an arbitrary git repository using the manifest annotation software.ocm/component-version. The ref can be used to further specify the branch or tag to checkout, otherwise the remote HEAD is used.\nThis blob type specification supports the following fields:\nrepository string\nThis REQUIRED property describes the URL of the git repository to access. All git URL formats are supported.\nref string\nThis OPTIONAL property can be used to specify the remote branch or tag to checkout (commonly called ref). If not set, the default HEAD (remotes/origin/HEAD) of the remote is used.\ncommit string\nThis OPTIONAL property can be used to specify the commit hash to checkout. If not set, the default HEAD of the ref is used.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type helm\nThe path must denote an helm chart archive or directory relative to the resources file or a chart name in a helm chart repository. The denoted chart is packed as an OCI artifact set. For the filesystem version additional provider info is taken from a file with the same name and the suffix .prov.\nIf the chart should just be stored as plain archive, please use the type file or dir, instead.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to the helm chart relative to the resource file location.\nversion string\nThis OPTIONAL property can be set to configure an explicit version hint. If not specified the version from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.\nhelmRepository string\nThis OPTIONAL property can be set, if the helm chart should be loaded from a helm repository instead of the local filesystem. It describes the base URL of the chart repository. If specified, the path field must describe the name of the chart in the chart repository, and version must describe the version of the chart imported from the chart repository\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\ncaCertFile string\nThis OPTIONAL property can be used to specify a relative filename for the TLS root certificate used to access a helm repository.\ncaCert string\nThis OPTIONAL property can be used to specify a TLS root certificate used to access a helm repository.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputHelmRepository, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;mediaType\nInput type maven\nThe repoUrl is the url pointing either to the http endpoint of a maven repository (e.g. https://repo.maven.apache.org/maven2/) or to a file system based maven repository (e.g. file://local/directory).\nThis blob type specification supports the following fields:\nrepoUrl string\nThis REQUIRED property describes the url from which the resource is to be accessed.\ngroupId string\nThis REQUIRED property describes the groupId of a maven artifact.\nartifactId string\nThis REQUIRED property describes artifactId of a maven artifact.\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nclassifier string\nThis OPTIONAL property describes the classifier of a maven artifact.\nextension string\nThis OPTIONAL property describes the extension of a maven artifact.\nOptions used to configure fields: \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;url\nInput type npm\nThe registry is the url pointing to the npm registry from which a resource is downloaded.\nThis blob type specification supports the following fields:\nregistry string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\npackage string\nThis REQUIRED property describes the name of the package to download.\nversion string\nThis is an OPTIONAL property describing the version of the package to download. If not defined, latest will be used automatically.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion, \u0026ndash;package\nInput type ociArtifact\nThis input type is used to import an OCI image from an OCI registry. If it is a multi-arch image the set of platforms to be imported can be filtered using the \u0026ldquo;platforms\u0026rdquo; attribute. The path must denote an OCI image reference.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the OCI image reference of the image to import.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nplatforms []string\nThis OPTIONAL property can be used to filter index artifacts to include only images for dedicated operating systems/architectures. Elements must meet the syntax [\u0026lt;os\u0026gt;]/[\u0026lt;architecture\u0026gt;].\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ociImage\nDEPRECATED: This type is deprecated, please use ociArtifact instead.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ocm\nThis input type allows to get a resource artifact from an OCM repository.\nThis blob type specification supports the following fields:\nocmRepository repository specification\nThis REQUIRED property describes the OCM repository specification\ncomponent string\nThis REQUIRED property describes the component na,e\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nresourceRef relative resource reference\nThis REQUIRED property describes the resource reference for the desired resource relative to the given component version .\nOptions used to configure fields: \u0026ndash;identityPath, \u0026ndash;inputComponent, \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type spiff\nThe path must denote a spiff template relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nvalues map[string]any\nThis OPTIONAL property describes an additional value binding for the template processing. It will be available under the node inputvalues.\nlibraries []string\nThis OPTIONAL property describes a list of spiff libraries to include in template processing.\nThe variable settings from the command line are available as binding, also. They are provided under the node values.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputLibraries, \u0026ndash;inputPath, \u0026ndash;inputValues, \u0026ndash;mediaType\nInput type utf8\nThis blob type is used to provide inline text based content (UTF8). The specification supports the following fields:\ntext string\nThe utf8 string content to provide.\njson JSON or JSON string interpreted as JSON\nThe content emitted as JSON.\nformattedJson YAML/JSON or JSON/YAML string interpreted as JSON\nThe content emitted as formatted JSON.\nyaml AML/JSON or JSON/YAML string interpreted as YAML\nThe content emitted as YAML.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputFormattedJson, \u0026ndash;inputJson, \u0026ndash;inputText, \u0026ndash;inputYaml, \u0026ndash;mediaType\nInput type wget\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string\nThis OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string\nThis OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string\nThis OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte\nThis OPTIONAL property describes the http body to be included in the request.\nnoredirect bool\nThis OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nThe following list describes the supported access methods, their versions and specification formats. Typically there is special support for the CLI artifact add commands. The access method specification can be put below the access field. If always requires the field type describing the kind and version shown below.\nAccess type git\nThis method implements the access of the content of a git commit stored in a Git repository.\nThe following versions are supported:\nVersion v1alpha1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;commit, \u0026ndash;reference\nAccess type gitHub\nThis method implements the access of the content of a git commit stored in a GitHub repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessHostname, \u0026ndash;accessRepository, \u0026ndash;commit\nAccess type helm\nThis method implements the access of a Helm chart stored in a Helm repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nhelmRepository string\nHelm repository URL.\nhelmChart string\nThe name of the Helm chart and its version separated by a colon.\nversion string\nThe version of the Helm chart if not specified as part of the chart name.\ncaCert string\nAn optional TLS root certificate.\nkeyring string\nAn optional keyring used to verify the chart.\nIt uses the consumer identity type HelmChartRepository with the fields for a hostpath identity matcher (see ocm get credentials).\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type localBlob\nThis method is used to store a resource blob along with the component descriptor on behalf of the hosting OCM repository.\nIts implementation is specific to the implementation of OCM repository used to read the component descriptor. Every repository implementation may decide how and where local blobs are stored, but it MUST provide an implementation for this method.\nRegardless of the chosen implementation the attribute specification is defined globally the same.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nlocalReference string\nRepository type specific location information as string. The value may encode any deep structure, but typically just an access path is sufficient.\nmediaType string\nThe media type of the blob used to store the resource. It may add format information like +tar or +gzip.\nreferenceName (optional) string\nThis optional attribute may contain identity information used by other repositories to restore some global access with an identity related to the original source.\nFor example, if an OCI artifact originally referenced using the access method ociArtifact is stored during some transport step as local artifact, the reference name can be set to its original repository name. An import step into an OCI based OCM repository may then decide to make this artifact available again as regular OCI artifact.\nglobalAccess (optional) access method specification\nIf a resource blob is stored locally, the repository implementation may decide to provide an external access information (independent of the OCM model).\nFor example, an OCI artifact stored as local blob can be additionally stored as regular OCI artifact in an OCI registry.\nThis additional external access information can be added using a second external access method specification.\nOptions used to configure fields: \u0026ndash;globalAccess, \u0026ndash;hint, \u0026ndash;mediaType, \u0026ndash;reference\nAccess type maven\nThis method implements the access of a Maven artifact in a Maven repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nURL of the Maven repository\ngroupId string\nThe groupId of the Maven artifact\nartifactId string\nThe artifactId of the Maven artifact\nversion string\nThe version name of the Maven artifact\nclassifier string\nThe optional classifier of the Maven artifact\nextension string\nThe optional extension of the Maven artifact\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId\nAccess type none\ndummy resource with no access\nAccess type npm\nThis method implements the access of an NPM package in an NPM registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregistry string\nBase URL of the NPM registry.\npackage string\nThe name of the NPM package\nversion string\nThe version name of the NPM package\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type ociArtifact\nThis method implements the access of an OCI artifact stored in an OCI registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI image/artifact reference following the possible docker schemes:\n\u0026lt;repo\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;digest\u0026gt;@\u0026lt;tag\u0026gt; [\u0026lt;port\u0026gt;]/\u0026lt;repo path\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;version\u0026gt;@\u0026lt;tag\u0026gt; Options used to configure fields: \u0026ndash;reference\nAccess type ociBlob\nThis method implements the access of an OCI blob stored in an OCI repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI repository reference (this artifact name used to store the blob).\nmediaType string\nThe media type of the blob\ndigest string\nThe digest of the blob used to access the blob in the OCI repository.\nsize integer\nThe size of the blob\nOptions used to configure fields: \u0026ndash;digest, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;size\nAccess type ocm\nThis method implements the access of any resource artifact stored in an OCM repository. Only repository types supporting remote access should be used.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nocmRepository json\nThe repository spec for the OCM repository\ncomponent string\n(Optional) The name of the component. The default is the own component.\nversion string\n(Optional) The version of the component. The default is the own component version.\nresourceRef relative resource ref\nThe resource reference of the denoted resource relative to the given component version.\nIt uses the consumer identity and credentials for the intermediate repositories and the final resource access.\nOptions used to configure fields: \u0026ndash;accessComponent, \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;identityPath\nAccess type s3\nThis method implements the access of a blob stored in an S3 bucket.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucket string\nThe name of the S3 bucket containing the blob\nkey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nVersion v2\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucketName string\nThe name of the S3 bucket containing the blob\nobjectKey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nOptions used to configure fields: \u0026ndash;accessVersion, \u0026ndash;bucket, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;region\nAccess type wget\nThis method implements access to resources stored on an http server.\nThe following versions are supported:\nVersion v1\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string This REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string This OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string This OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string This OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte This OPTIONAL property describes the http body to be included in the request.\nnoredirect bool This OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nThe \u0026ndash;replace option allows users to specify whether adding an element with the same name and extra identity but different version as an existing element, append (false) or replace (true) the existing element.\nThe \u0026ndash;preserve-signature option prohibits changes of signature relevant elements.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" Examples Add a resource directly by options $ ocm add resources --file path/to/ca --name myresource --type PlainText --input \u0026#39;{ \u0026#34;type\u0026#34;: \u0026#34;file\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;testdata/testcontent\u0026#34;, \u0026#34;mediaType\u0026#34;: \u0026#34;text/plain\u0026#34; }\u0026#39; Add a resource by a description file: *resources.yaml*: --- name: myrresource type: plainText version: ${version] input: type: file path: testdata/testcontent mediaType: text/plain $ ocm add resources --file path/to/ca resources.yaml VERSION=1.0.0\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":75,"permalink":"/docs/reference/ocm-cli/add/resources/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add resources [\u0026lt;options\u0026gt;] [\u0026lt;target\u0026gt;] {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --access YAML                         blob access specification (YAML)\n      --accessComponent string              component for access specification\n      --accessHostname string               hostname used for access\n      --accessRepository string             repository or registry URL\n      --accessType string                   type of blob access specification\n      --accessVersion string                version for access specification\n      --addenv                              access environment for templating\n      --artifactId string                   maven artifact id\n      --body string                         body of a http request\n      --bucket string                       bucket name\n      --classifier string                   maven classifier\n      --commit string                       git commit id\n      --digest string                       blob digest\n      --dry-run                             evaluate and print resource specifications\n      --extension string                    maven extension name\n      --external                            flag non-local resource\n      --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;                resource extra identity (default [])\n  -F, --file string                         target file/directory (default \u0026#34;component-archive\u0026#34;)\n      --globalAccess YAML                   access specification for global access\n      --groupId string                      maven group id\n      --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,...   http headers (default {})\n  -h, --help                                help for resources\n      --hint string                         (repository) hint for local artifacts\n      --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;}       identity path for specification\n      --input YAML                          blob input specification (YAML)\n      --inputComponent string               component name\n      --inputCompress                       compress option for input\n      --inputData !bytesBase64              data (string, !!string or !\u0026lt;base64\u0026gt;\n      --inputExcludes stringArray           excludes (path) for inputs\n      --inputFollowSymlinks                 follow symbolic links during archive creation for inputs\n      --inputFormattedJson YAML             JSON formatted text\n      --inputHelmRepository string          helm repository base URL\n      --inputIncludes stringArray           includes (path) for inputs\n      --inputJson YAML                      JSON formatted text\n      --inputLibraries stringArray          library path for inputs\n      --inputPath filepath                  path field for input\n      --inputPlatforms stringArray          input filter for image platforms ([os]/[architecture])\n      --inputPreserveDir                    preserve directory in archive for inputs\n      --inputRepository string              repository or registry for inputs\n      --inputText string                    utf8 text\n      --inputType string                    type of blob input specification\n      --inputValues YAML                    YAML based generic values for inputs\n      --inputVariants stringArray           (platform) variants for inputs\n      --inputVersion string                 version info for inputs\n      --inputYaml YAML                      YAML formatted text\n      --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt;                 resource label (leading * indicates signature relevant, optional version separated by @)\n      --mediaType string                    media type for artifact blob representation\n      --name string                         resource name\n      --noredirect                          http redirect behavior\n  -O, --output string                       output file for dry-run\n      --package string                      package or object name\n  -P, --preserve-signature                  preserve existing signatures\n      --reference string                    reference name\n      --region string                       region name\n  -R, --replace                             replace existing elements\n      --resource YAML                       resource meta data (yaml)\n  -s, --settings stringArray                settings file with variable settings (yaml)\n      --size int                            blob size\n      --skip-digest-generation              skip digest creation\n      --templater string                    templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;)\n      --type string                         resource type\n      --url string                          artifact or server url\n      --verb string                         http request method\n      --version string                      resource version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdds resources specified in a resource file to a component version.\nSo far, only component archives are supported as target.\u003c/p\u003e","tags":[],"title":"resources"},{"content":"Usage ocm download resources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\rOptions --check-verified enable verification store -c, --constraints constraints version constraint -d, --download-handlers use download handler if possible --downloader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; artifact downloader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default []) -x, --executable download executable for local platform -h, --help help for resources --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -O, --outfile string output file or directory -r, --recursive follow component reference nesting --repo string repository name or spec -t, --type stringArray resource type filter --verified string file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;) --verify verify downloads\rDescription Download resources of a component version. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.\nThe option -O is used to declare the output destination. For a single resource to download, this is the file written for the resource blob. If multiple resources are selected, a directory structure is written into the given directory for every involved component version as follows:\n\u0026lt;component\u003e/\u0026lt;version\u003e{/\u0026lt;nested component\u003e/\u0026lt;version\u003e} The resource files are named according to the resource identity in the component descriptor. If this identity is just the resource name, this name is used. If additional identity attributes are required, this name is append by a comma separated list of \u0026lt;name\u0026gt;=\u0026lt;\u0026gt;value\u0026gt; pairs separated by a \u0026ldquo;-\u0026rdquo; from the plain name. This attribute list is alphabetical order:\n\u0026lt;resource name\u003e[-[\u0026lt;name\u003e=\u0026lt;\u003evalue\u003e]{,\u0026lt;name\u003e=\u0026lt;\u003evalue\u003e}] If the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry If the \u0026ndash;downloader option is specified, appropriate downloader handlers are configured for the operation. It has the following format\n\u0026lt;name\u003e:\u0026lt;artifact type\u003e:\u0026lt;media type\u003e=\u0026lt;yaml target config\u003e The downloader name may be a path expression with the following possibilities:\nhelm/artifact: download helm chart resources\nThe helm downloader is able to download helm chart resources as helm chart packages. Thus, the downloader may perform transformations. For example, if the helm chart is currently stored as an oci artifact, the downloader performs the necessary extraction to provide the helm chart package from within that oci artifact.\nThe following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar+gzip application/vnd.cncf.helm.chart.content.v1.tar+gzip It accepts no config.\nlandscaper/blueprint: uploading an OCI artifact to an OCI registry\nThe artifact downloader is able to transfer OCI artifact-like resources into an OCI registry given by the combination of the download target and the registration config.\nIf no config is given, the target must be an OCI reference with a potentially omitted repository. The repo part is derived from the reference hint provided by the resource\u0026rsquo;s access specification.\nIf the config is given, the target is used as repository name prefixed with an optional repository prefix given by the configuration.\nThe following artifact media types are supported:\napplication/vnd.docker.distribution.manifest.v2+tar application/vnd.docker.distribution.manifest.v2+tar+gzip application/vnd.gardener.landscaper.blueprint.layer.v1.tar application/vnd.gardener.landscaper.blueprint.layer.v1.tar+gzip application/vnd.gardener.landscaper.blueprint.v1+tar application/vnd.gardener.landscaper.blueprint.v1+tar+gzip application/vnd.oci.image.manifest.v1+tar application/vnd.oci.image.manifest.v1+tar+gzip application/x-tar application/x-tar+gzip application/x-tgz It accepts a config with the following fields:\nociConfigTypes: a list of accepted OCI config archive mime types defaulted by application/vnd.gardener.landscaper.blueprint.config.v1. This handler is by default registered for the following artifact types: landscaper.gardener.cloud/blueprint,blueprint\noci/artifact: downloading an OCI artifact and optionally re-uploading to an OCI registry\nThe artifact download resources stored as oci artifact. Furthermore, it allows to specify another OCI registry as download destination, thereby, providing a kind of transfer functionality.\nIf no config is given, the target must be an OCI reference with a potentially omitted repository. The repo part is derived from the reference hint provided by the resource\u0026rsquo;s access specification.\nIf the config is given, the target is used as repository name prefixed with an optional repository prefix given by the configuration.\nThe following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar+gzip application/vnd.oci.image.index.v1+tar+gzip It accepts a config with the following fields:\nnamespacePrefix: a namespace prefix used for the uploaded artifacts ociRef: an OCI repository reference repository: an OCI repository specification for the target OCI registry ocm/dirtree: downloading directory tree-like resources\nThe dirtree downloader is able to download directory-tree like resources as directory structure (default) or archive. The following artifact media types are supported:\napplication/vnd.oci.image.manifest.v1+tar+gzip application/x-tgz application/x-tar+gzip application/x-tar By default, it is registered for the following resource types:\ndirectoryTree filesystem It accepts a config with the following fields:\nasArchive: flag to request an archive download ociConfigTypes: a list of accepted OCI config archive mime types defaulted by application/vnd.oci.image.config.v1+json. plugin: [downloaders provided by plugins]\nsub namespace of the form \u0026lt;plugin name\u0026gt;/\u0026lt;handler\u0026gt;\nSee ocm ocm-downloadhandlers for further details on using download handlers.\nThe library supports some downloads with semantics based on resource types. For example a helm chart can be download directly as helm chart archive, even if stored as OCI artifact. This is handled by download handler. Their usage can be enabled with the \u0026ndash;download-handlers option. Otherwise the resource as returned by the access method is stored.\nWith the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nIf the verification store is enabled, resources downloaded from signed or verified component versions are verified against their digests provided by the component version.(not supported for using downloaders for the resource download).\nThe usage of the verification store is enabled by \u0026ndash;check-verified or by specifying a verification file with \u0026ndash;verified.\nSee Also ocm download\t— Download oci artifacts, resources or complete components ","date":"0001-01-01","id":76,"permalink":"/docs/reference/ocm-cli/download/resources/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm download resources [\u0026lt;options\u0026gt;]  \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --check-verified              enable verification store\n  -c, --constraints constraints     version constraint\n  -d, --download-handlers           use download handler if possible\n      --downloader \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;   artifact downloader (\u0026lt;name\u0026gt;[:\u0026lt;artifact type\u0026gt;[:\u0026lt;media type\u0026gt;[:\u0026lt;priority\u0026gt;]]]=\u0026lt;JSON target config\u0026gt;) (default [])\n  -x, --executable                  download executable for local platform\n  -h, --help                        help for resources\n      --latest                      restrict component versions to latest\n      --lookup stringArray          repository name or spec for closure lookup fallback\n  -O, --outfile string              output file or directory\n  -r, --recursive                   follow component reference nesting\n      --repo string                 repository name or spec\n  -t, --type stringArray            resource type filter\n      --verified string             file used to remember verifications for downloads (default \u0026#34;~/.ocm/verified\u0026#34;)\n      --verify                      verify downloads\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eDownload resources of a component version. Resources are specified\nby identities. An identity consists of\na name argument followed by optional \u003ccode\u003e\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\u003c/code\u003e\narguments.\u003c/p\u003e","tags":[],"title":"resources"},{"content":"Usage ocm get resources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\rOptions -c, --constraints constraints version constraint -h, --help help for resources --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, treewide, wide, yaml) -r, --recursive follow component reference nesting --repo string repository name or spec -s, --sort stringArray sort fields\rDescription Get resources of a component version. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry With the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json tree treewide wide yaml See Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":77,"permalink":"/docs/reference/ocm-cli/get/resources/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get resources [\u0026lt;options\u0026gt;]  \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -c, --constraints constraints   version constraint\n  -h, --help                      help for resources\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -o, --output string             output mode (JSON, json, tree, treewide, wide, yaml)\n  -r, --recursive                 follow component reference nesting\n      --repo string               repository name or spec\n  -s, --sort stringArray          sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet resources of a component version. Resources are specified\nby identities. An identity consists of\na name argument followed by optional \u003ccode\u003e\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\u003c/code\u003e\narguments.\u003c/p\u003e","tags":[],"title":"resources"},{"content":"Usage ocm add routingslips [\u0026lt;options\u0026gt;] \u0026lt;component-version\u0026gt; \u0026lt;routing-slip\u0026gt; \u0026lt;type\u0026gt;\rOptions -S, --algorithm string signature handler (default \u0026#34;RSASSA-PKCS1-V1_5\u0026#34;) --comment string comment field value --digest string parent digest to use --entry YAML routing slip entry specification (YAML) -h, --help help for routingslips --links strings links to other slip/entries (\u0026lt;slipname\u0026gt;[@\u0026lt;digest\u0026gt;]) --lookup stringArray repository name or spec for closure lookup fallback --repo string repository name or spec\rDescription Add a routing slip entry for the specified routing slip name to the given component version. The name is typically a DNS domain name followed by some qualifiers separated by a slash (/). It is possible to use arbitrary types, the type is not checked, if it is not known. Accordingly, an arbitrary config given as JSON or YAML can be given to determine the attribute set of the new entry for unknown types.\nThe following list describes the well-known entry types explicitly supported by this version of the CLI, their versions and specification formats. Other kinds of entries can be configured using the \u0026ndash;entry option.\nEntry type comment\nAn unstructured comment as entry in a routing slip.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\ncomment string\nAny text as entry in a routing slip.\nOptions used to configure fields: \u0026ndash;comment\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nExamples $ ocm add routingslip ghcr.io/mandelsoft/ocm//ocmdemoinstaller:0.0.1-dev mandelsoft.org comment --entry \u0026#34;comment=some text\u0026#34;\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":78,"permalink":"/docs/reference/ocm-cli/add/routingslips/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add routingslips [\u0026lt;options\u0026gt;] \u0026lt;component-version\u0026gt; \u0026lt;routing-slip\u0026gt; \u0026lt;type\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -S, --algorithm string     signature handler (default \u0026#34;RSASSA-PKCS1-V1_5\u0026#34;)\n      --comment string       comment field value\n      --digest string        parent digest to use\n      --entry YAML           routing slip entry specification (YAML)\n  -h, --help                 help for routingslips\n      --links strings        links to other slip/entries (\u0026lt;slipname\u0026gt;[@\u0026lt;digest\u0026gt;])\n      --lookup stringArray   repository name or spec for closure lookup fallback\n      --repo string          repository name or spec\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdd a routing slip entry for the specified routing slip name to the given\ncomponent version. The name is typically a DNS domain name followed by some\nqualifiers separated by a slash (/). It is possible to use arbitrary types,\nthe type is not checked, if it is not known. Accordingly, an arbitrary config\ngiven as JSON or YAML can be given to determine the attribute set of the new\nentry for unknown types.\u003c/p\u003e","tags":[],"title":"routingslips"},{"content":"Usage ocm get routingslips [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt;}\rOptions --all-columns show all table columns -c, --constraints constraints version constraint --fail-on-error fail on validation error -h, --help help for routingslips --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, wide, yaml) --repo string repository name or spec -s, --sort stringArray sort fields -v, --verify verify signature\rDescription Get all or the selected routing slips for a component version specification.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json wide yaml See Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":79,"permalink":"/docs/reference/ocm-cli/get/routingslips/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get routingslips [\u0026lt;options\u0026gt;]  \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --all-columns               show all table columns\n  -c, --constraints constraints   version constraint\n      --fail-on-error             fail on validation error\n  -h, --help                      help for routingslips\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -o, --output string             output mode (JSON, json, wide, yaml)\n      --repo string               repository name or spec\n  -s, --sort stringArray          sort fields\n  -v, --verify                    verify signature\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet all or the selected routing slips for a component version specification.\u003c/p\u003e","tags":[],"title":"routingslips"},{"content":"Usage ocm create rsakeypair [\u0026lt;private key file\u0026gt; [\u0026lt;public key file\u0026gt;]] {\u0026lt;subject-attribute\u0026gt;=\u0026lt;value\u0026gt;}\rOptions --ca create certificate for a signing authority --ca-cert string certificate authority to sign public key --ca-key string private key for certificate authority -E, --encrypt encrypt private key with new key -e, --encryptionKey string encrypt private key with given key -h, --help help for rsakeypair --root-certs string root certificates used to validate used certificate authority --validity duration certificate validity (default 87600h0m0s)\rDescription Create an RSA public key pair and save to files.\nThe default for the filename to store the private key is rsa.priv. If no public key file is specified, its name will be derived from the filename for the private key (suffix .pub for public key or .cert for certificate). If a certificate authority is given (\u0026ndash;ca-cert) the public key will be signed. In this case a subject (at least common name/issuer) and a private key (\u0026ndash;ca-key) for the ca used to sign the key is required.\nIf only a subject is given and no ca, the public key will be self-signed. A signed public key always contains the complete certificate chain. If a non-self-signed ca is used to sign the key, its certificate chain is verified. Therefore, an additional root certificate (\u0026ndash;root-certs) is required, if no public root certificate was used to create the used ca.\nFor signing the public key the following subject attributes are supported:\nCN, common-name, issuer: Common Name/Issuer O, organization, org: Organization OU, organizational-unit, org-unit: Organizational Unit STREET (multiple): Street Address POSTALCODE, postal-code (multiple): Postal Code L, locality (multiple): Locality S, province, (multiple): Province C, country, (multiple): Country Examples $ ocm create rsakeypair mandelsoft.priv mandelsoft.cert issuer=mandelsoft\rSee Also ocm create\t— Create transport or component archive ","date":"0001-01-01","id":80,"permalink":"/docs/reference/ocm-cli/create/rsakeypair/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm create rsakeypair [\u0026lt;private key file\u0026gt; [\u0026lt;public key file\u0026gt;]] {\u0026lt;subject-attribute\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --ca                     create certificate for a signing authority\n      --ca-cert string         certificate authority to sign public key\n      --ca-key string          private key for certificate authority\n  -E, --encrypt                encrypt private key with new key\n  -e, --encryptionKey string   encrypt private key with given key\n  -h, --help                   help for rsakeypair\n      --root-certs string      root certificates used to validate used certificate authority\n      --validity duration      certificate validity (default 87600h0m0s)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eCreate an RSA public key pair and save to files.\u003c/p\u003e","tags":[],"title":"rsakeypair"},{"content":"Usage ocm set [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for set\rSee Also Sub Commands ocm set pubsub\t— Set the pubsub spec for an ocm repository ","date":"0001-01-01","id":81,"permalink":"/docs/reference/ocm-cli/set/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm set [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for set\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/set/pubsub/\"\u003eocm set \u003cb\u003epubsub\u003c/b\u003e\u003c/a\u003e\t — Set the pubsub spec for an ocm repository\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"set"},{"content":"Usage ocm show [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for show\rSee Also Sub Commands ocm show tags\t— show dedicated tags of OCI artifacts ocm show versions\t— show dedicated versions (semver compliant) ","date":"0001-01-01","id":82,"permalink":"/docs/reference/ocm-cli/show/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm show [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for show\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/show/tags/\"\u003eocm show \u003cb\u003etags\u003c/b\u003e\u003c/a\u003e\t — show dedicated tags of OCI artifacts\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/show/versions/\"\u003eocm show \u003cb\u003eversions\u003c/b\u003e\u003c/a\u003e\t — show dedicated versions (semver compliant)\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"show"},{"content":"Usage ocm sign [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for sign\rSee Also Sub Commands ocm sign componentversions\t— Sign component version ocm sign hash\t— sign hash ","date":"0001-01-01","id":83,"permalink":"/docs/reference/ocm-cli/sign/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm sign [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for sign\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/sign/componentversions/\"\u003eocm sign \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — Sign component version\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/sign/hash/\"\u003eocm sign \u003cb\u003ehash\u003c/b\u003e\u003c/a\u003e\t — sign hash\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"sign"},{"content":"Usage ocm add source-configuration [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;configfile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\rOptions --access YAML blob access specification (YAML) --accessComponent string component for access specification --accessHostname string hostname used for access --accessRepository string repository or registry URL --accessType string type of blob access specification --accessVersion string version for access specification --artifactId string maven artifact id --body string body of a http request --bucket string bucket name --classifier string maven classifier --commit string git commit id --digest string blob digest --extension string maven extension name --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; source extra identity (default []) --globalAccess YAML access specification for global access --groupId string maven group id --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,... http headers (default {}) -h, --help help for source-configuration --hint string (repository) hint for local artifacts --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;} identity path for specification --input YAML blob input specification (YAML) --inputComponent string component name --inputCompress compress option for input --inputData !bytesBase64 data (string, !!string or !\u0026lt;base64\u0026gt; --inputExcludes stringArray excludes (path) for inputs --inputFollowSymlinks follow symbolic links during archive creation for inputs --inputFormattedJson YAML JSON formatted text --inputHelmRepository string helm repository base URL --inputIncludes stringArray includes (path) for inputs --inputJson YAML JSON formatted text --inputLibraries stringArray library path for inputs --inputPath filepath path field for input --inputPlatforms stringArray input filter for image platforms ([os]/[architecture]) --inputPreserveDir preserve directory in archive for inputs --inputRepository string repository or registry for inputs --inputText string utf8 text --inputType string type of blob input specification --inputValues YAML YAML based generic values for inputs --inputVariants stringArray (platform) variants for inputs --inputVersion string version info for inputs --inputYaml YAML YAML formatted text --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt; source label (leading * indicates signature relevant, optional version separated by @) --mediaType string media type for artifact blob representation --name string source name --noredirect http redirect behavior --package string package or object name --reference string reference name --region string region name -s, --settings stringArray settings file with variable settings (yaml) --size int blob size --source YAML source meta data (yaml) --type string source type --url string artifact or server url --verb string http request method --version string source version\rDescription Add a source specification to a source config file used by ocm add sources.\nIt is possible to describe a single source via command line options. The meta data of this element is described by the argument of option \u0026ndash;source, which must be a YAML or JSON string. Alternatively, the name and version can be specified with the options \u0026ndash;name and \u0026ndash;version. With the option \u0026ndash;extra it is possible to add extra identity attributes. Explicitly specified options override values specified by the \u0026ndash;source option. (Note: Go templates are not supported for YAML-based option values. Besides this restriction, the finally composed element description is still processed by the selected template engine.)\nThe source type can be specified with the option \u0026ndash;type. Therefore, the minimal required meta data for elements can be completely specified by dedicated options and don\u0026rsquo;t need the YAML option.\nTo describe the content of this element one of the options \u0026ndash;access or \u0026ndash;input must be given. They take a YAML or JSON value describing an attribute set, also. The structure of those values is similar to the access or input fields of the description file format. Elements must follow the resource meta data description scheme of the component descriptor.\nIf not specified anywhere the artifact type will be defaulted to directoryTree.\nIf expressions/templates are used in the specification file an appropriate templater and the required settings might be required to provide a correct input validation.\nThis command accepts additional source specification files describing the sources to add to a component version.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" The resource specification supports the following blob input types, specified with the field type in the input field:\nInput type binary\nThis blob type is used to provide base64 encoded binary content. The specification supports the following fields:\ndata []byte\nThe binary data to provide.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputData, \u0026ndash;mediaType\nInput type dir\nThe path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no includes are specified all file not explicitly excluded are used.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to directory relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the file content should be stored compressed or not.\npreserveDir bool\nThis OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.\nfollowSymlinks bool\nThis OPTIONAL property describes whether symbolic links should be followed or included as links.\nexcludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.\nincludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputExcludes, \u0026ndash;inputFollowSymlinks, \u0026ndash;inputIncludes, \u0026ndash;inputPath, \u0026ndash;inputPreserveDir, \u0026ndash;mediaType\nInput type docker\nThe path must denote an image tag that can be found in the local docker daemon. The denoted image is packed as OCI artifact set. The OCI image will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the image name to import from the local docker daemon.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputPath\nInput type dockermulti\nThis input type describes the composition of a multi-platform OCI image. The various variants are taken from the local docker daemon. They should be built with the \u0026ldquo;buildx\u0026rdquo; command for cross platform docker builds (see https://ocm.software/docs/tutorials/best-practices/#building-multi-architecture-images). The denoted images, as well as the wrapping image index, are packed as OCI artifact set. They will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\nvariants []string\nThis REQUIRED property describes a set of image names to import from the local docker daemon used to compose a resulting image index.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputVariants\nInput type file\nThe path must denote a file relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;mediaType\nInput type git\nThe repository type allows accessing an arbitrary git repository using the manifest annotation software.ocm/component-version. The ref can be used to further specify the branch or tag to checkout, otherwise the remote HEAD is used.\nThis blob type specification supports the following fields:\nrepository string\nThis REQUIRED property describes the URL of the git repository to access. All git URL formats are supported.\nref string\nThis OPTIONAL property can be used to specify the remote branch or tag to checkout (commonly called ref). If not set, the default HEAD (remotes/origin/HEAD) of the remote is used.\ncommit string\nThis OPTIONAL property can be used to specify the commit hash to checkout. If not set, the default HEAD of the ref is used.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type helm\nThe path must denote an helm chart archive or directory relative to the resources file or a chart name in a helm chart repository. The denoted chart is packed as an OCI artifact set. For the filesystem version additional provider info is taken from a file with the same name and the suffix .prov.\nIf the chart should just be stored as plain archive, please use the type file or dir, instead.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to the helm chart relative to the resource file location.\nversion string\nThis OPTIONAL property can be set to configure an explicit version hint. If not specified the version from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.\nhelmRepository string\nThis OPTIONAL property can be set, if the helm chart should be loaded from a helm repository instead of the local filesystem. It describes the base URL of the chart repository. If specified, the path field must describe the name of the chart in the chart repository, and version must describe the version of the chart imported from the chart repository\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\ncaCertFile string\nThis OPTIONAL property can be used to specify a relative filename for the TLS root certificate used to access a helm repository.\ncaCert string\nThis OPTIONAL property can be used to specify a TLS root certificate used to access a helm repository.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputHelmRepository, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;mediaType\nInput type maven\nThe repoUrl is the url pointing either to the http endpoint of a maven repository (e.g. https://repo.maven.apache.org/maven2/) or to a file system based maven repository (e.g. file://local/directory).\nThis blob type specification supports the following fields:\nrepoUrl string\nThis REQUIRED property describes the url from which the resource is to be accessed.\ngroupId string\nThis REQUIRED property describes the groupId of a maven artifact.\nartifactId string\nThis REQUIRED property describes artifactId of a maven artifact.\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nclassifier string\nThis OPTIONAL property describes the classifier of a maven artifact.\nextension string\nThis OPTIONAL property describes the extension of a maven artifact.\nOptions used to configure fields: \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;url\nInput type npm\nThe registry is the url pointing to the npm registry from which a resource is downloaded.\nThis blob type specification supports the following fields:\nregistry string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\npackage string\nThis REQUIRED property describes the name of the package to download.\nversion string\nThis is an OPTIONAL property describing the version of the package to download. If not defined, latest will be used automatically.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion, \u0026ndash;package\nInput type ociArtifact\nThis input type is used to import an OCI image from an OCI registry. If it is a multi-arch image the set of platforms to be imported can be filtered using the \u0026ldquo;platforms\u0026rdquo; attribute. The path must denote an OCI image reference.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the OCI image reference of the image to import.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nplatforms []string\nThis OPTIONAL property can be used to filter index artifacts to include only images for dedicated operating systems/architectures. Elements must meet the syntax [\u0026lt;os\u0026gt;]/[\u0026lt;architecture\u0026gt;].\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ociImage\nDEPRECATED: This type is deprecated, please use ociArtifact instead.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ocm\nThis input type allows to get a resource artifact from an OCM repository.\nThis blob type specification supports the following fields:\nocmRepository repository specification\nThis REQUIRED property describes the OCM repository specification\ncomponent string\nThis REQUIRED property describes the component na,e\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nresourceRef relative resource reference\nThis REQUIRED property describes the resource reference for the desired resource relative to the given component version .\nOptions used to configure fields: \u0026ndash;identityPath, \u0026ndash;inputComponent, \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type spiff\nThe path must denote a spiff template relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nvalues map[string]any\nThis OPTIONAL property describes an additional value binding for the template processing. It will be available under the node inputvalues.\nlibraries []string\nThis OPTIONAL property describes a list of spiff libraries to include in template processing.\nThe variable settings from the command line are available as binding, also. They are provided under the node values.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputLibraries, \u0026ndash;inputPath, \u0026ndash;inputValues, \u0026ndash;mediaType\nInput type utf8\nThis blob type is used to provide inline text based content (UTF8). The specification supports the following fields:\ntext string\nThe utf8 string content to provide.\njson JSON or JSON string interpreted as JSON\nThe content emitted as JSON.\nformattedJson YAML/JSON or JSON/YAML string interpreted as JSON\nThe content emitted as formatted JSON.\nyaml AML/JSON or JSON/YAML string interpreted as YAML\nThe content emitted as YAML.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputFormattedJson, \u0026ndash;inputJson, \u0026ndash;inputText, \u0026ndash;inputYaml, \u0026ndash;mediaType\nInput type wget\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string\nThis OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string\nThis OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string\nThis OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte\nThis OPTIONAL property describes the http body to be included in the request.\nnoredirect bool\nThis OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nThe following list describes the supported access methods, their versions and specification formats. Typically there is special support for the CLI artifact add commands. The access method specification can be put below the access field. If always requires the field type describing the kind and version shown below.\nAccess type git\nThis method implements the access of the content of a git commit stored in a Git repository.\nThe following versions are supported:\nVersion v1alpha1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;commit, \u0026ndash;reference\nAccess type gitHub\nThis method implements the access of the content of a git commit stored in a GitHub repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessHostname, \u0026ndash;accessRepository, \u0026ndash;commit\nAccess type helm\nThis method implements the access of a Helm chart stored in a Helm repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nhelmRepository string\nHelm repository URL.\nhelmChart string\nThe name of the Helm chart and its version separated by a colon.\nversion string\nThe version of the Helm chart if not specified as part of the chart name.\ncaCert string\nAn optional TLS root certificate.\nkeyring string\nAn optional keyring used to verify the chart.\nIt uses the consumer identity type HelmChartRepository with the fields for a hostpath identity matcher (see ocm get credentials).\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type localBlob\nThis method is used to store a resource blob along with the component descriptor on behalf of the hosting OCM repository.\nIts implementation is specific to the implementation of OCM repository used to read the component descriptor. Every repository implementation may decide how and where local blobs are stored, but it MUST provide an implementation for this method.\nRegardless of the chosen implementation the attribute specification is defined globally the same.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nlocalReference string\nRepository type specific location information as string. The value may encode any deep structure, but typically just an access path is sufficient.\nmediaType string\nThe media type of the blob used to store the resource. It may add format information like +tar or +gzip.\nreferenceName (optional) string\nThis optional attribute may contain identity information used by other repositories to restore some global access with an identity related to the original source.\nFor example, if an OCI artifact originally referenced using the access method ociArtifact is stored during some transport step as local artifact, the reference name can be set to its original repository name. An import step into an OCI based OCM repository may then decide to make this artifact available again as regular OCI artifact.\nglobalAccess (optional) access method specification\nIf a resource blob is stored locally, the repository implementation may decide to provide an external access information (independent of the OCM model).\nFor example, an OCI artifact stored as local blob can be additionally stored as regular OCI artifact in an OCI registry.\nThis additional external access information can be added using a second external access method specification.\nOptions used to configure fields: \u0026ndash;globalAccess, \u0026ndash;hint, \u0026ndash;mediaType, \u0026ndash;reference\nAccess type maven\nThis method implements the access of a Maven artifact in a Maven repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nURL of the Maven repository\ngroupId string\nThe groupId of the Maven artifact\nartifactId string\nThe artifactId of the Maven artifact\nversion string\nThe version name of the Maven artifact\nclassifier string\nThe optional classifier of the Maven artifact\nextension string\nThe optional extension of the Maven artifact\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId\nAccess type none\ndummy resource with no access\nAccess type npm\nThis method implements the access of an NPM package in an NPM registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregistry string\nBase URL of the NPM registry.\npackage string\nThe name of the NPM package\nversion string\nThe version name of the NPM package\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type ociArtifact\nThis method implements the access of an OCI artifact stored in an OCI registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI image/artifact reference following the possible docker schemes:\n\u0026lt;repo\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;digest\u0026gt;@\u0026lt;tag\u0026gt; [\u0026lt;port\u0026gt;]/\u0026lt;repo path\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;version\u0026gt;@\u0026lt;tag\u0026gt; Options used to configure fields: \u0026ndash;reference\nAccess type ociBlob\nThis method implements the access of an OCI blob stored in an OCI repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI repository reference (this artifact name used to store the blob).\nmediaType string\nThe media type of the blob\ndigest string\nThe digest of the blob used to access the blob in the OCI repository.\nsize integer\nThe size of the blob\nOptions used to configure fields: \u0026ndash;digest, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;size\nAccess type ocm\nThis method implements the access of any resource artifact stored in an OCM repository. Only repository types supporting remote access should be used.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nocmRepository json\nThe repository spec for the OCM repository\ncomponent string\n(Optional) The name of the component. The default is the own component.\nversion string\n(Optional) The version of the component. The default is the own component version.\nresourceRef relative resource ref\nThe resource reference of the denoted resource relative to the given component version.\nIt uses the consumer identity and credentials for the intermediate repositories and the final resource access.\nOptions used to configure fields: \u0026ndash;accessComponent, \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;identityPath\nAccess type s3\nThis method implements the access of a blob stored in an S3 bucket.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucket string\nThe name of the S3 bucket containing the blob\nkey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nVersion v2\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucketName string\nThe name of the S3 bucket containing the blob\nobjectKey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nOptions used to configure fields: \u0026ndash;accessVersion, \u0026ndash;bucket, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;region\nAccess type wget\nThis method implements access to resources stored on an http server.\nThe following versions are supported:\nVersion v1\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string This REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string This OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string This OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string This OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte This OPTIONAL property describes the http body to be included in the request.\nnoredirect bool This OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" Examples $ ocm add source-config sources.yaml --name sources --type filesystem --access \u0026#39;{ \u0026#34;type\u0026#34;: \u0026#34;gitHub\u0026#34;, \u0026#34;repoUrl\u0026#34;: \u0026#34;ocm.software/ocm\u0026#34;, \u0026#34;commit\u0026#34;: \u0026#34;xyz\u0026#34; }\u0026#39;\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":84,"permalink":"/docs/reference/ocm-cli/add/source-configuration/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add source-configuration [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;configfile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --access YAML                         blob access specification (YAML)\n      --accessComponent string              component for access specification\n      --accessHostname string               hostname used for access\n      --accessRepository string             repository or registry URL\n      --accessType string                   type of blob access specification\n      --accessVersion string                version for access specification\n      --artifactId string                   maven artifact id\n      --body string                         body of a http request\n      --bucket string                       bucket name\n      --classifier string                   maven classifier\n      --commit string                       git commit id\n      --digest string                       blob digest\n      --extension string                    maven extension name\n      --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;                source extra identity (default [])\n      --globalAccess YAML                   access specification for global access\n      --groupId string                      maven group id\n      --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,...   http headers (default {})\n  -h, --help                                help for source-configuration\n      --hint string                         (repository) hint for local artifacts\n      --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;}       identity path for specification\n      --input YAML                          blob input specification (YAML)\n      --inputComponent string               component name\n      --inputCompress                       compress option for input\n      --inputData !bytesBase64              data (string, !!string or !\u0026lt;base64\u0026gt;\n      --inputExcludes stringArray           excludes (path) for inputs\n      --inputFollowSymlinks                 follow symbolic links during archive creation for inputs\n      --inputFormattedJson YAML             JSON formatted text\n      --inputHelmRepository string          helm repository base URL\n      --inputIncludes stringArray           includes (path) for inputs\n      --inputJson YAML                      JSON formatted text\n      --inputLibraries stringArray          library path for inputs\n      --inputPath filepath                  path field for input\n      --inputPlatforms stringArray          input filter for image platforms ([os]/[architecture])\n      --inputPreserveDir                    preserve directory in archive for inputs\n      --inputRepository string              repository or registry for inputs\n      --inputText string                    utf8 text\n      --inputType string                    type of blob input specification\n      --inputValues YAML                    YAML based generic values for inputs\n      --inputVariants stringArray           (platform) variants for inputs\n      --inputVersion string                 version info for inputs\n      --inputYaml YAML                      YAML formatted text\n      --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt;                 source label (leading * indicates signature relevant, optional version separated by @)\n      --mediaType string                    media type for artifact blob representation\n      --name string                         source name\n      --noredirect                          http redirect behavior\n      --package string                      package or object name\n      --reference string                    reference name\n      --region string                       region name\n  -s, --settings stringArray                settings file with variable settings (yaml)\n      --size int                            blob size\n      --source YAML                         source meta data (yaml)\n      --type string                         source type\n      --url string                          artifact or server url\n      --verb string                         http request method\n      --version string                      source version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdd a source specification to a source config file used by \n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/add/sources/\"\u003eocm add sources\u003c/a\u003e.\u003c/p\u003e","tags":[],"title":"source-configuration"},{"content":"Usage ocm add sources [\u0026lt;options\u0026gt;] [\u0026lt;target\u0026gt;] {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\rOptions --access YAML blob access specification (YAML) --accessComponent string component for access specification --accessHostname string hostname used for access --accessRepository string repository or registry URL --accessType string type of blob access specification --accessVersion string version for access specification --addenv access environment for templating --artifactId string maven artifact id --body string body of a http request --bucket string bucket name --classifier string maven classifier --commit string git commit id --digest string blob digest --dry-run evaluate and print source specifications --extension string maven extension name --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; source extra identity (default []) -F, --file string target file/directory (default \u0026#34;component-archive\u0026#34;) --globalAccess YAML access specification for global access --groupId string maven group id --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,... http headers (default {}) -h, --help help for sources --hint string (repository) hint for local artifacts --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;} identity path for specification --input YAML blob input specification (YAML) --inputComponent string component name --inputCompress compress option for input --inputData !bytesBase64 data (string, !!string or !\u0026lt;base64\u0026gt; --inputExcludes stringArray excludes (path) for inputs --inputFollowSymlinks follow symbolic links during archive creation for inputs --inputFormattedJson YAML JSON formatted text --inputHelmRepository string helm repository base URL --inputIncludes stringArray includes (path) for inputs --inputJson YAML JSON formatted text --inputLibraries stringArray library path for inputs --inputPath filepath path field for input --inputPlatforms stringArray input filter for image platforms ([os]/[architecture]) --inputPreserveDir preserve directory in archive for inputs --inputRepository string repository or registry for inputs --inputText string utf8 text --inputType string type of blob input specification --inputValues YAML YAML based generic values for inputs --inputVariants stringArray (platform) variants for inputs --inputVersion string version info for inputs --inputYaml YAML YAML formatted text --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt; source label (leading * indicates signature relevant, optional version separated by @) --mediaType string media type for artifact blob representation --name string source name --noredirect http redirect behavior -O, --output string output file for dry-run --package string package or object name -P, --preserve-signature preserve existing signatures --reference string reference name --region string region name -R, --replace replace existing elements -s, --settings stringArray settings file with variable settings (yaml) --size int blob size --source YAML source meta data (yaml) --templater string templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;) --type string source type --url string artifact or server url --verb string http request method --version string source version\rDescription Add information about the sources, e.g. commits in a Github repository, that have been used to create the resources specified in a resource file to a component version. So far only component archives are supported as target.\nThis command accepts source specification files describing the sources to add to a component version. Elements must follow the source meta data description scheme of the component descriptor. Besides referential sources using the access attribute to describe the access method, it is possible to describe local sources fed by local data using the input field (see below).\nThe description file might contain:\na single source a list of sources under the key sources a list of yaml documents with a single source or source list It is possible to describe a single source via command line options. The meta data of this element is described by the argument of option \u0026ndash;source, which must be a YAML or JSON string. Alternatively, the name and version can be specified with the options \u0026ndash;name and \u0026ndash;version. With the option \u0026ndash;extra it is possible to add extra identity attributes. Explicitly specified options override values specified by the \u0026ndash;source option. (Note: Go templates are not supported for YAML-based option values. Besides this restriction, the finally composed element description is still processed by the selected template engine.)\nThe source type can be specified with the option \u0026ndash;type. Therefore, the minimal required meta data for elements can be completely specified by dedicated options and don\u0026rsquo;t need the YAML option.\nTo describe the content of this element one of the options \u0026ndash;access or \u0026ndash;input must be given. They take a YAML or JSON value describing an attribute set, also. The structure of those values is similar to the access or input fields of the description file format.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" The resource specification supports the following blob input types, specified with the field type in the input field:\nInput type binary\nThis blob type is used to provide base64 encoded binary content. The specification supports the following fields:\ndata []byte\nThe binary data to provide.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputData, \u0026ndash;mediaType\nInput type dir\nThe path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no includes are specified all file not explicitly excluded are used.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to directory relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the file content should be stored compressed or not.\npreserveDir bool\nThis OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.\nfollowSymlinks bool\nThis OPTIONAL property describes whether symbolic links should be followed or included as links.\nexcludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.\nincludeFiles list of regex\nThis OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputExcludes, \u0026ndash;inputFollowSymlinks, \u0026ndash;inputIncludes, \u0026ndash;inputPath, \u0026ndash;inputPreserveDir, \u0026ndash;mediaType\nInput type docker\nThe path must denote an image tag that can be found in the local docker daemon. The denoted image is packed as OCI artifact set. The OCI image will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the image name to import from the local docker daemon.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputPath\nInput type dockermulti\nThis input type describes the composition of a multi-platform OCI image. The various variants are taken from the local docker daemon. They should be built with the \u0026ldquo;buildx\u0026rdquo; command for cross platform docker builds (see https://ocm.software/docs/tutorials/best-practices/#building-multi-architecture-images). The denoted images, as well as the wrapping image index, are packed as OCI artifact set. They will contain an informational back link to the component version using the manifest annotation software.ocm/component-version.\nThis blob type specification supports the following fields:\nvariants []string\nThis REQUIRED property describes a set of image names to import from the local docker daemon used to compose a resulting image index.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputVariants\nInput type file\nThe path must denote a file relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;mediaType\nInput type git\nThe repository type allows accessing an arbitrary git repository using the manifest annotation software.ocm/component-version. The ref can be used to further specify the branch or tag to checkout, otherwise the remote HEAD is used.\nThis blob type specification supports the following fields:\nrepository string\nThis REQUIRED property describes the URL of the git repository to access. All git URL formats are supported.\nref string\nThis OPTIONAL property can be used to specify the remote branch or tag to checkout (commonly called ref). If not set, the default HEAD (remotes/origin/HEAD) of the remote is used.\ncommit string\nThis OPTIONAL property can be used to specify the commit hash to checkout. If not set, the default HEAD of the ref is used.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type helm\nThe path must denote an helm chart archive or directory relative to the resources file or a chart name in a helm chart repository. The denoted chart is packed as an OCI artifact set. For the filesystem version additional provider info is taken from a file with the same name and the suffix .prov.\nIf the chart should just be stored as plain archive, please use the type file or dir, instead.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the file path to the helm chart relative to the resource file location.\nversion string\nThis OPTIONAL property can be set to configure an explicit version hint. If not specified the version from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.\nhelmRepository string\nThis OPTIONAL property can be set, if the helm chart should be loaded from a helm repository instead of the local filesystem. It describes the base URL of the chart repository. If specified, the path field must describe the name of the chart in the chart repository, and version must describe the version of the chart imported from the chart repository\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\ncaCertFile string\nThis OPTIONAL property can be used to specify a relative filename for the TLS root certificate used to access a helm repository.\ncaCert string\nThis OPTIONAL property can be used to specify a TLS root certificate used to access a helm repository.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputHelmRepository, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;mediaType\nInput type maven\nThe repoUrl is the url pointing either to the http endpoint of a maven repository (e.g. https://repo.maven.apache.org/maven2/) or to a file system based maven repository (e.g. file://local/directory).\nThis blob type specification supports the following fields:\nrepoUrl string\nThis REQUIRED property describes the url from which the resource is to be accessed.\ngroupId string\nThis REQUIRED property describes the groupId of a maven artifact.\nartifactId string\nThis REQUIRED property describes artifactId of a maven artifact.\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nclassifier string\nThis OPTIONAL property describes the classifier of a maven artifact.\nextension string\nThis OPTIONAL property describes the extension of a maven artifact.\nOptions used to configure fields: \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId, \u0026ndash;inputPath, \u0026ndash;inputVersion, \u0026ndash;url\nInput type npm\nThe registry is the url pointing to the npm registry from which a resource is downloaded.\nThis blob type specification supports the following fields:\nregistry string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\npackage string\nThis REQUIRED property describes the name of the package to download.\nversion string\nThis is an OPTIONAL property describing the version of the package to download. If not defined, latest will be used automatically.\nOptions used to configure fields: \u0026ndash;inputRepository, \u0026ndash;inputVersion, \u0026ndash;package\nInput type ociArtifact\nThis input type is used to import an OCI image from an OCI registry. If it is a multi-arch image the set of platforms to be imported can be filtered using the \u0026ldquo;platforms\u0026rdquo; attribute. The path must denote an OCI image reference.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the OCI image reference of the image to import.\nrepository string\nThis OPTIONAL property can be used to specify the repository hint for the generated local artifact access. It is prefixed by the component name if it does not start with slash \u0026ldquo;/\u0026rdquo;.\nplatforms []string\nThis OPTIONAL property can be used to filter index artifacts to include only images for dedicated operating systems/architectures. Elements must meet the syntax [\u0026lt;os\u0026gt;]/[\u0026lt;architecture\u0026gt;].\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ociImage\nDEPRECATED: This type is deprecated, please use ociArtifact instead.\nOptions used to configure fields: \u0026ndash;hint, \u0026ndash;inputCompress, \u0026ndash;inputPath, \u0026ndash;inputPlatforms, \u0026ndash;mediaType\nInput type ocm\nThis input type allows to get a resource artifact from an OCM repository.\nThis blob type specification supports the following fields:\nocmRepository repository specification\nThis REQUIRED property describes the OCM repository specification\ncomponent string\nThis REQUIRED property describes the component na,e\nversion string\nThis REQUIRED property describes the version of a maven artifact.\nresourceRef relative resource reference\nThis REQUIRED property describes the resource reference for the desired resource relative to the given component version .\nOptions used to configure fields: \u0026ndash;identityPath, \u0026ndash;inputComponent, \u0026ndash;inputRepository, \u0026ndash;inputVersion\nInput type spiff\nThe path must denote a spiff template relative the resources file. The content is compressed if the compress field is set to true.\nThis blob type specification supports the following fields:\npath string\nThis REQUIRED property describes the path to the file relative to the resource file location.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nvalues map[string]any\nThis OPTIONAL property describes an additional value binding for the template processing. It will be available under the node inputvalues.\nlibraries []string\nThis OPTIONAL property describes a list of spiff libraries to include in template processing.\nThe variable settings from the command line are available as binding, also. They are provided under the node values.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputLibraries, \u0026ndash;inputPath, \u0026ndash;inputValues, \u0026ndash;mediaType\nInput type utf8\nThis blob type is used to provide inline text based content (UTF8). The specification supports the following fields:\ntext string\nThe utf8 string content to provide.\njson JSON or JSON string interpreted as JSON\nThe content emitted as JSON.\nformattedJson YAML/JSON or JSON/YAML string interpreted as JSON\nThe content emitted as formatted JSON.\nyaml AML/JSON or JSON/YAML string interpreted as YAML\nThe content emitted as YAML.\nmediaType string\nThis OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.\ncompress bool\nThis OPTIONAL property describes whether the content should be stored compressed or not.\nOptions used to configure fields: \u0026ndash;inputCompress, \u0026ndash;inputFormattedJson, \u0026ndash;inputJson, \u0026ndash;inputText, \u0026ndash;inputYaml, \u0026ndash;mediaType\nInput type wget\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string\nThis REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string\nThis OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string\nThis OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string\nThis OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte\nThis OPTIONAL property describes the http body to be included in the request.\nnoredirect bool\nThis OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nThe following list describes the supported access methods, their versions and specification formats. Typically there is special support for the CLI artifact add commands. The access method specification can be put below the access field. If always requires the field type describing the kind and version shown below.\nAccess type git\nThis method implements the access of the content of a git commit stored in a Git repository.\nThe following versions are supported:\nVersion v1alpha1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;commit, \u0026ndash;reference\nAccess type gitHub\nThis method implements the access of the content of a git commit stored in a GitHub repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nRepository URL with or without scheme.\nref (optional) string\nOriginal ref used to get the commit from\ncommit string\nThe sha/id of the git commit\nOptions used to configure fields: \u0026ndash;accessHostname, \u0026ndash;accessRepository, \u0026ndash;commit\nAccess type helm\nThis method implements the access of a Helm chart stored in a Helm repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nhelmRepository string\nHelm repository URL.\nhelmChart string\nThe name of the Helm chart and its version separated by a colon.\nversion string\nThe version of the Helm chart if not specified as part of the chart name.\ncaCert string\nAn optional TLS root certificate.\nkeyring string\nAn optional keyring used to verify the chart.\nIt uses the consumer identity type HelmChartRepository with the fields for a hostpath identity matcher (see ocm get credentials).\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type localBlob\nThis method is used to store a resource blob along with the component descriptor on behalf of the hosting OCM repository.\nIts implementation is specific to the implementation of OCM repository used to read the component descriptor. Every repository implementation may decide how and where local blobs are stored, but it MUST provide an implementation for this method.\nRegardless of the chosen implementation the attribute specification is defined globally the same.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nlocalReference string\nRepository type specific location information as string. The value may encode any deep structure, but typically just an access path is sufficient.\nmediaType string\nThe media type of the blob used to store the resource. It may add format information like +tar or +gzip.\nreferenceName (optional) string\nThis optional attribute may contain identity information used by other repositories to restore some global access with an identity related to the original source.\nFor example, if an OCI artifact originally referenced using the access method ociArtifact is stored during some transport step as local artifact, the reference name can be set to its original repository name. An import step into an OCI based OCM repository may then decide to make this artifact available again as regular OCI artifact.\nglobalAccess (optional) access method specification\nIf a resource blob is stored locally, the repository implementation may decide to provide an external access information (independent of the OCM model).\nFor example, an OCI artifact stored as local blob can be additionally stored as regular OCI artifact in an OCI registry.\nThis additional external access information can be added using a second external access method specification.\nOptions used to configure fields: \u0026ndash;globalAccess, \u0026ndash;hint, \u0026ndash;mediaType, \u0026ndash;reference\nAccess type maven\nThis method implements the access of a Maven artifact in a Maven repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nrepoUrl string\nURL of the Maven repository\ngroupId string\nThe groupId of the Maven artifact\nartifactId string\nThe artifactId of the Maven artifact\nversion string\nThe version name of the Maven artifact\nclassifier string\nThe optional classifier of the Maven artifact\nextension string\nThe optional extension of the Maven artifact\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;artifactId, \u0026ndash;classifier, \u0026ndash;extension, \u0026ndash;groupId\nAccess type none\ndummy resource with no access\nAccess type npm\nThis method implements the access of an NPM package in an NPM registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregistry string\nBase URL of the NPM registry.\npackage string\nThe name of the NPM package\nversion string\nThe version name of the NPM package\nOptions used to configure fields: \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;package\nAccess type ociArtifact\nThis method implements the access of an OCI artifact stored in an OCI registry.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI image/artifact reference following the possible docker schemes:\n\u0026lt;repo\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;digest\u0026gt;@\u0026lt;tag\u0026gt; [\u0026lt;port\u0026gt;]/\u0026lt;repo path\u0026gt;/\u0026lt;artifact\u0026gt;:\u0026lt;version\u0026gt;@\u0026lt;tag\u0026gt; Options used to configure fields: \u0026ndash;reference\nAccess type ociBlob\nThis method implements the access of an OCI blob stored in an OCI repository.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nimageReference string\nOCI repository reference (this artifact name used to store the blob).\nmediaType string\nThe media type of the blob\ndigest string\nThe digest of the blob used to access the blob in the OCI repository.\nsize integer\nThe size of the blob\nOptions used to configure fields: \u0026ndash;digest, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;size\nAccess type ocm\nThis method implements the access of any resource artifact stored in an OCM repository. Only repository types supporting remote access should be used.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nocmRepository json\nThe repository spec for the OCM repository\ncomponent string\n(Optional) The name of the component. The default is the own component.\nversion string\n(Optional) The version of the component. The default is the own component version.\nresourceRef relative resource ref\nThe resource reference of the denoted resource relative to the given component version.\nIt uses the consumer identity and credentials for the intermediate repositories and the final resource access.\nOptions used to configure fields: \u0026ndash;accessComponent, \u0026ndash;accessRepository, \u0026ndash;accessVersion, \u0026ndash;identityPath\nAccess type s3\nThis method implements the access of a blob stored in an S3 bucket.\nThe following versions are supported:\nVersion v1\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucket string\nThe name of the S3 bucket containing the blob\nkey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nVersion v2\nThe type specific specification fields are:\nregion (optional) string\nOCI repository reference (this artifact name used to store the blob).\nbucketName string\nThe name of the S3 bucket containing the blob\nobjectKey string\nThe key of the desired blob\nversion (optional) string\nThe key of the desired blob\nmediaType (optional) string\nThe media type of the content\nOptions used to configure fields: \u0026ndash;accessVersion, \u0026ndash;bucket, \u0026ndash;mediaType, \u0026ndash;reference, \u0026ndash;region\nAccess type wget\nThis method implements access to resources stored on an http server.\nThe following versions are supported:\nVersion v1\nThe url is the url pointing to the http endpoint from which a resource is downloaded. The mimeType can be used to specify the MIME type of the resource.\nThis blob type specification supports the following fields:\nurl string This REQUIRED property describes the url from which the resource is to be downloaded.\nmediaType string This OPTIONAL property describes the media type of the resource to be downloaded. If omitted, ocm tries to read the mediaType from the Content-Type header of the http response. If the mediaType cannot be set from the Content-Type header as well, ocm tries to deduct the mediaType from the URL. If that is not possible either, the default media type is defaulted to application/octet-stream.\nheader map[string][]string This OPTIONAL property describes the http headers to be set in the http request to the server.\nverb string This OPTIONAL property describes the http verb (also known as http request method) for the http request. If omitted, the http verb is defaulted to GET.\nbody []byte This OPTIONAL property describes the http body to be included in the request.\nnoredirect bool This OPTIONAL property describes whether http redirects should be disabled. If omitted, it is defaulted to false (so, per default, redirects are enabled).\nOptions used to configure fields: \u0026ndash;body, \u0026ndash;header, \u0026ndash;mediaType, \u0026ndash;noredirect, \u0026ndash;url, \u0026ndash;verb\nThe \u0026ndash;replace option allows users to specify whether adding an element with the same name and extra identity but different version as an existing element, append (false) or replace (true) the existing element.\nThe \u0026ndash;preserve-signature option prohibits changes of signature relevant elements.\nAll yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, command line settings.\nNote: Variable names are case-sensitive.\nExample:\n\u0026lt;command\u003e \u0026lt;options\u003e -- MY_VAL=test \u0026lt;args\u003e There are several templaters that can be selected by the \u0026ndash;templater option:\ngo go templating supports complex values.\nkey: subkey: \"abc {{.MY_VAL}}\" none do not do any substitution.\nspiff spiff templating.\nIt supports complex values. the settings are accessible using the binding values.\nkey: subkey: \"abc (( values.MY_VAL ))\" subst simple value substitution with the drone/envsubst templater.\nIt supports string values, only. Complex settings will be json encoded.\nkey: subkey: \"abc ${MY_VAL}\" Examples $ ocm add sources --file path/to/cafile sources.yaml\rSee Also ocm add\t— Add elements to a component repository or component version ","date":"0001-01-01","id":85,"permalink":"/docs/reference/ocm-cli/add/sources/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm add sources [\u0026lt;options\u0026gt;] [\u0026lt;target\u0026gt;] {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e      --access YAML                         blob access specification (YAML)\n      --accessComponent string              component for access specification\n      --accessHostname string               hostname used for access\n      --accessRepository string             repository or registry URL\n      --accessType string                   type of blob access specification\n      --accessVersion string                version for access specification\n      --addenv                              access environment for templating\n      --artifactId string                   maven artifact id\n      --body string                         body of a http request\n      --bucket string                       bucket name\n      --classifier string                   maven classifier\n      --commit string                       git commit id\n      --digest string                       blob digest\n      --dry-run                             evaluate and print source specifications\n      --extension string                    maven extension name\n      --extra \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;                source extra identity (default [])\n  -F, --file string                         target file/directory (default \u0026#34;component-archive\u0026#34;)\n      --globalAccess YAML                   access specification for global access\n      --groupId string                      maven group id\n      --header \u0026lt;name\u0026gt;:\u0026lt;value\u0026gt;,\u0026lt;value\u0026gt;,...   http headers (default {})\n  -h, --help                                help for sources\n      --hint string                         (repository) hint for local artifacts\n      --identityPath {\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;}       identity path for specification\n      --input YAML                          blob input specification (YAML)\n      --inputComponent string               component name\n      --inputCompress                       compress option for input\n      --inputData !bytesBase64              data (string, !!string or !\u0026lt;base64\u0026gt;\n      --inputExcludes stringArray           excludes (path) for inputs\n      --inputFollowSymlinks                 follow symbolic links during archive creation for inputs\n      --inputFormattedJson YAML             JSON formatted text\n      --inputHelmRepository string          helm repository base URL\n      --inputIncludes stringArray           includes (path) for inputs\n      --inputJson YAML                      JSON formatted text\n      --inputLibraries stringArray          library path for inputs\n      --inputPath filepath                  path field for input\n      --inputPlatforms stringArray          input filter for image platforms ([os]/[architecture])\n      --inputPreserveDir                    preserve directory in archive for inputs\n      --inputRepository string              repository or registry for inputs\n      --inputText string                    utf8 text\n      --inputType string                    type of blob input specification\n      --inputValues YAML                    YAML based generic values for inputs\n      --inputVariants stringArray           (platform) variants for inputs\n      --inputVersion string                 version info for inputs\n      --inputYaml YAML                      YAML formatted text\n      --label \u0026lt;name\u0026gt;=\u0026lt;YAML\u0026gt;                 source label (leading * indicates signature relevant, optional version separated by @)\n      --mediaType string                    media type for artifact blob representation\n      --name string                         source name\n      --noredirect                          http redirect behavior\n  -O, --output string                       output file for dry-run\n      --package string                      package or object name\n  -P, --preserve-signature                  preserve existing signatures\n      --reference string                    reference name\n      --region string                       region name\n  -R, --replace                             replace existing elements\n  -s, --settings stringArray                settings file with variable settings (yaml)\n      --size int                            blob size\n      --source YAML                         source meta data (yaml)\n      --templater string                    templater to use (go, none, spiff, subst) (default \u0026#34;subst\u0026#34;)\n      --type string                         source type\n      --url string                          artifact or server url\n      --verb string                         http request method\n      --version string                      source version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eAdd information about the sources, e.g. commits in a Github repository,\nthat have been used to create the resources specified in a resource file to a component version.\nSo far only component archives are supported as target.\u003c/p\u003e","tags":[],"title":"sources"},{"content":"Usage ocm get sources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\rOptions -c, --constraints constraints version constraint -h, --help help for sources --latest restrict component versions to latest --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --recursive follow component reference nesting --repo string repository name or spec -s, --sort stringArray sort fields\rDescription Get sources of a component version. Sources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.\nIf the option \u0026ndash;constraints is given, and no version is specified for a component, only versions matching the given version constraints (semver https://github.com/Masterminds/semver) are selected. With \u0026ndash;latest only the latest matching versions will be selected.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry With the option \u0026ndash;recursive the complete reference tree of a component reference is traversed.\nIf a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default, the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json tree wide yaml See Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":86,"permalink":"/docs/reference/ocm-cli/get/sources/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get sources [\u0026lt;options\u0026gt;]  \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -c, --constraints constraints   version constraint\n  -h, --help                      help for sources\n      --latest                    restrict component versions to latest\n      --lookup stringArray        repository name or spec for closure lookup fallback\n  -o, --output string             output mode (JSON, json, tree, wide, yaml)\n  -r, --recursive                 follow component reference nesting\n      --repo string               repository name or spec\n  -s, --sort stringArray          sort fields\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet sources of a component version. Sources are specified\nby identities. An identity consists of\na name argument followed by optional \u003ccode\u003e\u0026lt;key\u0026gt;=\u0026lt;value\u0026gt;\u003c/code\u003e\narguments.\u003c/p\u003e","tags":[],"title":"sources"},{"content":"Usage ocm show tags [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;}\rOptions -h, --help help for tags -l, --latest show only latest tags --repo string repository name or spec -o, --semantic show semantic tags -s, --semver show only semver compliant tags\rDescription Match tags of an artifact against some patterns.\nIf the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax\n\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended OCI artifact references.\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nArtifactSet: v1 CommonTransportFormat: v1 DockerDaemon: v1 Empty: v1 OCIRegistry: v1 oci: v1 ociRegistry Examples $ ocm show tags ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image $ ocm oci show tags ghcr.io/open-component-model/ocm/ocm.software/ocmcli/ocmcli-image\rSee Also ocm show\t— Show tags or versions ","date":"0001-01-01","id":87,"permalink":"/docs/reference/ocm-cli/show/tags/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm show tags [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help          help for tags\n  -l, --latest        show only latest tags\n      --repo string   repository name or spec\n  -o, --semantic      show semantic tags\n  -s, --semver        show only semver compliant tags\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eMatch tags of an artifact against some patterns.\u003c/p\u003e","tags":[],"title":"tags"},{"content":"Description Tiny OCM Installer (TOI) is a small toolset on top of the Open Component Model. It provides a possibility to run images taken from a component version with user configuration and feed them with the content of this component version. It is some basic mechanism, which can be used to execute simple installation steps based on content described by the Open Component Model (see ocm bootstrap package).\nTherefore, a dedicated resource type toiPackage is defined, which describes an installation package to be handled by TOI. When calling the ocm bootstrap package command it is selected by a resource identity pattern. The first resource in given component version matching the pattern is used. A possible use case could be to provide different packages for different environments. The resource can use an identity attribute platform=\u0026lt;value\u0026gt;. By specifying just the platform attribute, the appropriate package will be chosen.\nThe bootstrap command uses this package resource to determine a TOI executor together with executor configuration and additional client specific settings to describe a dedicated installation.\nTo do this the package describes dedicated actions that can be executed by the bootstrap command. Every action (for example install) refers to an executor, which is executed to perform the action.\nAn executor is basically an image following the TOI specification for passing information into the image execution and receiving results from the execution. An executor specification can be described in two ways:\nit either directly describes a resource of type ociImage or it describes a resource of type toiExecutor, which defines the image to use and some default settings. It furthermore describes the features and requirements of the executor image. The package describes configuration values for every configured executor as well as general credentials requirements and required user configuration which must be passed along with the bootstrap command. The executor specification may then optionally map this package global settings into executor specific views.\nAfter validation of the input and its mapping to an executor specific format, finally, a container with the selected executor image is created, that contains the content of the initial component version in form of a Common Transport Archive and all the specified configuration data.\nThe execution of the container may do the needful to achieve the goal of the requested action and provide some labeled output files, which will be passed to the caller.\nThe toiPackage Resource This resource describes an installable software package, whose content is contained in the component version, which contains the package resource.\nIt is a plain yaml resource with the media types media type application/x-yaml, text/yaml or\napplication/vnd.toi.ocm.software.package.v1+yaml) containing information required to control the instantiation of an executor.\nIt has the following format:\ndescription (optional) string\nA short description of the installation package and some configuration hints.\nexecutors []ExecutorSpecification\nconfigTemplate (optional) yaml\nThis is a spiff template used to generate The user config that is finally passed to the executor. If no template is specified the user parameter input will be processed directly without template.\nconfigScheme (optional) yaml\nThis is a JSONSCHEMA used to validate the user input prior to merging with the template\ntemplateLibraries (optional) []ResourceReference\nThis is a list of resources whose content is used as additional stubs for the template processing.\ncredentials (optional) map[string]CredentialRequest\nHere the package may request the provisioning of some credentials with a dedicated name/purpose and structure. If specified the bootstrap command requites the specification of a credentials file providing the information how to satisfy those credential requests.\nadditionalResources (optional) map[string]AdditionalResource)\nA set of additional resources specified by an OCM resource reference or direct data as byte, string or yaml. The key describes the meaning of the resource. The following keys have a special meaning:\nconfigFile: an example template for a parameter file credentialsFile: an example template for a credentials file Those templates can be downloaded with ocm bootstrap configuration.\nExecutorSpecification The executor specification describes the available actions and their mapping to executors. It uses the following fields:\nactions []string\nThe list of actions this executor can be used for. If nothings is specified the executor will be used for all actions. The first matching executor entry will be used to execute an action by the bootstrap command\nresourceRef ResourceReference\nAn OCM resource reference describing a component version resource relative to the component version containing the package resource.\nconfig (optional) yaml\nThis is optional static executor config passed to the executor as is. It is to describe the set of elements on which the actual execution of the executor should work on.\nparameterMapping (optional) spiff yaml\nThis is an optional spiff template used to process the actual package parameter set passed by the caller to transform it to the requirements of the actual executor.\nA package has a global parameter setting, but possibly multiple different executors for different actions. They might have different requirements/formats concerning the parameter input. Therefore, the executor specification allows to map the provided user input, accordingly.\ncredentialMapping (optional) map[string]string\nThis is an optional mapping to map credential names used by the package to the needs of dedicated executors.\nA package has global parameter setting, but possibly multiple different executors for different action. They might have different requirements/formats concerning the parameter input. There the executor specification allows to map the provided user input, accordingly\nimage (development) object\nInstead of a resourceRef it is possible to directly specify an absolute image.\nATTENTION: this is intended for development purposes, ONLY. Do not use it for final component versions.\nIt has the field ref and the optional field digest.\noutputs (optional) map[string]string\nThis field can be used to map the names of outputs provided by a dedicated executor outputs to package outputs.\nResourceReference An OCM resource reference describes a resource of a component version. It is always evaluated relative to the component version providing the resource that contains the resource reference. It uses the following fields:\nresourcePath (optional) []Identity\nThis is sequence of reference identities used to follow a chain of component version references starting with the actual component version. If not specified the specified resource will be taken from the actual component version.\nresource Identity\nThis is the identity of the resource in the selected component version.\nAdditionalResource This field has either the fields of a ResourceReference to refer to the content of an OCM resource or the field:\ncontent string|[]byte|YAML\nEither a resource reference or the field content must be given. The content field may contain a string or an inline YAML document. For larger content the resource reference form should be preferred.\nIdentity An identity specification is a map[string]string. It describes the identity attributes of a desired resource in a component version. It always has at least one identity attribute name, which is the resource name field of the desired resource. If this resource defines additional identity attributes, the complete set must be specified.\nInput Mapping for Executors An optional parameterMapping in the executor section can be used to process the global package user-specified parameters to provide specific values expected by the executor.\nThis is done by a spiff template. Here special functions are provided to access specific content:\nhasCredentials(string[,string]) bool\nThis function can be used to check whether dedicated credentials are effectively provided for the actual installation.\nThe name is the name of the credentials as described in the credentials request section optionally mapped to the name used for the executor (field credentialMapping).\nIf the second argument is given, it checks for the named property in the credential set.\ngetCredentials(string[,string]) map[string]string | string\nThis functions provides the property set of the provided credentials.\nIf the second argument is given, it returns the named property in the selected credential set.\nIf the property name is an asterisks (*) a single property is expected, whose value is returned.\nUser Config vs Executor Config An executor is typically able to handle a complete class of installations. It describes a dedicated installation mechanism, but not a dedicated installation source. Although, there might be specialized images for dedicated installation sources, in general the idea is to provide more general executors, for example an helm executor, which is able to handle any helm chart, not just a dedicated helm deployment.\nBecause of this, there is a clear separation between an installation specific configuration, which is provided by the user calling the TOI commands, and the parameterization of the executor, which is completely specified in the package.\nThe task of the package is to represent a dedicated deployment source. As such it has to provide information to tell the executor what to install, while the user configuration is used to describe the instance specific settings.\nBack to the example of a helm installer executor, the executor config contained in the package resource describes the helm chart, which should be installed and the way how the user input is mapped to chart values. Here, also the localizations are described in an executor specific way.\nTherefore, an executor expects a dedicated configuration format, which can be specified in the executor resource in form of a JSON scheme.\nThe package then may provide a package specific scheme for the instance configuration. This value-set is dependent on the installation source (the helm chart in this example).\nFor further details you have to refer to the dedicated executor and package definitions.\nThe toiExecutor Resource Instead of directly describing an image resource in the package file, it is possible to refer to a resource of type toiExecutor. This is a yaml file with the media type application/x-yaml, text/yaml or application/vnd.toi.ocm.software.package.v1+yaml) containing common information about the executor. If this flavor is used by the package, this information is used to validate settings in the package specification.\nIt has the following format:\nimageRef ResourceReference\nThis field reference the image resource relative to the component version providing the executor resource\nconfigTemplate (optional) yaml\nThis a spiff template used to generate The executor config from the package specification that is finally passed to the executor. If no template is specified the executor config specified in the package will be processed directly without template.\nconfigScheme (optional) yaml\nThis is a JSONSCHEMA used to validate the executor config from the package prior to merging with the template\ntemplateLibraries (optional) []ResourceReference\nThis is a list of resources whose content is used as additional stubs for the template processing.\ncredentials (optional) map[string]CredentialRequest\nHere the executor may request the provisioning of some credentials with a dedicated name/purpose and structure. If specified it will be propagated to a using package. It this uses an own credentials section, this one will be filtered and checked for the actual executor.\noutputs (optional) map[string]OutputSpecification\nThis field can be used to describe the provided outputs of this executor. The OutputSpecification contains only the field description, so far. It is intended to be extended to contain further information to more formally describe the type of output.\nimage (development) object\nInstead of an imageRef it is possible to directly specify an absolute image.\nATTENTION: this is intended for development purposes, ONLY. Do not use it for final component versions.\nIt has the field ref and the optional field digest.\nClient Parameters Common to all executors a parameter file can be provided by the caller. The package specification may provide a spiff template for this parameter file. It can be used, for example to provide useful defaults. The actually provided content is merged with this template.\nTo validate user configuration a JSON scheme can be provided. The user input is validated first against this scheme before the actual merge is done.\nCredentials Additionally credentials can be requested to be provided by a client. This is done with the credentials field. It is a map of credentials names and their meaning and/or handling.\nIt uses the following fields:\ndescription string\nThis field should describe the purpose of the credential.\nproperties map[string]string\nThis field should describe the used credential fields\nconsumerId map[string]\nThis field can be used to optionally define a consumer id that should be set in the OCM support library, if used by the executor. At least the field type and one additional field must be set.\nCredentials are provided in an ocm config file (see ocm configfile). It uses a memory credential repository with the name default to store the credentials under the given name. Additionally appropriate consumer ids will be propagated, if requested in the credentials request config.\nExecutor Image Contract The executor image is called with the action as additional argument. It is expected that is defines a default entry point and a potentially empty list of standard arguments.\nIt is called with two arguments:\nname of the action to execute\nidentity of the component version containing the package the executor is executed for.\nThis can be used to access the component descriptor to get access to further described resources in the executor config\nThe container used to execute the executor image gets prepared a standard filesystem structure used to provide all the executor inputs before the execution and reading provided executor outputs after the execution.\n/ └── toi ├── inputs │ ├── config configuration from package specification │ ├── ocmrepo OCM filesystem repository containing the complete │ │ component version of the package │ └── parameters merged complete parameter file ├── outputs │ ├── \u0026lt;out\u003e any number of arbitrary output data provided │ │ by executor │ └── ... └── run good practice: typical location for the executed command After processing it is possible to return named outputs. The name of an output must be a filename. The executor section in the package specification maps those files to logical outputs in the outputs section.\n\u0026lt;file name by executor\u003e -\u003e \u0026lt;logical output name\u003e Basically the output may contain any data, but is strongly recommended to use yaml or json files, only. This enables further formal processing by the TOI toolset.\nExamples description: | This package is just an example. executors: - actions: - install resourceRef: resource: name: installerimage config: level: info # parameterMapping: # optional spiff mapping of Package configuration to # .... # executor parameters outputs: test: bla credentials: target: description: kubeconfig for target kubernetes cluster consumerId: type: Kubernetes purpose: target configTemplate: parameters: username: admin password: (( \u0026amp;merge )) configScheme: type: object required: - parameters additionalProperties: false properties: parameters: type: object required: - password additionalProperties: false properties: username: type: string password: type: string additionalResources: configFile: resource: name: config-file\rSee Also ","date":"0001-01-01","id":88,"permalink":"/docs/reference/ocm-cli/help/toi-bootstrapping/","summary":"\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eTiny OCM Installer (TOI) is a small toolset on top of the Open Component Model.\nIt provides a possibility to run images taken from a component version with user\nconfiguration and feed them with the content of this component version.\nIt is some basic mechanism, which can be used to execute simple installation\nsteps based on content described by the Open Component Model\n(see \n\n\n\n\n\n\n\u003ca href=\"https://github.com/open-component-model/ocm/blob/main/docs/reference/ocm_bootstrap_package.md\" target=\"_blank\" rel=\"noopener\"\u003eocm bootstrap package\u003c/a\u003e).\u003c/p\u003e","tags":[],"title":"toi-bootstrapping"},{"content":"Usage ocm transfer [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for transfer\rSee Also Sub Commands ocm transfer artifacts\t— transfer OCI artifacts ocm transfer commontransportarchive\t— transfer transport archive ocm transfer componentarchive\t— (DEPRECATED) - Please use commontransportarchive instead ocm transfer componentversions\t— transfer component version ","date":"0001-01-01","id":89,"permalink":"/docs/reference/ocm-cli/transfer/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm transfer [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for transfer\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/transfer/artifacts/\"\u003eocm transfer \u003cb\u003eartifacts\u003c/b\u003e\u003c/a\u003e\t — transfer OCI artifacts\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/transfer/commontransportarchive/\"\u003eocm transfer \u003cb\u003ecommontransportarchive\u003c/b\u003e\u003c/a\u003e\t — transfer transport archive\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/transfer/componentarchive/\"\u003eocm transfer \u003cb\u003ecomponentarchive\u003c/b\u003e\u003c/a\u003e\t — (DEPRECATED) - Please use commontransportarchive instead\u003c/li\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/transfer/componentversions/\"\u003eocm transfer \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — transfer component version\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"transfer"},{"content":"Usage ocm create transportarchive [\u0026lt;options\u0026gt;] \u0026lt;path\u0026gt;\rOptions -f, --force remove existing content -h, --help help for transportarchive -t, --type string archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\rDescription Create a new empty OCM/OCI transport archive. This might be either a directory prepared to host artifact content or a tar/tgz file.\nSee Also ocm create\t— Create transport or component archive ","date":"0001-01-01","id":90,"permalink":"/docs/reference/ocm-cli/create/transportarchive/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm create transportarchive [\u0026lt;options\u0026gt;] \u0026lt;path\u0026gt;\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -f, --force         remove existing content\n  -h, --help          help for transportarchive\n  -t, --type string   archive format (directory, tar, tgz) (default \u0026#34;directory\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eCreate a new empty OCM/OCI transport archive. This might be either a directory prepared\nto host artifact content or a tar/tgz file.\u003c/p\u003e","tags":[],"title":"transportarchive"},{"content":"Usage ocm get verified [\u0026lt;options\u0026gt;] {\u0026lt;component / version}\rOptions -h, --help help for verified -o, --output string output mode (JSON, json, wide, yaml) -s, --sort stringArray sort fields --verified string verified file (default \u0026#34;~/.ocm/verified\u0026#34;)\rDescription Get lists remembered verified component versions.\nWith the option \u0026ndash;output the output mode can be selected. The following modes are supported:\n(default) JSON json wide yaml Examples $ ocm get verified $ ocm get verified -f verified.yaml acme.org/component -o yaml\rSee Also ocm get\t— Get information about artifacts and components ","date":"0001-01-01","id":91,"permalink":"/docs/reference/ocm-cli/get/verified/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm get verified [\u0026lt;options\u0026gt;] {\u0026lt;component / version}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help               help for verified\n  -o, --output string      output mode (JSON, json, wide, yaml)\n  -s, --sort stringArray   sort fields\n      --verified string    verified file (default \u0026#34;~/.ocm/verified\u0026#34;)\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eGet lists remembered verified component versions.\u003c/p\u003e","tags":[],"title":"verified"},{"content":"Usage ocm verify [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\rOptions -h, --help help for verify\rSee Also Sub Commands ocm verify componentversions\t— Verify signature of component version ","date":"0001-01-01","id":92,"permalink":"/docs/reference/ocm-cli/verify/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm verify [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ...\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help   help for verify\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"see-also\"\u003eSee Also\u003c/h3\u003e\n\u003ch5 id=\"sub-commands\"\u003eSub Commands\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e\n\n\n\n\n\n  \n  \n\n\n\u003ca href=\"/docs/reference/ocm-cli/verify/componentversions/\"\u003eocm verify \u003cb\u003ecomponentversions\u003c/b\u003e\u003c/a\u003e\t — Verify signature of component version\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"verify"},{"content":"Usage ocm show versions [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;}\rOptions -h, --help help for versions -l, --latest show only latest version --repo string repository name or spec -s, --semantic show semantic version\rDescription Match versions of a component against some patterns.\nIf the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax\n\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:\n[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications\n[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:\n[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.\nUsing the JSON variant any repository types supported by the linked library can be used:\nOCI Repository types (using standard component repository to OCI mapping):\nCommonTransportFormat: v1 OCIRegistry: v1 oci: v1 ociRegistry Examples $ ocm show versions ghcr.io/mandelsoft/cnudie//github.com/mandelsoft/playground\rSee Also ocm show\t— Show tags or versions ","date":"0001-01-01","id":93,"permalink":"/docs/reference/ocm-cli/show/versions/","summary":"\u003ch3 id=\"usage\"\u003eUsage\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003eocm show versions [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"options\"\u003eOptions\u003c/h3\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  -h, --help          help for versions\n  -l, --latest        show only latest version\n      --repo string   repository name or spec\n  -s, --semantic      show semantic version\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003ch3 id=\"description\"\u003eDescription\u003c/h3\u003e\n\u003cp\u003eMatch versions of a component against some patterns.\u003c/p\u003e","tags":[],"title":"versions"},{"content":"","date":"0001-01-01","id":94,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":95,"permalink":"/community/","summary":"","tags":[],"title":"Communities"},{"content":"","date":"0001-01-01","id":96,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":97,"permalink":"/docs/","summary":"","tags":[],"title":"Documentation"},{"content":"","date":"0001-01-01","id":98,"permalink":"/","summary":"","tags":[],"title":"Open Component Model"},{"content":"","date":"0001-01-01","id":99,"permalink":"/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"","date":"0001-01-01","id":100,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"},{"content":"How to engage with us The Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\nGitHub Our GitHub repositories are the central hub for all project development. Connect with our codebase, report issues, submit pull requests, and follow our project\u0026rsquo;s progress. New contributors can find issues labeled good first issue to get started, and our detailed contribution guidelines will help you make your first successful submission.\nSlack Join our #open-component-model channel in the Kubernetes Slack workspace and connect with us and other community members.\nKubernetes Slack Membership\nIf you aren\u0026rsquo;t already a member in the Kubernetes Slack workspace, please request an invitation\nOur team is passionate about delving into diverse deployment processes, exploring patterns, aiding in design, and troubleshooting issues. Who knows? Your inquiry might inspire the development of the next useful OCM feature!\nCommunity Calls We\u0026rsquo;re excited to announce our regular community calls:\nSchedule Frequency: Every first Wednesday of the months Time: 16:00-17:00 UTC (17:00-18:00 CET, 11:00-12:00 EST, 08:00-09:00 PST) Duration: 1 hour Location: Use this Zoom Link to join the call. Call History This page contains the history of the Open Component Model community calls and links to slides and recordings.\nWhat to Expect Join us to see and discuss project updates, share your feedback, ask questions, and connect with other community members. The community calls should be an open discussion space and give a voice to any interested stakeholder. At the same time we want our community to be diverse, helpful, collaborative and fun.\nThese calls are open to everyone and will be moderated by at least one OCM Core Maintainer. We will answer anything you might bring up!\nWhat to Bring We want to hear from you! This is your chance to share your thoughts and ideas with the community. You can bring anything, including:\nIdeas how to make OCM better Issues you would like to talk about and that should be addressed Concepts you would like to work on together Questions you have about the community or upcoming work Contributing We welcome community contributions! Please see the Contributing Guideline for instructions on how to submit changes. If you are planning on making more elaborate or potentially controversial changes, please discuss them with the maintainers in the Slack channel before sending a pull request.\nCode of Conduct To make OCM a welcoming and harassment-free experience for everyone, we follow the CNCF Code of Conduct.\nSecurity Guideline In case you want to report any security vulnerabilities inside the Open Component Model project, please do not report them through public GitHub issues.\nPlease visit the Open Source Security Policy for more information.\n","date":"0001-01-01","id":101,"permalink":"/community/engagement/","summary":"\u003ch2 id=\"how-to-engage-with-us\"\u003eHow to engage with us\u003c/h2\u003e\n\u003cp\u003eThe Open Component Model is developed in the open. Here are some of the channels we use to communicate and contribute:\u003c/p\u003e","tags":[],"title":"The OCM Community"}]